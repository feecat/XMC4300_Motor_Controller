   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "sdoserv.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm u8PendingSdo,1,1
  20              	 .comm bStoreCompleteAccess,1,1
  21              	 .comm u8StoreSubindex,1,1
  22              	 .comm u16StoreIndex,2,2
  23              	 .comm u32StoreDataSize,4,4
  24              	 .comm pStoreData,4,4
  25              	 .comm pSdoPendFunc,4,4
  26              	 .comm aSdoInfoHeader,16,4
  27              	 .comm pSdoSegData,4,4
  28              	 .comm nSdoInfoFragmentsLeft,2,2
  29              	 .global cAbortCode
  30              	 .section .rodata.cAbortCode,"a",%progbits
  31              	 .align 2
  34              	cAbortCode:
  35 0000 00000000 	 .word 0
  36 0004 00000305 	 .word 84082688
  37 0008 00000405 	 .word 84148224
  38 000c 01000405 	 .word 84148225
  39 0010 05000405 	 .word 84148229
  40 0014 00000106 	 .word 100728832
  41 0018 01000106 	 .word 100728833
  42 001c 02000106 	 .word 100728834
  43 0020 00000206 	 .word 100794368
  44 0024 41000406 	 .word 100925505
  45 0028 42000406 	 .word 100925506
  46 002c 43000406 	 .word 100925507
  47 0030 47000406 	 .word 100925511
  48 0034 00000606 	 .word 101056512
  49 0038 10000706 	 .word 101122064
  50 003c 12000706 	 .word 101122066
  51 0040 13000706 	 .word 101122067
  52 0044 11000906 	 .word 101253137
  53 0048 30000906 	 .word 101253168
  54 004c 31000906 	 .word 101253169
  55 0050 32000906 	 .word 101253170
  56 0054 33000906 	 .word 101253171
  57 0058 36000906 	 .word 101253174
  58 005c 00000008 	 .word 134217728
  59 0060 20000008 	 .word 134217760
  60 0064 21000008 	 .word 134217761
  61 0068 22000008 	 .word 134217762
  62 006c 23000008 	 .word 134217763
  63 0070 03000106 	 .word 100728835
  64 0074 04000106 	 .word 100728836
  65              	 .comm nSdoInfoIndex,2,2
  66              	 .comm pSdoInfoObjEntry,4,4
  67              	 .comm pSdoResStored,4,4
  68              	 .global bSdoInWork
  69              	 .section .bss.bSdoInWork,"aw",%nobits
  72              	bSdoInWork:
  73 0000 00       	 .space 1
  74              	 .comm nSdoSegService,1,1
  75              	 .comm bSdoSegFollows,1,1
  76              	 .comm bSdoSegAccess,1,1
  77              	 .comm nSdoSegIndex,2,2
  78              	 .comm nSdoSegSubindex,1,1
  79              	 .comm nSdoSegBytesToHandle,4,4
  80              	 .comm bSdoSegLastToggle,1,1
  81              	 .comm nSdoSegCompleteSize,4,4
  82              	 .comm pSdoSegObjEntry,4,4
  83              	 .section .text.SdoDownloadSegmentInd,"ax",%progbits
  84              	 .align 2
  85              	 .thumb
  86              	 .thumb_func
  88              	SdoDownloadSegmentInd:
  89              	.LFB179:
  90              	 .file 1 "../SSC/Src/sdoserv.c"
   1:../SSC/Src/sdoserv.c **** /*
   2:../SSC/Src/sdoserv.c **** * This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & 
   3:../SSC/Src/sdoserv.c **** * The corresponding license agreement applies. This hint shall not be removed.
   4:../SSC/Src/sdoserv.c **** */
   5:../SSC/Src/sdoserv.c **** 
   6:../SSC/Src/sdoserv.c **** /**
   7:../SSC/Src/sdoserv.c **** \addtogroup CoE CAN Application Profile over EtherCAT
   8:../SSC/Src/sdoserv.c **** @{
   9:../SSC/Src/sdoserv.c **** */
  10:../SSC/Src/sdoserv.c **** 
  11:../SSC/Src/sdoserv.c **** /**
  12:../SSC/Src/sdoserv.c **** \file    sdoserv.c
  13:../SSC/Src/sdoserv.c **** \author EthercatSSC@beckhoff.com
  14:../SSC/Src/sdoserv.c **** \brief Implementation
  15:../SSC/Src/sdoserv.c **** The SDO server handles all sdo and sdo information services
  16:../SSC/Src/sdoserv.c **** 
  17:../SSC/Src/sdoserv.c **** \version 5.12
  18:../SSC/Src/sdoserv.c **** 
  19:../SSC/Src/sdoserv.c **** <br>Changes to version V5.11:<br>
  20:../SSC/Src/sdoserv.c **** V5.12 COE2: do not clear the object index low byte in case of creating a SDO Abort<br>
  21:../SSC/Src/sdoserv.c **** V5.12 COE5: updates in case of MBX_16BIT_ACCESS == 0<br>
  22:../SSC/Src/sdoserv.c **** V5.12 COE6: handle get object length in case of an out of range subindex<br>
  23:../SSC/Src/sdoserv.c **** V5.12 ECAT2: big endian changes<br>
  24:../SSC/Src/sdoserv.c **** V5.12 EOE4: handle 16bit only acceess, move ethernet protocol defines and structures to application
  25:../SSC/Src/sdoserv.c **** V5.12 MBX3: handle incomplete mailbox communication<br>
  26:../SSC/Src/sdoserv.c **** V5.12 TEST3: Send  ping request or invalid mbx data in case of access to idx 0x1009<br>
  27:../SSC/Src/sdoserv.c **** <br>Changes to version V5.10:<br>
  28:../SSC/Src/sdoserv.c **** V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
  29:../SSC/Src/sdoserv.c **** V5.11 ECAT7: add missing big endian swapping<br>
  30:../SSC/Src/sdoserv.c **** V5.11 SDO10: add new SDO abort code 0x6010004 (complete access not supported)<br>
  31:../SSC/Src/sdoserv.c **** V5.11 SDO4: "if insufficient memory is available on complete download access return ""unsupported a
  32:../SSC/Src/sdoserv.c **** <br>Changes to version V5.01:<br>
  33:../SSC/Src/sdoserv.c **** V5.10 ESC5: Add missing swapping<br>
  34:../SSC/Src/sdoserv.c **** V5.10 MBX1: Remove multiple swapping of length filed in mailbox header<br>
  35:../SSC/Src/sdoserv.c **** V5.10 SDO3: Add new SDO Abort Code (0x06090033)<br>
  36:../SSC/Src/sdoserv.c **** V5.10 SDO4: Block SDO Info services for indices less 0x1000<br>
  37:../SSC/Src/sdoserv.c **** V5.10 SDO7: Correct mailbox length calculation on segmented or normal SDO upload response<br>
  38:../SSC/Src/sdoserv.c **** V5.10 SDO8: Fix invalid fragment calculation on SdoInfo list response<br>
  39:../SSC/Src/sdoserv.c **** V5.10 TEST5: test 0x2020.1 change limit from 10 to 16 Byte <br>
  40:../SSC/Src/sdoserv.c ****              Add test object 0x3009/0x300A (huge array and record objects)<br>
  41:../SSC/Src/sdoserv.c **** <br>Changes to version V5.0:<br>
  42:../SSC/Src/sdoserv.c **** V5.01 MBX1: Allocate always complete 16Bit memory areas<br>
  43:../SSC/Src/sdoserv.c **** V5.01 SDO2: Prevent invalid memory access in case of 8Bit mailbox memory handling<br>
  44:../SSC/Src/sdoserv.c **** V5.01 SDO3: Update mailbox data length calculation<br>
  45:../SSC/Src/sdoserv.c **** V5.01 SDO4: Update length calculation in case of an segmented SDO list response<br>
  46:../SSC/Src/sdoserv.c **** V5.01 SDO6: Update SDO response interface handling. (used if the object access function returns "AB
  47:../SSC/Src/sdoserv.c **** V5.01 TEST2: Change Test 0x2020.1 (force Segmented transfer) to 16Byte<br>
  48:../SSC/Src/sdoserv.c **** <br>Changes to version V4.40:<br>
  49:../SSC/Src/sdoserv.c **** V5.0 TEST1: Add test application. see Application Note ET9300 for more details.<br>
  50:../SSC/Src/sdoserv.c **** V5.0 MBX3: Calculate MBX datagram length independent of SM size.<br>
  51:../SSC/Src/sdoserv.c **** V5.0 SDO2: SDO toggle bit don not do be cleared for segmented communication.<br>
  52:../SSC/Src/sdoserv.c **** V5.0 SDO3: Set SDO OpCode in list response.<br>
  53:../SSC/Src/sdoserv.c **** V5.0 SDO4: Update abort code for "BIG_ENDIAN_16BIT" configuration.<br>
  54:../SSC/Src/sdoserv.c **** V5.0 SDO5: Object code was calculated wrong for SDO Info service.<br>
  55:../SSC/Src/sdoserv.c **** V5.0 SDO6: Handle SDO segmented transfer if only 16Bit MBX memory access is allowed. <br>
  56:../SSC/Src/sdoserv.c **** <br>Changes to version V4.20:<br>
  57:../SSC/Src/sdoserv.c **** V4.40 SDO1: change size calculation for SDO services<br>
  58:../SSC/Src/sdoserv.c **** V4.40 MBX1: Prevent accessing odd address<br>
  59:../SSC/Src/sdoserv.c **** V4.40 COE1: Abort code is set in OBJ_GetObjectList()<br>
  60:../SSC/Src/sdoserv.c **** <br>Changes to version V4.11:<br>
  61:../SSC/Src/sdoserv.c **** V4.20 PIC24: Add EL9800_4 (PIC24) required source code<br>
  62:../SSC/Src/sdoserv.c **** V4.20 SDO 2: SDO mask value bug<br>
  63:../SSC/Src/sdoserv.c **** V4.20 SDO 1: check zero size object length<br>
  64:../SSC/Src/sdoserv.c **** <br>Changes to version V4.10:<br>
  65:../SSC/Src/sdoserv.c **** V4.11 SDO 1: fixed calculation of frame fragments during a object dictionary array list request<br>
  66:../SSC/Src/sdoserv.c **** V4.11 SDO 2-3: fixed size of entry description<br>
  67:../SSC/Src/sdoserv.c **** V4.11 SDO 4-7: add STRUCT_PACKED defines<br>
  68:../SSC/Src/sdoserv.c **** <br>Changes to version V4.08:\a<br>
  69:../SSC/Src/sdoserv.c **** V4.10 SDO 1: fixed zero size SDO comparison<br>
  70:../SSC/Src/sdoserv.c **** V4.10 SDO 2: set SdoService_CommandOffset to 0<br>
  71:../SSC/Src/sdoserv.c **** V4.10 SDO 3: fixed zero size SDO comparison<br>
  72:../SSC/Src/sdoserv.c **** V4.10 SDO 4: fixed struct_packed definition<br>
  73:../SSC/Src/sdoserv.c **** <br>Changes to version V4.07:<br>
  74:../SSC/Src/sdoserv.c **** V4.08 SDO 1: For an upload segment response the toggle bit was overwritten<br>
  75:../SSC/Src/sdoserv.c **** V4.08 SDO 2: For a segmented response the command was wrong in the response<br>
  76:../SSC/Src/sdoserv.c **** <br>Changes to version V4.06:<br>
  77:../SSC/Src/sdoserv.c **** V4.07 SDO 1: In SdoRes the command specifier was not set correctly in case of an abort<br>
  78:../SSC/Src/sdoserv.c **** V4.07 ECAT 1: The sources for SPI and MCI were merged (in ecat_def.h<br>
  79:../SSC/Src/sdoserv.c ****                    set the switch MCI_HW to 1 when using the MCI,<br>
  80:../SSC/Src/sdoserv.c ****                    set the switch SPI_HW to 1 when using the SPI<br>
  81:../SSC/Src/sdoserv.c **** <br>Changes to version V4.05:<br>
  82:../SSC/Src/sdoserv.c **** V4.06 SDO 1: The variable dataSize was used wrong in function SdoRes<br>
  83:../SSC/Src/sdoserv.c **** <br>Changes to version V4.03:<br>
  84:../SSC/Src/sdoserv.c **** V4.04 SDO 1: The SDO interface was changed in that way that a SDO response<br>
  85:../SSC/Src/sdoserv.c ****              could be sent by the application to a later time. In that case<br>
  86:../SSC/Src/sdoserv.c ****                  the functions OBJ_Read and OBJ_Write shall return the value<br>
  87:../SSC/Src/sdoserv.c ****                  ABORTIDX_WORKING. To send the SDO response the new function SDOS_SdoRes<br>
  88:../SSC/Src/sdoserv.c ****                  has to be called by the application. While waiting for the call<br>
  89:../SSC/Src/sdoserv.c ****                  of SDOS_SdoRes the SDO interface will answer to another SDO request<br>
  90:../SSC/Src/sdoserv.c ****                  with the error MBXERR_SERVICEINWORK in the mailbox protocol <br>
  91:../SSC/Src/sdoserv.c **** <br>Changes to version V3.20:<br>
  92:../SSC/Src/sdoserv.c **** V4.00 SDO 1: The size of the written data in case of a SDO Download will be<br>
  93:../SSC/Src/sdoserv.c ****              in the function OBJ_Write to be more flexible<br>
  94:../SSC/Src/sdoserv.c **** V4.00 SDO 2: The object lists will be generated in the functions OBJ_GetNoOfObjects<br>
  95:../SSC/Src/sdoserv.c ****              and OBJ_GetObjectList in objdef.c to decouple the SDO services from<br>
  96:../SSC/Src/sdoserv.c ****              the implementation of the object dictionary<br>
  97:../SSC/Src/sdoserv.c **** V4.00 SDO 3: The name of an object or entry description will only be transmitted<br>
  98:../SSC/Src/sdoserv.c ****              if it fits in the mailbox because the fragmentation is not supported in the sample cod
  99:../SSC/Src/sdoserv.c **** V4.00 SDO 4: SDOs with size greater than 65535 were not handled correctly, that is fixed now
 100:../SSC/Src/sdoserv.c **** */
 101:../SSC/Src/sdoserv.c **** 
 102:../SSC/Src/sdoserv.c **** /*---------------------------------------------------------------------------------------
 103:../SSC/Src/sdoserv.c **** ------
 104:../SSC/Src/sdoserv.c **** ------    Includes
 105:../SSC/Src/sdoserv.c **** ------
 106:../SSC/Src/sdoserv.c **** ---------------------------------------------------------------------------------------*/
 107:../SSC/Src/sdoserv.c **** 
 108:../SSC/Src/sdoserv.c **** #include "ecat_def.h"
 109:../SSC/Src/sdoserv.c **** 
 110:../SSC/Src/sdoserv.c **** #include "ecatslv.h"
 111:../SSC/Src/sdoserv.c **** 
 112:../SSC/Src/sdoserv.c **** 
 113:../SSC/Src/sdoserv.c **** #define _SDOSERV_ 1
 114:../SSC/Src/sdoserv.c **** #include "objdef.h"
 115:../SSC/Src/sdoserv.c **** #undef  _SDOSERV_
 116:../SSC/Src/sdoserv.c **** /*remove definition of _SDOSERV_ (#ifdef is used in objdef.h)*/
 117:../SSC/Src/sdoserv.c **** 
 118:../SSC/Src/sdoserv.c **** 
 119:../SSC/Src/sdoserv.c **** 
 120:../SSC/Src/sdoserv.c **** 
 121:../SSC/Src/sdoserv.c **** 
 122:../SSC/Src/sdoserv.c **** extern OBJCONST TOBJECT OBJMEM asObjDef[];
 123:../SSC/Src/sdoserv.c **** extern UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT1
 124:../SSC/Src/sdoserv.c **** extern OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UI
 125:../SSC/Src/sdoserv.c **** extern OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry);
 126:../SSC/Src/sdoserv.c **** 
 127:../SSC/Src/sdoserv.c **** /*---------------------------------------------------------------------------------------
 128:../SSC/Src/sdoserv.c **** ------
 129:../SSC/Src/sdoserv.c **** ------    Modulintern variable definitions
 130:../SSC/Src/sdoserv.c **** ------
 131:../SSC/Src/sdoserv.c **** ---------------------------------------------------------------------------------------*/
 132:../SSC/Src/sdoserv.c **** 
 133:../SSC/Src/sdoserv.c **** const UINT32 MBXMEM cAbortCode[] =
 134:../SSC/Src/sdoserv.c **** {
 135:../SSC/Src/sdoserv.c ****     ABORT_NOERROR,
 136:../SSC/Src/sdoserv.c ****     ABORT_TOGGLE_BIT_NOT_CHANGED,
 137:../SSC/Src/sdoserv.c ****     ABORT_SDO_PROTOCOL_TIMEOUT,
 138:../SSC/Src/sdoserv.c ****     ABORT_COMMAND_SPECIFIER_UNKNOWN,
 139:../SSC/Src/sdoserv.c ****     ABORT_OUT_OF_MEMORY,
 140:../SSC/Src/sdoserv.c ****     ABORT_UNSUPPORTED_ACCESS,
 141:../SSC/Src/sdoserv.c ****     ABORT_WRITE_ONLY_ENTRY,
 142:../SSC/Src/sdoserv.c ****     ABORT_READ_ONLY_ENTRY,
 143:../SSC/Src/sdoserv.c ****     ABORT_OBJECT_NOT_EXISTING,
 144:../SSC/Src/sdoserv.c ****     ABORT_OBJECT_CANT_BE_PDOMAPPED,
 145:../SSC/Src/sdoserv.c ****     ABORT_MAPPED_OBJECTS_EXCEED_PDO,
 146:../SSC/Src/sdoserv.c ****     ABORT_PARAM_IS_INCOMPATIBLE,
 147:../SSC/Src/sdoserv.c ****     ABORT_INTERNAL_DEVICE_INCOMPATIBILITY,
 148:../SSC/Src/sdoserv.c ****     ABORT_HARDWARE_ERROR,
 149:../SSC/Src/sdoserv.c ****     ABORT_PARAM_LENGTH_ERROR,
 150:../SSC/Src/sdoserv.c ****     ABORT_PARAM_LENGTH_TOO_LONG,
 151:../SSC/Src/sdoserv.c ****     ABORT_PARAM_LENGTH_TOO_SHORT,
 152:../SSC/Src/sdoserv.c ****     ABORT_SUBINDEX_NOT_EXISTING,
 153:../SSC/Src/sdoserv.c ****     ABORT_VALUE_EXCEEDED,
 154:../SSC/Src/sdoserv.c ****     ABORT_VALUE_TOO_GREAT,
 155:../SSC/Src/sdoserv.c ****     ABORT_VALUE_TOO_SMALL,
 156:../SSC/Src/sdoserv.c ****     ABORT_MODULE_ID_LIST_NOT_MATCH,
 157:../SSC/Src/sdoserv.c ****     ABORT_MAX_VALUE_IS_LESS_THAN_MIN_VALUE,
 158:../SSC/Src/sdoserv.c ****     ABORT_GENERAL_ERROR,
 159:../SSC/Src/sdoserv.c ****     ABORT_DATA_CANNOT_BE_READ_OR_STORED,
 160:../SSC/Src/sdoserv.c ****     ABORT_DATA_CANNOT_BE_READ_OR_STORED_BECAUSE_OF_LOCAL_CONTROL,
 161:../SSC/Src/sdoserv.c ****     ABORT_DATA_CANNOT_BE_READ_OR_STORED_IN_THIS_STATE,
 162:../SSC/Src/sdoserv.c ****     ABORT_NO_OBJECT_DICTIONARY_IS_PRESENT,
 163:../SSC/Src/sdoserv.c ****     ABORT_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0,
 164:../SSC/Src/sdoserv.c ****     ABORT_COMPLETE_ACCESS_NOT_SUPPORTED
 165:../SSC/Src/sdoserv.c **** };
 166:../SSC/Src/sdoserv.c **** 
 167:../SSC/Src/sdoserv.c **** UINT16 VARMEM                            nSdoInfoIndex;
 168:../SSC/Src/sdoserv.c **** OBJCONST TOBJECT OBJMEM * VARMEM        pSdoInfoObjEntry;
 169:../SSC/Src/sdoserv.c **** 
 170:../SSC/Src/sdoserv.c **** TINITSDOMBX MBXMEM *    VARMEM            pSdoResStored;
 171:../SSC/Src/sdoserv.c **** BOOL    VARMEM                            bSdoInWork = FALSE;
 172:../SSC/Src/sdoserv.c **** 
 173:../SSC/Src/sdoserv.c **** UINT8    VARMEM                         nSdoSegService;
 174:../SSC/Src/sdoserv.c **** UINT8    VARMEM                         bSdoSegFollows;
 175:../SSC/Src/sdoserv.c **** UINT8    VARMEM                         bSdoSegAccess;
 176:../SSC/Src/sdoserv.c **** UINT16 VARMEM                           nSdoSegIndex;
 177:../SSC/Src/sdoserv.c **** UINT8 VARMEM                            nSdoSegSubindex;
 178:../SSC/Src/sdoserv.c **** UINT32 VARMEM                           nSdoSegBytesToHandle;
 179:../SSC/Src/sdoserv.c **** UINT8 VARMEM                            bSdoSegLastToggle;
 180:../SSC/Src/sdoserv.c **** UINT32 VARMEM                           nSdoSegCompleteSize;
 181:../SSC/Src/sdoserv.c **** OBJCONST TOBJECT OBJMEM * VARMEM        pSdoSegObjEntry;
 182:../SSC/Src/sdoserv.c **** 
 183:../SSC/Src/sdoserv.c **** /*---------------------------------------------------------------------------------------
 184:../SSC/Src/sdoserv.c **** ------
 185:../SSC/Src/sdoserv.c **** ------    module internal function declarations
 186:../SSC/Src/sdoserv.c **** ------
 187:../SSC/Src/sdoserv.c **** ---------------------------------------------------------------------------------------*/
 188:../SSC/Src/sdoserv.c **** static UINT8 SdoDownloadSegmentInd(TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd);
 189:../SSC/Src/sdoserv.c **** static UINT8 SdoUploadSegmentInd(TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd);
 190:../SSC/Src/sdoserv.c **** /*---------------------------------------------------------------------------------------
 191:../SSC/Src/sdoserv.c **** ------
 192:../SSC/Src/sdoserv.c **** ------    Functions
 193:../SSC/Src/sdoserv.c **** ------
 194:../SSC/Src/sdoserv.c **** ---------------------------------------------------------------------------------------*/
 195:../SSC/Src/sdoserv.c **** 
 196:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 197:../SSC/Src/sdoserv.c **** /**
 198:../SSC/Src/sdoserv.c ****  \param     pSdoInd    Pointer to the received mailbox data from the master.
 199:../SSC/Src/sdoserv.c **** 
 200:../SSC/Src/sdoserv.c ****  \return    Indicates if an error occurred while the operation ( good = 0 ).
 201:../SSC/Src/sdoserv.c **** 
 202:../SSC/Src/sdoserv.c ****  \brief    This function is called when a Download SDO Segment request
 203:../SSC/Src/sdoserv.c ****             service is received from the master. If its the last segment
 204:../SSC/Src/sdoserv.c ****             the data will be written to the object dictionary. The
 205:../SSC/Src/sdoserv.c ****             function sends a response by itself.
 206:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 207:../SSC/Src/sdoserv.c **** 
 208:../SSC/Src/sdoserv.c **** static UINT8 SdoDownloadSegmentInd( TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd )
 209:../SSC/Src/sdoserv.c **** {
  91              	 .loc 1 209 0
  92              	 .cfi_startproc
  93              	 
  94              	 
  95 0000 B0B5     	 push {r4,r5,r7,lr}
  96              	.LCFI0:
  97              	 .cfi_def_cfa_offset 16
  98              	 .cfi_offset 4,-16
  99              	 .cfi_offset 5,-12
 100              	 .cfi_offset 7,-8
 101              	 .cfi_offset 14,-4
 102 0002 88B0     	 sub sp,sp,#32
 103              	.LCFI1:
 104              	 .cfi_def_cfa_offset 48
 105 0004 02AF     	 add r7,sp,#8
 106              	.LCFI2:
 107              	 .cfi_def_cfa 7,40
 108 0006 7860     	 str r0,[r7,#4]
 210:../SSC/Src/sdoserv.c ****     UINT8 abort = 0;
 109              	 .loc 1 210 0
 110 0008 0023     	 movs r3,#0
 111 000a FB75     	 strb r3,[r7,#23]
 211:../SSC/Src/sdoserv.c ****     UINT32 bytesToSave = 0;
 112              	 .loc 1 211 0
 113 000c 0023     	 movs r3,#0
 114 000e 3B61     	 str r3,[r7,#16]
 212:../SSC/Src/sdoserv.c **** 
 213:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12) ECAT2*/
 214:../SSC/Src/sdoserv.c ****     if ( SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle )
 115              	 .loc 1 214 0
 116 0010 7B68     	 ldr r3,[r7,#4]
 117 0012 1B7A     	 ldrb r3,[r3,#8]
 118 0014 03F01003 	 and r3,r3,#16
 119 0018 864A     	 ldr r2,.L24
 120 001a 1278     	 ldrb r2,[r2]
 121 001c 9342     	 cmp r3,r2
 122 001e 02D1     	 bne .L2
 215:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12) ECAT2*/
 216:../SSC/Src/sdoserv.c ****     {
 217:../SSC/Src/sdoserv.c ****         /* toggle bit has not toggled... */
 218:../SSC/Src/sdoserv.c ****         abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
 123              	 .loc 1 218 0
 124 0020 0123     	 movs r3,#1
 125 0022 FB75     	 strb r3,[r7,#23]
 126 0024 BBE0     	 b .L3
 127              	.L2:
 128              	.LBB2:
 219:../SSC/Src/sdoserv.c ****     }
 220:../SSC/Src/sdoserv.c ****     else
 221:../SSC/Src/sdoserv.c ****     {
 222:../SSC/Src/sdoserv.c ****         /* maxData contains the maximum data to be received with a SDO-DownloadSegment */
 223:../SSC/Src/sdoserv.c ****         UINT16 maxData =    u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
 129              	 .loc 1 223 0
 130 0026 844B     	 ldr r3,.L24+4
 131 0028 1B88     	 ldrh r3,[r3]
 132 002a 093B     	 subs r3,r3,#9
 133 002c FB81     	 strh r3,[r7,#14]
 224:../SSC/Src/sdoserv.c ****         /* the new toggle bit is stored in bSdoSegLastToggle */
 225:../SSC/Src/sdoserv.c ****         /* ECATCHANGE_START(V5.12) ECAT2*/
 226:../SSC/Src/sdoserv.c ****         bSdoSegLastToggle = SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE);
 134              	 .loc 1 226 0
 135 002e 7B68     	 ldr r3,[r7,#4]
 136 0030 1B7A     	 ldrb r3,[r3,#8]
 137 0032 03F01003 	 and r3,r3,#16
 138 0036 DAB2     	 uxtb r2,r3
 139 0038 7E4B     	 ldr r3,.L24
 140 003a 1A70     	 strb r2,[r3]
 227:../SSC/Src/sdoserv.c ****         /* ECATCHANGE_END(V5.12) ECAT2*/
 228:../SSC/Src/sdoserv.c **** 
 229:../SSC/Src/sdoserv.c ****         /* a SDO-Download Segment is only allowed if a SDO-Download Request was received before,
 230:../SSC/Src/sdoserv.c ****            in that case a buffer for the received data was allocated in SDOS_SdoInd before */
 231:../SSC/Src/sdoserv.c ****         if ( pSdoSegData )
 141              	 .loc 1 231 0
 142 003c 7F4B     	 ldr r3,.L24+8
 143 003e 1B68     	 ldr r3,[r3]
 144 0040 002B     	 cmp r3,#0
 145 0042 00F0AA80 	 beq .L4
 232:../SSC/Src/sdoserv.c ****         {
 233:../SSC/Src/sdoserv.c ****             /* bytesToSave contains the remaining data with this and maybe the following
 234:../SSC/Src/sdoserv.c ****                SDO-Download Segment services */
 235:../SSC/Src/sdoserv.c ****             bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
 146              	 .loc 1 235 0
 147 0046 7E4B     	 ldr r3,.L24+12
 148 0048 1A68     	 ldr r2,[r3]
 149 004a 7E4B     	 ldr r3,.L24+16
 150 004c 1B68     	 ldr r3,[r3]
 151 004e D31A     	 subs r3,r2,r3
 152 0050 3B61     	 str r3,[r7,#16]
 236:../SSC/Src/sdoserv.c **** 
 237:../SSC/Src/sdoserv.c ****             if ( pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS )
 153              	 .loc 1 237 0
 154 0052 7B68     	 ldr r3,[r7,#4]
 155 0054 1B7A     	 ldrb r3,[r3,#8]
 156 0056 03F00103 	 and r3,r3,#1
 157 005a 002B     	 cmp r3,#0
 158 005c 2CD0     	 beq .L5
 238:../SSC/Src/sdoserv.c ****             {
 239:../SSC/Src/sdoserv.c ****                 /* the last segment is received, check if the length of the remaining data is the
 240:../SSC/Src/sdoserv.c ****                    same as the length of the received data */
 241:../SSC/Src/sdoserv.c ****                 if ( bytesToSave <= maxData )
 159              	 .loc 1 241 0
 160 005e FA89     	 ldrh r2,[r7,#14]
 161 0060 3B69     	 ldr r3,[r7,#16]
 162 0062 9A42     	 cmp r2,r3
 163 0064 25D3     	 bcc .L6
 164              	.LBB3:
 242:../SSC/Src/sdoserv.c ****                 {
 243:../SSC/Src/sdoserv.c ****                     UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
 165              	 .loc 1 243 0
 166 0066 7B68     	 ldr r3,[r7,#4]
 167 0068 1B88     	 ldrh r3,[r3]
 168 006a BB81     	 strh r3,[r7,#12]
 244:../SSC/Src/sdoserv.c **** 
 245:../SSC/Src/sdoserv.c ****                     /* for the check it is distinguished if the remaining bytes are less than 8 (in
 246:../SSC/Src/sdoserv.c ****                        case 7 data bytes were sent and the SDO-Download Segment header contains the
 247:../SSC/Src/sdoserv.c ****                         how much bytes are valid (CAN-compatibility)), otherwise the length has to 
 248:../SSC/Src/sdoserv.c ****                         and the SDO-Download Segment-Headerbyte is ignored */
 249:../SSC/Src/sdoserv.c ****                     if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
 169              	 .loc 1 249 0
 170 006c BB89     	 ldrh r3,[r7,#12]
 171 006e 033B     	 subs r3,r3,#3
 172 0070 1A46     	 mov r2,r3
 173 0072 3B69     	 ldr r3,[r7,#16]
 174 0074 9A42     	 cmp r2,r3
 175 0076 0CD3     	 bcc .L7
 250:../SSC/Src/sdoserv.c ****                          &&( bytesToSave == ((UINT16) (MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.Se
 176              	 .loc 1 250 0
 177 0078 7B68     	 ldr r3,[r7,#4]
 178 007a 1B7A     	 ldrb r3,[r3,#8]
 179 007c 03F00E03 	 and r3,r3,#14
 180 0080 5B10     	 asrs r3,r3,#1
 181 0082 9BB2     	 uxth r3,r3
 182 0084 C3F10703 	 rsb r3,r3,#7
 183 0088 9BB2     	 uxth r3,r3
 184 008a 1A46     	 mov r2,r3
 185 008c 3B69     	 ldr r3,[r7,#16]
 186 008e 9A42     	 cmp r2,r3
 187 0090 08D0     	 beq .L8
 188              	.L7:
 251:../SSC/Src/sdoserv.c ****                           )
 252:../SSC/Src/sdoserv.c ****                         ||( ( bytesToSave > MIN_SEGMENTED_DATA )
 189              	 .loc 1 252 0
 190 0092 3B69     	 ldr r3,[r7,#16]
 191 0094 072B     	 cmp r3,#7
 192 0096 09D9     	 bls .L9
 253:../SSC/Src/sdoserv.c ****                         && (bytesToSave == (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
 193              	 .loc 1 253 0
 194 0098 BB89     	 ldrh r3,[r7,#12]
 195 009a 033B     	 subs r3,r3,#3
 196 009c 1A46     	 mov r2,r3
 197 009e 3B69     	 ldr r3,[r7,#16]
 198 00a0 9A42     	 cmp r2,r3
 199 00a2 03D1     	 bne .L9
 200              	.L8:
 254:../SSC/Src/sdoserv.c ****                         ) )
 255:../SSC/Src/sdoserv.c ****                     {
 256:../SSC/Src/sdoserv.c ****                         /* length is correct */
 257:../SSC/Src/sdoserv.c ****                         bSdoSegFollows = FALSE;
 201              	 .loc 1 257 0
 202 00a4 684B     	 ldr r3,.L24+20
 203 00a6 0022     	 movs r2,#0
 204 00a8 1A70     	 strb r2,[r3]
 205 00aa 11E0     	 b .L12
 206              	.L9:
 258:../SSC/Src/sdoserv.c ****                     }
 259:../SSC/Src/sdoserv.c ****                     else
 260:../SSC/Src/sdoserv.c ****                     {
 261:../SSC/Src/sdoserv.c ****                         abort = ABORTIDX_PARAM_LENGTH_ERROR;
 207              	 .loc 1 261 0
 208 00ac 0E23     	 movs r3,#14
 209 00ae FB75     	 strb r3,[r7,#23]
 210              	.LBE3:
 211 00b0 0EE0     	 b .L12
 212              	.L6:
 262:../SSC/Src/sdoserv.c ****                     }
 263:../SSC/Src/sdoserv.c ****                 }
 264:../SSC/Src/sdoserv.c ****                 else
 265:../SSC/Src/sdoserv.c ****                 {
 266:../SSC/Src/sdoserv.c ****                     abort = ABORTIDX_PARAM_LENGTH_ERROR;
 213              	 .loc 1 266 0
 214 00b2 0E23     	 movs r3,#14
 215 00b4 FB75     	 strb r3,[r7,#23]
 216 00b6 0BE0     	 b .L12
 217              	.L5:
 267:../SSC/Src/sdoserv.c ****                 }
 268:../SSC/Src/sdoserv.c ****             }
 269:../SSC/Src/sdoserv.c ****             else
 270:../SSC/Src/sdoserv.c ****             {
 271:../SSC/Src/sdoserv.c ****                 /* its not the last segment */
 272:../SSC/Src/sdoserv.c ****                 bSdoSegFollows = TRUE;
 218              	 .loc 1 272 0
 219 00b8 634B     	 ldr r3,.L24+20
 220 00ba 0122     	 movs r2,#1
 221 00bc 1A70     	 strb r2,[r3]
 273:../SSC/Src/sdoserv.c ****                 /* we have to check if we expect less bytes than the maximum size which can be send
 274:../SSC/Src/sdoserv.c ****                    SDO Download Segment */
 275:../SSC/Src/sdoserv.c ****                 if ( bytesToSave <= maxData )
 222              	 .loc 1 275 0
 223 00be FA89     	 ldrh r2,[r7,#14]
 224 00c0 3B69     	 ldr r3,[r7,#16]
 225 00c2 9A42     	 cmp r2,r3
 226 00c4 02D3     	 bcc .L13
 276:../SSC/Src/sdoserv.c ****                 {
 277:../SSC/Src/sdoserv.c ****                     abort = ABORTIDX_PARAM_LENGTH_ERROR;
 227              	 .loc 1 277 0
 228 00c6 0E23     	 movs r3,#14
 229 00c8 FB75     	 strb r3,[r7,#23]
 230 00ca 01E0     	 b .L12
 231              	.L13:
 278:../SSC/Src/sdoserv.c ****                 }
 279:../SSC/Src/sdoserv.c ****                 else
 280:../SSC/Src/sdoserv.c ****                 {
 281:../SSC/Src/sdoserv.c ****                     /* length is okay, bytesToSave contains the data size to be copied */
 282:../SSC/Src/sdoserv.c ****                     bytesToSave = maxData;
 232              	 .loc 1 282 0
 233 00cc FB89     	 ldrh r3,[r7,#14]
 234 00ce 3B61     	 str r3,[r7,#16]
 235              	.L12:
 283:../SSC/Src/sdoserv.c ****                 }
 284:../SSC/Src/sdoserv.c ****             }
 285:../SSC/Src/sdoserv.c **** 
 286:../SSC/Src/sdoserv.c ****             if ( abort == 0 )
 236              	 .loc 1 286 0
 237 00d0 FB7D     	 ldrb r3,[r7,#23]
 238 00d2 002B     	 cmp r3,#0
 239 00d4 63D1     	 bne .L3
 287:../SSC/Src/sdoserv.c ****             {
 288:../SSC/Src/sdoserv.c ****                 /* the received data is copied in the buffer */
 289:../SSC/Src/sdoserv.c ****                 MBXMEMCPY( ((UINT8*)pSdoSegData) + (nSdoSegBytesToHandle), pSdoInd->SdoHeader.Data,
 240              	 .loc 1 289 0
 241 00d6 594B     	 ldr r3,.L24+8
 242 00d8 1A68     	 ldr r2,[r3]
 243 00da 5A4B     	 ldr r3,.L24+16
 244 00dc 1B68     	 ldr r3,[r3]
 245 00de 1A44     	 add r2,r2,r3
 246 00e0 7B68     	 ldr r3,[r7,#4]
 247 00e2 0933     	 adds r3,r3,#9
 248 00e4 1046     	 mov r0,r2
 249 00e6 1946     	 mov r1,r3
 250 00e8 3A69     	 ldr r2,[r7,#16]
 251 00ea FFF7FEFF 	 bl memcpy
 290:../SSC/Src/sdoserv.c **** 
 291:../SSC/Src/sdoserv.c ****                 if ( bSdoSegFollows == FALSE    )
 252              	 .loc 1 291 0
 253 00ee 564B     	 ldr r3,.L24+20
 254 00f0 1B78     	 ldrb r3,[r3]
 255 00f2 002B     	 cmp r3,#0
 256 00f4 53D1     	 bne .L3
 292:../SSC/Src/sdoserv.c ****                 {
 293:../SSC/Src/sdoserv.c ****                     /* it was the last segment, OBJ_Write will called to make the Write-operation *
 294:../SSC/Src/sdoserv.c ****                     abort = OBJ_Write( nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegO
 257              	 .loc 1 294 0
 258 00f6 554B     	 ldr r3,.L24+24
 259 00f8 1888     	 ldrh r0,[r3]
 260 00fa 554B     	 ldr r3,.L24+28
 261 00fc 1978     	 ldrb r1,[r3]
 262 00fe 504B     	 ldr r3,.L24+12
 263 0100 1D68     	 ldr r5,[r3]
 264 0102 544B     	 ldr r3,.L24+32
 265 0104 1C68     	 ldr r4,[r3]
 266 0106 4D4B     	 ldr r3,.L24+8
 267 0108 1A68     	 ldr r2,[r3]
 268 010a 534B     	 ldr r3,.L24+36
 269 010c 1B78     	 ldrb r3,[r3]
 270 010e 0092     	 str r2,[sp]
 271 0110 0193     	 str r3,[sp,#4]
 272 0112 2A46     	 mov r2,r5
 273 0114 2346     	 mov r3,r4
 274 0116 FFF7FEFF 	 bl OBJ_Write
 275 011a 0346     	 mov r3,r0
 276 011c FB75     	 strb r3,[r7,#23]
 295:../SSC/Src/sdoserv.c ****                     if ( abort == ABORTIDX_WORKING )
 277              	 .loc 1 295 0
 278 011e FB7D     	 ldrb r3,[r7,#23]
 279 0120 FF2B     	 cmp r3,#255
 280 0122 31D1     	 bne .L15
 296:../SSC/Src/sdoserv.c ****                     {
 297:../SSC/Src/sdoserv.c ****                         /* the application generates the SDO-Response later on by calling SDOS_SdoR
 298:../SSC/Src/sdoserv.c ****                         u8PendingSdo = SDO_PENDING_SEG_WRITE;
 281              	 .loc 1 298 0
 282 0124 4D4B     	 ldr r3,.L24+40
 283 0126 0222     	 movs r2,#2
 284 0128 1A70     	 strb r2,[r3]
 299:../SSC/Src/sdoserv.c ****                         bStoreCompleteAccess = bSdoSegAccess;
 285              	 .loc 1 299 0
 286 012a 4B4B     	 ldr r3,.L24+36
 287 012c 1B78     	 ldrb r3,[r3]
 288 012e 002B     	 cmp r3,#0
 289 0130 14BF     	 ite ne
 290 0132 0123     	 movne r3,#1
 291 0134 0023     	 moveq r3,#0
 292 0136 DAB2     	 uxtb r2,r3
 293 0138 494B     	 ldr r3,.L24+44
 294 013a 1A70     	 strb r2,[r3]
 300:../SSC/Src/sdoserv.c ****                         u8StoreSubindex = nSdoSegSubindex;
 295              	 .loc 1 300 0
 296 013c 444B     	 ldr r3,.L24+28
 297 013e 1A78     	 ldrb r2,[r3]
 298 0140 484B     	 ldr r3,.L24+48
 299 0142 1A70     	 strb r2,[r3]
 301:../SSC/Src/sdoserv.c ****                         u16StoreIndex = nSdoSegIndex;
 300              	 .loc 1 301 0
 301 0144 414B     	 ldr r3,.L24+24
 302 0146 1A88     	 ldrh r2,[r3]
 303 0148 474B     	 ldr r3,.L24+52
 304 014a 1A80     	 strh r2,[r3]
 302:../SSC/Src/sdoserv.c ****                         u32StoreDataSize = nSdoSegCompleteSize;
 305              	 .loc 1 302 0
 306 014c 3C4B     	 ldr r3,.L24+12
 307 014e 1B68     	 ldr r3,[r3]
 308 0150 464A     	 ldr r2,.L24+56
 309 0152 1360     	 str r3,[r2]
 303:../SSC/Src/sdoserv.c ****                         pStoreData = pSdoSegData;
 310              	 .loc 1 303 0
 311 0154 394B     	 ldr r3,.L24+8
 312 0156 1B68     	 ldr r3,[r3]
 313 0158 454A     	 ldr r2,.L24+60
 314 015a 1360     	 str r3,[r2]
 304:../SSC/Src/sdoserv.c **** 
 305:../SSC/Src/sdoserv.c ****                         pSdoPendFunc = pSdoSegObjEntry->Write;
 315              	 .loc 1 305 0
 316 015c 3D4B     	 ldr r3,.L24+32
 317 015e 1B68     	 ldr r3,[r3]
 318 0160 1B6A     	 ldr r3,[r3,#32]
 319 0162 444A     	 ldr r2,.L24+64
 320 0164 1360     	 str r3,[r2]
 306:../SSC/Src/sdoserv.c **** 
 307:../SSC/Src/sdoserv.c ****                         bSdoInWork = TRUE;
 321              	 .loc 1 307 0
 322 0166 444B     	 ldr r3,.L24+68
 323 0168 0122     	 movs r2,#1
 324 016a 1A70     	 strb r2,[r3]
 308:../SSC/Src/sdoserv.c ****                         pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
 325              	 .loc 1 308 0
 326 016c 434A     	 ldr r2,.L24+72
 327 016e 7B68     	 ldr r3,[r7,#4]
 328 0170 1360     	 str r3,[r2]
 309:../SSC/Src/sdoserv.c **** 
 310:../SSC/Src/sdoserv.c ****                         bSdoSegFollows = FALSE;
 329              	 .loc 1 310 0
 330 0172 354B     	 ldr r3,.L24+20
 331 0174 0022     	 movs r2,#0
 332 0176 1A70     	 strb r2,[r3]
 311:../SSC/Src/sdoserv.c ****                         nSdoSegService    = 0;
 333              	 .loc 1 311 0
 334 0178 414B     	 ldr r3,.L24+76
 335 017a 0022     	 movs r2,#0
 336 017c 1A70     	 strb r2,[r3]
 312:../SSC/Src/sdoserv.c ****                         nSdoSegBytesToHandle = 0;
 337              	 .loc 1 312 0
 338 017e 314B     	 ldr r3,.L24+16
 339 0180 0022     	 movs r2,#0
 340 0182 1A60     	 str r2,[r3]
 313:../SSC/Src/sdoserv.c **** 
 314:../SSC/Src/sdoserv.c ****                         return ABORTIDX_WORKING;
 341              	 .loc 1 314 0
 342 0184 FF23     	 movs r3,#255
 343 0186 51E0     	 b .L16
 344              	.L15:
 315:../SSC/Src/sdoserv.c ****                     }
 316:../SSC/Src/sdoserv.c ****                     else
 317:../SSC/Src/sdoserv.c ****                     {
 318:../SSC/Src/sdoserv.c ****                         /* the allocated buffer can be released */
 319:../SSC/Src/sdoserv.c ****                         FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 345              	 .loc 1 319 0
 346 0188 2C4B     	 ldr r3,.L24+8
 347 018a 1B68     	 ldr r3,[r3]
 348 018c 1846     	 mov r0,r3
 349 018e FFF7FEFF 	 bl free
 320:../SSC/Src/sdoserv.c ****                         pSdoSegData = NULL;
 350              	 .loc 1 320 0
 351 0192 2A4B     	 ldr r3,.L24+8
 352 0194 0022     	 movs r2,#0
 353 0196 1A60     	 str r2,[r3]
 354 0198 01E0     	 b .L3
 355              	.L4:
 321:../SSC/Src/sdoserv.c ****                     }
 322:../SSC/Src/sdoserv.c ****                 }
 323:../SSC/Src/sdoserv.c ****             }
 324:../SSC/Src/sdoserv.c ****         }
 325:../SSC/Src/sdoserv.c ****         else
 326:../SSC/Src/sdoserv.c ****         {
 327:../SSC/Src/sdoserv.c ****             abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 356              	 .loc 1 327 0
 357 019a 0323     	 movs r3,#3
 358 019c FB75     	 strb r3,[r7,#23]
 359              	.L3:
 360              	.LBE2:
 328:../SSC/Src/sdoserv.c ****         }
 329:../SSC/Src/sdoserv.c ****     }
 330:../SSC/Src/sdoserv.c **** 
 331:../SSC/Src/sdoserv.c ****     if ( abort == 0)
 361              	 .loc 1 331 0
 362 019e FB7D     	 ldrb r3,[r7,#23]
 363 01a0 002B     	 cmp r3,#0
 364 01a2 2DD1     	 bne .L17
 332:../SSC/Src/sdoserv.c ****     {
 333:../SSC/Src/sdoserv.c ****         /* send the SDO Download Segment response */
 334:../SSC/Src/sdoserv.c ****         pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
 365              	 .loc 1 334 0
 366 01a4 7B68     	 ldr r3,[r7,#4]
 367 01a6 0A22     	 movs r2,#10
 368 01a8 1A80     	 strh r2,[r3]
 335:../SSC/Src/sdoserv.c ****         pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 369              	 .loc 1 335 0
 370 01aa 7B68     	 ldr r3,[r7,#4]
 371 01ac DB88     	 ldrh r3,[r3,#6]
 372 01ae C3F30B03 	 ubfx r3,r3,#0,#12
 373 01b2 9AB2     	 uxth r2,r3
 374 01b4 7B68     	 ldr r3,[r7,#4]
 375 01b6 DA80     	 strh r2,[r3,#6]
 336:../SSC/Src/sdoserv.c ****         pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
 376              	 .loc 1 336 0
 377 01b8 7B68     	 ldr r3,[r7,#4]
 378 01ba DB88     	 ldrh r3,[r3,#6]
 379 01bc 43F44053 	 orr r3,r3,#12288
 380 01c0 9AB2     	 uxth r2,r3
 381 01c2 7B68     	 ldr r3,[r7,#4]
 382 01c4 DA80     	 strh r2,[r3,#6]
 337:../SSC/Src/sdoserv.c ****         /* the SDO Download Segment header depends if it was the last segment or not */
 338:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12) ECAT2*/
 339:../SSC/Src/sdoserv.c ****         if ( bSdoSegLastToggle )
 383              	 .loc 1 339 0
 384 01c6 1B4B     	 ldr r3,.L24
 385 01c8 1B78     	 ldrb r3,[r3]
 386 01ca 002B     	 cmp r3,#0
 387 01cc 03D0     	 beq .L18
 340:../SSC/Src/sdoserv.c ****         {
 341:../SSC/Src/sdoserv.c ****            pSdoInd->SdoHeader.SegHeader        = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES|SEGHEADER_T
 388              	 .loc 1 341 0
 389 01ce 7B68     	 ldr r3,[r7,#4]
 390 01d0 3022     	 movs r2,#48
 391 01d2 1A72     	 strb r2,[r3,#8]
 392 01d4 02E0     	 b .L19
 393              	.L18:
 342:../SSC/Src/sdoserv.c ****         }
 343:../SSC/Src/sdoserv.c ****         else
 344:../SSC/Src/sdoserv.c ****         {
 345:../SSC/Src/sdoserv.c ****            pSdoInd->SdoHeader.SegHeader        = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
 394              	 .loc 1 345 0
 395 01d6 7B68     	 ldr r3,[r7,#4]
 396 01d8 2022     	 movs r2,#32
 397 01da 1A72     	 strb r2,[r3,#8]
 398              	.L19:
 346:../SSC/Src/sdoserv.c ****         }
 347:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12) ECAT2*/
 348:../SSC/Src/sdoserv.c ****         
 349:../SSC/Src/sdoserv.c ****         if ( bSdoSegFollows == TRUE )
 399              	 .loc 1 349 0
 400 01dc 1A4B     	 ldr r3,.L24+20
 401 01de 1B78     	 ldrb r3,[r3]
 402 01e0 012B     	 cmp r3,#1
 403 01e2 06D1     	 bne .L20
 350:../SSC/Src/sdoserv.c ****         {
 351:../SSC/Src/sdoserv.c ****             /* segments are still expected, nSdoSegBytesToHandle contains the number of received da
 352:../SSC/Src/sdoserv.c ****             nSdoSegBytesToHandle += bytesToSave;
 404              	 .loc 1 352 0
 405 01e4 174B     	 ldr r3,.L24+16
 406 01e6 1A68     	 ldr r2,[r3]
 407 01e8 3B69     	 ldr r3,[r7,#16]
 408 01ea 1344     	 add r3,r3,r2
 409 01ec 154A     	 ldr r2,.L24+16
 410 01ee 1360     	 str r3,[r2]
 411 01f0 1BE0     	 b .L22
 412              	.L20:
 353:../SSC/Src/sdoserv.c ****         }
 354:../SSC/Src/sdoserv.c ****         else
 355:../SSC/Src/sdoserv.c ****         {
 356:../SSC/Src/sdoserv.c ****             /* the last segment was received, the variables are reset */
 357:../SSC/Src/sdoserv.c ****             nSdoSegBytesToHandle = 0;
 413              	 .loc 1 357 0
 414 01f2 144B     	 ldr r3,.L24+16
 415 01f4 0022     	 movs r2,#0
 416 01f6 1A60     	 str r2,[r3]
 358:../SSC/Src/sdoserv.c ****             nSdoSegService    = 0;
 417              	 .loc 1 358 0
 418 01f8 214B     	 ldr r3,.L24+76
 419 01fa 0022     	 movs r2,#0
 420 01fc 1A70     	 strb r2,[r3]
 421 01fe 14E0     	 b .L22
 422              	.L17:
 359:../SSC/Src/sdoserv.c ****         }
 360:../SSC/Src/sdoserv.c ****     }
 361:../SSC/Src/sdoserv.c ****     else 
 362:../SSC/Src/sdoserv.c ****     {
 363:../SSC/Src/sdoserv.c ****         /* the Abort-Response will be sent in SDOS_SdoInd*/
 364:../SSC/Src/sdoserv.c ****         bSdoSegFollows = FALSE;
 423              	 .loc 1 364 0
 424 0200 114B     	 ldr r3,.L24+20
 425 0202 0022     	 movs r2,#0
 426 0204 1A70     	 strb r2,[r3]
 365:../SSC/Src/sdoserv.c ****         nSdoSegService    = 0;
 427              	 .loc 1 365 0
 428 0206 1E4B     	 ldr r3,.L24+76
 429 0208 0022     	 movs r2,#0
 430 020a 1A70     	 strb r2,[r3]
 366:../SSC/Src/sdoserv.c ****         if (pSdoSegData)
 431              	 .loc 1 366 0
 432 020c 0B4B     	 ldr r3,.L24+8
 433 020e 1B68     	 ldr r3,[r3]
 434 0210 002B     	 cmp r3,#0
 435 0212 07D0     	 beq .L23
 367:../SSC/Src/sdoserv.c ****         {
 368:../SSC/Src/sdoserv.c ****             /* the memory has to be released if it is not released before.
 369:../SSC/Src/sdoserv.c ****             In case of AbortIdx_Working the buffer will be freed in SDOS_SdoRes*/
 370:../SSC/Src/sdoserv.c ****             FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 436              	 .loc 1 370 0
 437 0214 094B     	 ldr r3,.L24+8
 438 0216 1B68     	 ldr r3,[r3]
 439 0218 1846     	 mov r0,r3
 440 021a FFF7FEFF 	 bl free
 371:../SSC/Src/sdoserv.c ****             pSdoSegData = NULL;
 441              	 .loc 1 371 0
 442 021e 074B     	 ldr r3,.L24+8
 443 0220 0022     	 movs r2,#0
 444 0222 1A60     	 str r2,[r3]
 445              	.L23:
 372:../SSC/Src/sdoserv.c ****         }
 373:../SSC/Src/sdoserv.c **** 
 374:../SSC/Src/sdoserv.c ****         nSdoSegBytesToHandle = 0;
 446              	 .loc 1 374 0
 447 0224 074B     	 ldr r3,.L24+16
 448 0226 0022     	 movs r2,#0
 449 0228 1A60     	 str r2,[r3]
 450              	.L22:
 375:../SSC/Src/sdoserv.c ****     }
 376:../SSC/Src/sdoserv.c **** 
 377:../SSC/Src/sdoserv.c ****     return abort;
 451              	 .loc 1 377 0
 452 022a FB7D     	 ldrb r3,[r7,#23]
 453              	.L16:
 378:../SSC/Src/sdoserv.c **** }
 454              	 .loc 1 378 0
 455 022c 1846     	 mov r0,r3
 456 022e 1837     	 adds r7,r7,#24
 457              	.LCFI3:
 458              	 .cfi_def_cfa_offset 16
 459 0230 BD46     	 mov sp,r7
 460              	.LCFI4:
 461              	 .cfi_def_cfa_register 13
 462              	 
 463 0232 B0BD     	 pop {r4,r5,r7,pc}
 464              	.L25:
 465              	 .align 2
 466              	.L24:
 467 0234 00000000 	 .word bSdoSegLastToggle
 468 0238 00000000 	 .word u16ReceiveMbxSize
 469 023c 00000000 	 .word pSdoSegData
 470 0240 00000000 	 .word nSdoSegCompleteSize
 471 0244 00000000 	 .word nSdoSegBytesToHandle
 472 0248 00000000 	 .word bSdoSegFollows
 473 024c 00000000 	 .word nSdoSegIndex
 474 0250 00000000 	 .word nSdoSegSubindex
 475 0254 00000000 	 .word pSdoSegObjEntry
 476 0258 00000000 	 .word bSdoSegAccess
 477 025c 00000000 	 .word u8PendingSdo
 478 0260 00000000 	 .word bStoreCompleteAccess
 479 0264 00000000 	 .word u8StoreSubindex
 480 0268 00000000 	 .word u16StoreIndex
 481 026c 00000000 	 .word u32StoreDataSize
 482 0270 00000000 	 .word pStoreData
 483 0274 00000000 	 .word pSdoPendFunc
 484 0278 00000000 	 .word bSdoInWork
 485 027c 00000000 	 .word pSdoResStored
 486 0280 00000000 	 .word nSdoSegService
 487              	 .cfi_endproc
 488              	.LFE179:
 490              	 .section .text.SdoUploadSegmentInd,"ax",%progbits
 491              	 .align 2
 492              	 .thumb
 493              	 .thumb_func
 495              	SdoUploadSegmentInd:
 496              	.LFB180:
 379:../SSC/Src/sdoserv.c **** 
 380:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 381:../SSC/Src/sdoserv.c **** /**
 382:../SSC/Src/sdoserv.c ****  \param     pSdoInd            Pointer to the received mailbox data from the master.
 383:../SSC/Src/sdoserv.c **** 
 384:../SSC/Src/sdoserv.c ****  \return    Indicates if an error occurred while the operation ( good = 0 ).
 385:../SSC/Src/sdoserv.c **** 
 386:../SSC/Src/sdoserv.c ****  \brief    This function is called when a Upload SDO Segment request service
 387:../SSC/Src/sdoserv.c ****             is received from the master. It prepares and operates the
 388:../SSC/Src/sdoserv.c ****             response and sends it by itself.
 389:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 390:../SSC/Src/sdoserv.c **** 
 391:../SSC/Src/sdoserv.c **** static UINT8 SdoUploadSegmentInd( TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd )
 392:../SSC/Src/sdoserv.c **** {
 497              	 .loc 1 392 0
 498              	 .cfi_startproc
 499              	 
 500              	 
 501 0000 80B5     	 push {r7,lr}
 502              	.LCFI5:
 503              	 .cfi_def_cfa_offset 8
 504              	 .cfi_offset 7,-8
 505              	 .cfi_offset 14,-4
 506 0002 86B0     	 sub sp,sp,#24
 507              	.LCFI6:
 508              	 .cfi_def_cfa_offset 32
 509 0004 00AF     	 add r7,sp,#0
 510              	.LCFI7:
 511              	 .cfi_def_cfa_register 7
 512 0006 7860     	 str r0,[r7,#4]
 393:../SSC/Src/sdoserv.c ****     UINT8 abort = 0;
 513              	 .loc 1 393 0
 514 0008 0023     	 movs r3,#0
 515 000a FB75     	 strb r3,[r7,#23]
 394:../SSC/Src/sdoserv.c ****     TUPLOADSDOSEGRESMBX MBXMEM * pSdoSegRes = (TUPLOADSDOSEGRESMBX MBXMEM *)pSdoInd;
 516              	 .loc 1 394 0
 517 000c 7B68     	 ldr r3,[r7,#4]
 518 000e FB60     	 str r3,[r7,#12]
 395:../SSC/Src/sdoserv.c **** 
 396:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12) ECAT2*/
 397:../SSC/Src/sdoserv.c ****    if ( SWAPWORD(pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle )
 519              	 .loc 1 397 0
 520 0010 7B68     	 ldr r3,[r7,#4]
 521 0012 1B7A     	 ldrb r3,[r3,#8]
 522 0014 03F01003 	 and r3,r3,#16
 523 0018 4C4A     	 ldr r2,.L37
 524 001a 1278     	 ldrb r2,[r2]
 525 001c 9342     	 cmp r3,r2
 526 001e 02D1     	 bne .L27
 398:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12) ECAT2*/
 399:../SSC/Src/sdoserv.c ****     {
 400:../SSC/Src/sdoserv.c ****         /* toggle bit has not toggled... */
 401:../SSC/Src/sdoserv.c ****         abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
 527              	 .loc 1 401 0
 528 0020 0123     	 movs r3,#1
 529 0022 FB75     	 strb r3,[r7,#23]
 530 0024 8CE0     	 b .L28
 531              	.L27:
 532              	.LBB4:
 402:../SSC/Src/sdoserv.c ****     }
 403:../SSC/Src/sdoserv.c ****     else
 404:../SSC/Src/sdoserv.c ****     {
 405:../SSC/Src/sdoserv.c ****         /* maxData contains the maximum data to be sent with a SDO-Upload Segment response */
 406:../SSC/Src/sdoserv.c ****          
 407:../SSC/Src/sdoserv.c ****         UINT32 size = 0;
 533              	 .loc 1 407 0
 534 0026 0023     	 movs r3,#0
 535 0028 3B61     	 str r3,[r7,#16]
 408:../SSC/Src/sdoserv.c ****         UINT16 maxData;
 409:../SSC/Src/sdoserv.c ****         
 410:../SSC/Src/sdoserv.c ****         {
 411:../SSC/Src/sdoserv.c ****             maxData =    u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
 536              	 .loc 1 411 0
 537 002a 494B     	 ldr r3,.L37+4
 538 002c 1B88     	 ldrh r3,[r3]
 539 002e 093B     	 subs r3,r3,#9
 540 0030 7B81     	 strh r3,[r7,#10]
 412:../SSC/Src/sdoserv.c ****         }
 413:../SSC/Src/sdoserv.c **** 
 414:../SSC/Src/sdoserv.c ****         /* the new toggle bit is stored in bSdoSegLastToggle */
 415:../SSC/Src/sdoserv.c ****         bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
 541              	 .loc 1 415 0
 542 0032 7B68     	 ldr r3,[r7,#4]
 543 0034 1B7A     	 ldrb r3,[r3,#8]
 544 0036 03F01003 	 and r3,r3,#16
 545 003a DAB2     	 uxtb r2,r3
 546 003c 434B     	 ldr r3,.L37
 547 003e 1A70     	 strb r2,[r3]
 416:../SSC/Src/sdoserv.c **** 
 417:../SSC/Src/sdoserv.c ****         if ( nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData) )
 548              	 .loc 1 417 0
 549 0040 7A89     	 ldrh r2,[r7,#10]
 550 0042 444B     	 ldr r3,.L37+8
 551 0044 1B68     	 ldr r3,[r3]
 552 0046 1A44     	 add r2,r2,r3
 553 0048 434B     	 ldr r3,.L37+12
 554 004a 1B68     	 ldr r3,[r3]
 555 004c 9A42     	 cmp r2,r3
 556 004e 09D9     	 bls .L29
 418:../SSC/Src/sdoserv.c ****         {
 419:../SSC/Src/sdoserv.c ****             /* the remaining data can be send with one SDO Upload Segment response,
 420:../SSC/Src/sdoserv.c ****                size contains the data to be copied */
 421:../SSC/Src/sdoserv.c ****             size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
 557              	 .loc 1 421 0
 558 0050 414B     	 ldr r3,.L37+12
 559 0052 1A68     	 ldr r2,[r3]
 560 0054 3F4B     	 ldr r3,.L37+8
 561 0056 1B68     	 ldr r3,[r3]
 562 0058 D31A     	 subs r3,r2,r3
 563 005a 3B61     	 str r3,[r7,#16]
 422:../SSC/Src/sdoserv.c ****             bSdoSegFollows = FALSE;
 564              	 .loc 1 422 0
 565 005c 3F4B     	 ldr r3,.L37+16
 566 005e 0022     	 movs r2,#0
 567 0060 1A70     	 strb r2,[r3]
 568 0062 04E0     	 b .L30
 569              	.L29:
 423:../SSC/Src/sdoserv.c ****         }
 424:../SSC/Src/sdoserv.c ****         else
 425:../SSC/Src/sdoserv.c ****         {
 426:../SSC/Src/sdoserv.c ****             /* more data will follow, size contains the data to be copied */
 427:../SSC/Src/sdoserv.c ****             size = maxData;
 570              	 .loc 1 427 0
 571 0064 7B89     	 ldrh r3,[r7,#10]
 572 0066 3B61     	 str r3,[r7,#16]
 428:../SSC/Src/sdoserv.c ****             bSdoSegFollows = TRUE;
 573              	 .loc 1 428 0
 574 0068 3C4B     	 ldr r3,.L37+16
 575 006a 0122     	 movs r2,#1
 576 006c 1A70     	 strb r2,[r3]
 577              	.L30:
 429:../SSC/Src/sdoserv.c ****         }
 430:../SSC/Src/sdoserv.c **** 
 431:../SSC/Src/sdoserv.c ****         /* copy the object data in the SDO Upload segment response */
 432:../SSC/Src/sdoserv.c ****         MBXMEMCPY( pSdoSegRes->SdoHeader.Data, &(((UINT8*)pSdoSegData)[nSdoSegBytesToHandle]), size
 578              	 .loc 1 432 0
 579 006e FB68     	 ldr r3,[r7,#12]
 580 0070 03F10901 	 add r1,r3,#9
 581 0074 3A4B     	 ldr r3,.L37+20
 582 0076 1A68     	 ldr r2,[r3]
 583 0078 364B     	 ldr r3,.L37+8
 584 007a 1B68     	 ldr r3,[r3]
 585 007c 1344     	 add r3,r3,r2
 586 007e 0846     	 mov r0,r1
 587 0080 1946     	 mov r1,r3
 588 0082 3A69     	 ldr r2,[r7,#16]
 589 0084 FFF7FEFF 	 bl memcpy
 433:../SSC/Src/sdoserv.c ****         
 434:../SSC/Src/sdoserv.c ****         /* the SDO Upload Segment header depends if there is still data to be sent */
 435:../SSC/Src/sdoserv.c ****         pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 590              	 .loc 1 435 0
 591 0088 FB68     	 ldr r3,[r7,#12]
 592 008a DB88     	 ldrh r3,[r3,#6]
 593 008c C3F30B03 	 ubfx r3,r3,#0,#12
 594 0090 9AB2     	 uxth r2,r3
 595 0092 FB68     	 ldr r3,[r7,#12]
 596 0094 DA80     	 strh r2,[r3,#6]
 436:../SSC/Src/sdoserv.c ****         pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
 597              	 .loc 1 436 0
 598 0096 FB68     	 ldr r3,[r7,#12]
 599 0098 DB88     	 ldrh r3,[r3,#6]
 600 009a 43F44053 	 orr r3,r3,#12288
 601 009e 9AB2     	 uxth r2,r3
 602 00a0 FB68     	 ldr r3,[r7,#12]
 603 00a2 DA80     	 strh r2,[r3,#6]
 437:../SSC/Src/sdoserv.c **** 
 438:../SSC/Src/sdoserv.c ****         /*Clear SDO header*/
 439:../SSC/Src/sdoserv.c ****         pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
 604              	 .loc 1 439 0
 605 00a4 FB68     	 ldr r3,[r7,#12]
 606 00a6 0022     	 movs r2,#0
 607 00a8 1A72     	 strb r2,[r3,#8]
 440:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12) ECAT2*/
 441:../SSC/Src/sdoserv.c ****         if (bSdoSegFollows)
 608              	 .loc 1 441 0
 609 00aa 2C4B     	 ldr r3,.L37+16
 610 00ac 1B78     	 ldrb r3,[r3]
 611 00ae 002B     	 cmp r3,#0
 612 00b0 08D0     	 beq .L31
 442:../SSC/Src/sdoserv.c ****         {
 443:../SSC/Src/sdoserv.c ****             pSdoSegRes->SdoHeader.SegHeader        |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSe
 613              	 .loc 1 443 0
 614 00b2 FB68     	 ldr r3,[r7,#12]
 615 00b4 1A7A     	 ldrb r2,[r3,#8]
 616 00b6 254B     	 ldr r3,.L37
 617 00b8 1B78     	 ldrb r3,[r3]
 618 00ba 1343     	 orrs r3,r3,r2
 619 00bc DAB2     	 uxtb r2,r3
 620 00be FB68     	 ldr r3,[r7,#12]
 621 00c0 1A72     	 strb r2,[r3,#8]
 622 00c2 0AE0     	 b .L32
 623              	.L31:
 444:../SSC/Src/sdoserv.c ****         }
 445:../SSC/Src/sdoserv.c ****         else
 446:../SSC/Src/sdoserv.c ****         {
 447:../SSC/Src/sdoserv.c ****             pSdoSegRes->SdoHeader.SegHeader        |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSe
 624              	 .loc 1 447 0
 625 00c4 FB68     	 ldr r3,[r7,#12]
 626 00c6 1A7A     	 ldrb r2,[r3,#8]
 627 00c8 204B     	 ldr r3,.L37
 628 00ca 1B78     	 ldrb r3,[r3]
 629 00cc 1343     	 orrs r3,r3,r2
 630 00ce DBB2     	 uxtb r3,r3
 631 00d0 43F00103 	 orr r3,r3,#1
 632 00d4 DAB2     	 uxtb r2,r3
 633 00d6 FB68     	 ldr r3,[r7,#12]
 634 00d8 1A72     	 strb r2,[r3,#8]
 635              	.L32:
 448:../SSC/Src/sdoserv.c ****         }
 449:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12) ECAT2*/
 450:../SSC/Src/sdoserv.c **** 
 451:../SSC/Src/sdoserv.c ****         // operate CAN specific flag segDataSize:
 452:../SSC/Src/sdoserv.c ****         /* HBu 06.02.06: the sizes were wrong */
 453:../SSC/Src/sdoserv.c ****         if ( size < MIN_SEGMENTED_DATA )
 636              	 .loc 1 453 0
 637 00da 3B69     	 ldr r3,[r7,#16]
 638 00dc 062B     	 cmp r3,#6
 639 00de 10D8     	 bhi .L33
 454:../SSC/Src/sdoserv.c ****         {
 455:../SSC/Src/sdoserv.c ****             // at least    MIN_SEGMENTED_DATA bytes have to be send:
 456:../SSC/Src/sdoserv.c ****             pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
 640              	 .loc 1 456 0
 641 00e0 FB68     	 ldr r3,[r7,#12]
 642 00e2 0A22     	 movs r2,#10
 643 00e4 1A80     	 strh r2,[r3]
 457:../SSC/Src/sdoserv.c ****             pSdoSegRes->SdoHeader.SegHeader    |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEG
 644              	 .loc 1 457 0
 645 00e6 FB68     	 ldr r3,[r7,#12]
 646 00e8 1A7A     	 ldrb r2,[r3,#8]
 647 00ea 3B69     	 ldr r3,[r7,#16]
 648 00ec DBB2     	 uxtb r3,r3
 649 00ee C3F10703 	 rsb r3,r3,#7
 650 00f2 DBB2     	 uxtb r3,r3
 651 00f4 5B00     	 lsls r3,r3,#1
 652 00f6 DBB2     	 uxtb r3,r3
 653 00f8 1343     	 orrs r3,r3,r2
 654 00fa DAB2     	 uxtb r2,r3
 655 00fc FB68     	 ldr r3,[r7,#12]
 656 00fe 1A72     	 strb r2,[r3,#8]
 657 0100 05E0     	 b .L34
 658              	.L33:
 458:../SSC/Src/sdoserv.c ****         }
 459:../SSC/Src/sdoserv.c ****         else
 460:../SSC/Src/sdoserv.c ****         {
 461:../SSC/Src/sdoserv.c ****             pSdoSegRes->MbxHeader.Length         = ((UINT16) size) + SEGMENT_NORM_HEADER_SIZE;
 659              	 .loc 1 461 0
 660 0102 3B69     	 ldr r3,[r7,#16]
 661 0104 9BB2     	 uxth r3,r3
 662 0106 0333     	 adds r3,r3,#3
 663 0108 9AB2     	 uxth r2,r3
 664 010a FB68     	 ldr r3,[r7,#12]
 665 010c 1A80     	 strh r2,[r3]
 666              	.L34:
 462:../SSC/Src/sdoserv.c ****         }
 463:../SSC/Src/sdoserv.c **** 
 464:../SSC/Src/sdoserv.c ****         if ( bSdoSegFollows == TRUE )
 667              	 .loc 1 464 0
 668 010e 134B     	 ldr r3,.L37+16
 669 0110 1B78     	 ldrb r3,[r3]
 670 0112 012B     	 cmp r3,#1
 671 0114 06D1     	 bne .L35
 465:../SSC/Src/sdoserv.c ****         {
 466:../SSC/Src/sdoserv.c ****             // updating the value of send bytes:
 467:../SSC/Src/sdoserv.c ****             nSdoSegBytesToHandle += size;
 672              	 .loc 1 467 0
 673 0116 0F4B     	 ldr r3,.L37+8
 674 0118 1A68     	 ldr r2,[r3]
 675 011a 3B69     	 ldr r3,[r7,#16]
 676 011c 1344     	 add r3,r3,r2
 677 011e 0D4A     	 ldr r2,.L37+8
 678 0120 1360     	 str r3,[r2]
 679 0122 0DE0     	 b .L28
 680              	.L35:
 468:../SSC/Src/sdoserv.c ****         }
 469:../SSC/Src/sdoserv.c ****         else
 470:../SSC/Src/sdoserv.c ****         {
 471:../SSC/Src/sdoserv.c ****             FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 681              	 .loc 1 471 0
 682 0124 0E4B     	 ldr r3,.L37+20
 683 0126 1B68     	 ldr r3,[r3]
 684 0128 1846     	 mov r0,r3
 685 012a FFF7FEFF 	 bl free
 472:../SSC/Src/sdoserv.c ****             pSdoSegData = NULL;
 686              	 .loc 1 472 0
 687 012e 0C4B     	 ldr r3,.L37+20
 688 0130 0022     	 movs r2,#0
 689 0132 1A60     	 str r2,[r3]
 473:../SSC/Src/sdoserv.c ****             nSdoSegBytesToHandle = 0;
 690              	 .loc 1 473 0
 691 0134 074B     	 ldr r3,.L37+8
 692 0136 0022     	 movs r2,#0
 693 0138 1A60     	 str r2,[r3]
 474:../SSC/Src/sdoserv.c ****             nSdoSegService    = 0;
 694              	 .loc 1 474 0
 695 013a 0A4B     	 ldr r3,.L37+24
 696 013c 0022     	 movs r2,#0
 697 013e 1A70     	 strb r2,[r3]
 698              	.L28:
 699              	.LBE4:
 475:../SSC/Src/sdoserv.c ****         }
 476:../SSC/Src/sdoserv.c ****     }
 477:../SSC/Src/sdoserv.c **** 
 478:../SSC/Src/sdoserv.c ****     return abort;
 700              	 .loc 1 478 0
 701 0140 FB7D     	 ldrb r3,[r7,#23]
 479:../SSC/Src/sdoserv.c **** }
 702              	 .loc 1 479 0
 703 0142 1846     	 mov r0,r3
 704 0144 1837     	 adds r7,r7,#24
 705              	.LCFI8:
 706              	 .cfi_def_cfa_offset 8
 707 0146 BD46     	 mov sp,r7
 708              	.LCFI9:
 709              	 .cfi_def_cfa_register 13
 710              	 
 711 0148 80BD     	 pop {r7,pc}
 712              	.L38:
 713 014a 00BF     	 .align 2
 714              	.L37:
 715 014c 00000000 	 .word bSdoSegLastToggle
 716 0150 00000000 	 .word u16SendMbxSize
 717 0154 00000000 	 .word nSdoSegBytesToHandle
 718 0158 00000000 	 .word nSdoSegCompleteSize
 719 015c 00000000 	 .word bSdoSegFollows
 720 0160 00000000 	 .word pSdoSegData
 721 0164 00000000 	 .word nSdoSegService
 722              	 .cfi_endproc
 723              	.LFE180:
 725              	 .section .text.SdoRes,"ax",%progbits
 726              	 .align 2
 727              	 .global SdoRes
 728              	 .thumb
 729              	 .thumb_func
 731              	SdoRes:
 732              	.LFB181:
 480:../SSC/Src/sdoserv.c **** 
 481:../SSC/Src/sdoserv.c **** 
 482:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 483:../SSC/Src/sdoserv.c **** /**
 484:../SSC/Src/sdoserv.c ****  \param    abort                 Result of the SDO access
 485:../SSC/Src/sdoserv.c ****  \param    command		         SDO command index 
 486:../SSC/Src/sdoserv.c ****  \param    completeAccess        Indicates if complete access was requested
 487:../SSC/Src/sdoserv.c ****  \param    dataSize              Available data buffer in the response
 488:../SSC/Src/sdoserv.c ****  \param    objLength             Complete size of the object
 489:../SSC/Src/sdoserv.c ****  \param     pSdoRes                Pointer to the mailbox buffer
 490:../SSC/Src/sdoserv.c **** 
 491:../SSC/Src/sdoserv.c ****  \brief    This function is called when a SDO response shall be sent
 492:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 493:../SSC/Src/sdoserv.c **** 
 494:../SSC/Src/sdoserv.c **** void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TI
 495:../SSC/Src/sdoserv.c **** {
 733              	 .loc 1 495 0
 734              	 .cfi_startproc
 735              	 
 736              	 
 737 0000 90B5     	 push {r4,r7,lr}
 738              	.LCFI10:
 739              	 .cfi_def_cfa_offset 12
 740              	 .cfi_offset 4,-12
 741              	 .cfi_offset 7,-8
 742              	 .cfi_offset 14,-4
 743 0002 83B0     	 sub sp,sp,#12
 744              	.LCFI11:
 745              	 .cfi_def_cfa_offset 24
 746 0004 00AF     	 add r7,sp,#0
 747              	.LCFI12:
 748              	 .cfi_def_cfa_register 7
 749 0006 0446     	 mov r4,r0
 750 0008 0846     	 mov r0,r1
 751 000a 1146     	 mov r1,r2
 752 000c 1A46     	 mov r2,r3
 753 000e 2346     	 mov r3,r4
 754 0010 FB71     	 strb r3,[r7,#7]
 755 0012 0346     	 mov r3,r0
 756 0014 BB71     	 strb r3,[r7,#6]
 757 0016 0B46     	 mov r3,r1
 758 0018 7B71     	 strb r3,[r7,#5]
 759 001a 1346     	 mov r3,r2
 760 001c 7B80     	 strh r3,[r7,#2]
 496:../SSC/Src/sdoserv.c ****     /* for an upload segment response the toggle bit was overwritten */
 497:../SSC/Src/sdoserv.c ****     if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
 761              	 .loc 1 497 0
 762 001e BB79     	 ldrb r3,[r7,#6]
 763 0020 602B     	 cmp r3,#96
 764 0022 05D0     	 beq .L40
 765              	 .loc 1 497 0 is_stmt 0 discriminator 1
 766 0024 BB79     	 ldrb r3,[r7,#6]
 767 0026 002B     	 cmp r3,#0
 768 0028 02D0     	 beq .L40
 498:../SSC/Src/sdoserv.c ****     {
 499:../SSC/Src/sdoserv.c ****         pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] = 0;
 769              	 .loc 1 499 0 is_stmt 1
 770 002a FB69     	 ldr r3,[r7,#28]
 771 002c 0022     	 movs r2,#0
 772 002e 1A72     	 strb r2,[r3,#8]
 773              	.L40:
 500:../SSC/Src/sdoserv.c ****     }
 501:../SSC/Src/sdoserv.c ****     if ( abort == 0 )
 774              	 .loc 1 501 0
 775 0030 FB79     	 ldrb r3,[r7,#7]
 776 0032 002B     	 cmp r3,#0
 777 0034 6CD1     	 bne .L41
 502:../SSC/Src/sdoserv.c ****     {
 503:../SSC/Src/sdoserv.c ****         /* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
 504:../SSC/Src/sdoserv.c ****         pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 778              	 .loc 1 504 0
 779 0036 FB69     	 ldr r3,[r7,#28]
 780 0038 DB88     	 ldrh r3,[r3,#6]
 781 003a C3F30B03 	 ubfx r3,r3,#0,#12
 782 003e 9AB2     	 uxth r2,r3
 783 0040 FB69     	 ldr r3,[r7,#28]
 784 0042 DA80     	 strh r2,[r3,#6]
 505:../SSC/Src/sdoserv.c ****         pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
 785              	 .loc 1 505 0
 786 0044 FB69     	 ldr r3,[r7,#28]
 787 0046 DB88     	 ldrh r3,[r3,#6]
 788 0048 43F44053 	 orr r3,r3,#12288
 789 004c 9AB2     	 uxth r2,r3
 790 004e FB69     	 ldr r3,[r7,#28]
 791 0050 DA80     	 strh r2,[r3,#6]
 506:../SSC/Src/sdoserv.c ****         if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 792              	 .loc 1 506 0
 793 0052 BB79     	 ldrb r3,[r7,#6]
 794 0054 402B     	 cmp r3,#64
 795 0056 3FD1     	 bne .L42
 507:../SSC/Src/sdoserv.c ****         {
 508:../SSC/Src/sdoserv.c ****             // HBu 06.02.06: Complete Access Bit in the SDO-Upload-Response too */
 509:../SSC/Src/sdoserv.c ****             if ( (objLength <= 4) && (objLength > 0) )
 796              	 .loc 1 509 0
 797 0058 BB69     	 ldr r3,[r7,#24]
 798 005a 042B     	 cmp r3,#4
 799 005c 18D8     	 bhi .L43
 800              	 .loc 1 509 0 is_stmt 0 discriminator 1
 801 005e BB69     	 ldr r3,[r7,#24]
 802 0060 002B     	 cmp r3,#0
 803 0062 15D0     	 beq .L43
 510:../SSC/Src/sdoserv.c ****             {
 511:../SSC/Src/sdoserv.c ****                 /* Expedited Upload Response */
 512:../SSC/Src/sdoserv.c ****                 pSdoRes->MbxHeader.Length             =         EXPEDITED_FRAME_SIZE;
 804              	 .loc 1 512 0 is_stmt 1
 805 0064 FB69     	 ldr r3,[r7,#28]
 806 0066 0A22     	 movs r2,#10
 807 0068 1A80     	 strh r2,[r3]
 513:../SSC/Src/sdoserv.c ****                 pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOHEADER_SIZEINDICATOR |
 808              	 .loc 1 513 0
 809 006a FB69     	 ldr r3,[r7,#28]
 810 006c 1A7A     	 ldrb r2,[r3,#8]
 514:../SSC/Src/sdoserv.c ****                                                                             SDOHEADER_TRANSFERTYPE 
 515:../SSC/Src/sdoserv.c ****                                                                             completeAccess |
 516:../SSC/Src/sdoserv.c ****                                                                             ((MAX_EXPEDITED_DATA - 
 811              	 .loc 1 516 0
 812 006e BB69     	 ldr r3,[r7,#24]
 813 0070 DBB2     	 uxtb r3,r3
 814 0072 C3F10403 	 rsb r3,r3,#4
 815 0076 9B00     	 lsls r3,r3,#2
 513:../SSC/Src/sdoserv.c ****                 pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOHEADER_SIZEINDICATOR |
 816              	 .loc 1 513 0
 817 0078 D9B2     	 uxtb r1,r3
 818 007a 7B79     	 ldrb r3,[r7,#5]
 819 007c 0B43     	 orrs r3,r3,r1
 820 007e DBB2     	 uxtb r3,r3
 821 0080 1343     	 orrs r3,r3,r2
 822 0082 DBB2     	 uxtb r3,r3
 823 0084 43F04303 	 orr r3,r3,#67
 824 0088 DAB2     	 uxtb r2,r3
 825 008a FB69     	 ldr r3,[r7,#28]
 826 008c 1A72     	 strb r2,[r3,#8]
 827 008e 5DE0     	 b .L49
 828              	.L43:
 517:../SSC/Src/sdoserv.c ****                                                                             SDOSERVICE_INITIATEUPLO
 518:../SSC/Src/sdoserv.c ****             }
 519:../SSC/Src/sdoserv.c ****             else
 520:../SSC/Src/sdoserv.c ****             {
 521:../SSC/Src/sdoserv.c ****                 /* Normal or Segmented Upload Response */
 522:../SSC/Src/sdoserv.c ****                 if (dataSize <  objLength)
 829              	 .loc 1 522 0
 830 0090 7A88     	 ldrh r2,[r7,#2]
 831 0092 BB69     	 ldr r3,[r7,#24]
 832 0094 9A42     	 cmp r2,r3
 833 0096 05D2     	 bcs .L45
 523:../SSC/Src/sdoserv.c ****                 {
 524:../SSC/Src/sdoserv.c ****                     pSdoRes->MbxHeader.Length         =         UPLOAD_NORM_RES_SIZE+dataSize;
 834              	 .loc 1 524 0
 835 0098 7B88     	 ldrh r3,[r7,#2]
 836 009a 0A33     	 adds r3,r3,#10
 837 009c 9AB2     	 uxth r2,r3
 838 009e FB69     	 ldr r3,[r7,#28]
 839 00a0 1A80     	 strh r2,[r3]
 840 00a2 05E0     	 b .L46
 841              	.L45:
 525:../SSC/Src/sdoserv.c ****                 }
 526:../SSC/Src/sdoserv.c ****                 else
 527:../SSC/Src/sdoserv.c ****                 {
 528:../SSC/Src/sdoserv.c ****                     pSdoRes->MbxHeader.Length         =         UPLOAD_NORM_RES_SIZE+((UINT16)objLe
 842              	 .loc 1 528 0
 843 00a4 BB69     	 ldr r3,[r7,#24]
 844 00a6 9BB2     	 uxth r3,r3
 845 00a8 0A33     	 adds r3,r3,#10
 846 00aa 9AB2     	 uxth r2,r3
 847 00ac FB69     	 ldr r3,[r7,#28]
 848 00ae 1A80     	 strh r2,[r3]
 849              	.L46:
 529:../SSC/Src/sdoserv.c ****                 }
 530:../SSC/Src/sdoserv.c ****                    ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT1
 850              	 .loc 1 530 0
 851 00b0 BB69     	 ldr r3,[r7,#24]
 852 00b2 9AB2     	 uxth r2,r3
 853 00b4 FB69     	 ldr r3,[r7,#28]
 854 00b6 9A81     	 strh r2,[r3,#12]
 531:../SSC/Src/sdoserv.c ****                    ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT1
 855              	 .loc 1 531 0
 856 00b8 BB69     	 ldr r3,[r7,#24]
 857 00ba 1B0C     	 lsrs r3,r3,#16
 858 00bc 9AB2     	 uxth r2,r3
 859 00be FB69     	 ldr r3,[r7,#28]
 860 00c0 DA81     	 strh r2,[r3,#14]
 532:../SSC/Src/sdoserv.c ****                    pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOHEADER_SIZEINDICATOR |
 861              	 .loc 1 532 0
 862 00c2 FB69     	 ldr r3,[r7,#28]
 863 00c4 1A7A     	 ldrb r2,[r3,#8]
 864 00c6 7B79     	 ldrb r3,[r7,#5]
 865 00c8 1343     	 orrs r3,r3,r2
 866 00ca DBB2     	 uxtb r3,r3
 867 00cc 43F04103 	 orr r3,r3,#65
 868 00d0 DAB2     	 uxtb r2,r3
 869 00d2 FB69     	 ldr r3,[r7,#28]
 870 00d4 1A72     	 strb r2,[r3,#8]
 871 00d6 39E0     	 b .L49
 872              	.L42:
 533:../SSC/Src/sdoserv.c ****                                                                            completeAccess |
 534:../SSC/Src/sdoserv.c ****                                                                            SDOSERVICE_INITIATEUPLOA
 535:../SSC/Src/sdoserv.c **** 
 536:../SSC/Src/sdoserv.c ****             }
 537:../SSC/Src/sdoserv.c ****         }
 538:../SSC/Src/sdoserv.c ****         /* for a segmented response the command was wrong in the response */
 539:../SSC/Src/sdoserv.c ****         else if ( command == SDOSERVICE_DOWNLOADSEGMENTREQ )
 873              	 .loc 1 539 0
 874 00d8 BB79     	 ldrb r3,[r7,#6]
 875 00da 002B     	 cmp r3,#0
 876 00dc 0AD1     	 bne .L48
 540:../SSC/Src/sdoserv.c ****         {
 541:../SSC/Src/sdoserv.c ****             /* Download segmented response */
 542:../SSC/Src/sdoserv.c ****             pSdoRes->MbxHeader.Length         = DOWNLOAD_NORM_RES_SIZE;
 877              	 .loc 1 542 0
 878 00de FB69     	 ldr r3,[r7,#28]
 879 00e0 0A22     	 movs r2,#10
 880 00e2 1A80     	 strh r2,[r3]
 543:../SSC/Src/sdoserv.c ****             pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOSERVICE_DOWNLOADSEGMENTRES;
 881              	 .loc 1 543 0
 882 00e4 FB69     	 ldr r3,[r7,#28]
 883 00e6 1B7A     	 ldrb r3,[r3,#8]
 884 00e8 43F02003 	 orr r3,r3,#32
 885 00ec DAB2     	 uxtb r2,r3
 886 00ee FB69     	 ldr r3,[r7,#28]
 887 00f0 1A72     	 strb r2,[r3,#8]
 888 00f2 2BE0     	 b .L49
 889              	.L48:
 544:../SSC/Src/sdoserv.c ****       }
 545:../SSC/Src/sdoserv.c ****         else if ( command != SDOSERVICE_UPLOADSEGMENTREQ )
 890              	 .loc 1 545 0
 891 00f4 BB79     	 ldrb r3,[r7,#6]
 892 00f6 602B     	 cmp r3,#96
 893 00f8 28D0     	 beq .L49
 546:../SSC/Src/sdoserv.c ****         {
 547:../SSC/Src/sdoserv.c ****             /* Download response */
 548:../SSC/Src/sdoserv.c ****             pSdoRes->MbxHeader.Length         = DOWNLOAD_NORM_RES_SIZE;
 894              	 .loc 1 548 0
 895 00fa FB69     	 ldr r3,[r7,#28]
 896 00fc 0A22     	 movs r2,#10
 897 00fe 1A80     	 strh r2,[r3]
 549:../SSC/Src/sdoserv.c ****             pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOSERVICE_INITIATEDOWNLOADRES;
 898              	 .loc 1 549 0
 899 0100 FB69     	 ldr r3,[r7,#28]
 900 0102 1B7A     	 ldrb r3,[r3,#8]
 901 0104 43F06003 	 orr r3,r3,#96
 902 0108 DAB2     	 uxtb r2,r3
 903 010a FB69     	 ldr r3,[r7,#28]
 904 010c 1A72     	 strb r2,[r3,#8]
 905 010e 1DE0     	 b .L49
 906              	.L41:
 550:../SSC/Src/sdoserv.c ****         }
 551:../SSC/Src/sdoserv.c ****     }
 552:../SSC/Src/sdoserv.c ****     else
 553:../SSC/Src/sdoserv.c ****     {
 554:../SSC/Src/sdoserv.c ****         /* generate a SDO-Abort-Request */
 555:../SSC/Src/sdoserv.c ****         pSdoRes->MbxHeader.Length         = ABORT_NORM_RES_SIZE;
 907              	 .loc 1 555 0
 908 0110 FB69     	 ldr r3,[r7,#28]
 909 0112 0A22     	 movs r2,#10
 910 0114 1A80     	 strh r2,[r3]
 556:../SSC/Src/sdoserv.c ****         pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 911              	 .loc 1 556 0
 912 0116 FB69     	 ldr r3,[r7,#28]
 913 0118 DB88     	 ldrh r3,[r3,#6]
 914 011a C3F30B03 	 ubfx r3,r3,#0,#12
 915 011e 9AB2     	 uxth r2,r3
 916 0120 FB69     	 ldr r3,[r7,#28]
 917 0122 DA80     	 strh r2,[r3,#6]
 557:../SSC/Src/sdoserv.c ****         pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
 918              	 .loc 1 557 0
 919 0124 FB69     	 ldr r3,[r7,#28]
 920 0126 DB88     	 ldrh r3,[r3,#6]
 921 0128 43F40053 	 orr r3,r3,#8192
 922 012c 9AB2     	 uxth r2,r3
 923 012e FB69     	 ldr r3,[r7,#28]
 924 0130 DA80     	 strh r2,[r3,#6]
 558:../SSC/Src/sdoserv.c ****         /* ECATCHANGE_START(V5.12) COE2*/
 559:../SSC/Src/sdoserv.c ****         pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOSERVICE_ABORTTRANSFER;
 925              	 .loc 1 559 0
 926 0132 FB69     	 ldr r3,[r7,#28]
 927 0134 1B7A     	 ldrb r3,[r3,#8]
 928 0136 63F07F03 	 orn r3,r3,#127
 929 013a DAB2     	 uxtb r2,r3
 930 013c FB69     	 ldr r3,[r7,#28]
 931 013e 1A72     	 strb r2,[r3,#8]
 560:../SSC/Src/sdoserv.c ****         /* ECATCHANGE_END(V5.12) COE2*/
 561:../SSC/Src/sdoserv.c **** 
 562:../SSC/Src/sdoserv.c ****         ((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
 932              	 .loc 1 562 0
 933 0140 FB79     	 ldrb r3,[r7,#7]
 934 0142 094A     	 ldr r2,.L51
 935 0144 52F82320 	 ldr r2,[r2,r3,lsl#2]
 936 0148 FB69     	 ldr r3,[r7,#28]
 937 014a DA60     	 str r2,[r3,#12]
 938              	.L49:
 563:../SSC/Src/sdoserv.c ****     }
 564:../SSC/Src/sdoserv.c **** 
 565:../SSC/Src/sdoserv.c ****     // HBu 02.05.06: if the CoE-response could not be sent because the
 566:../SSC/Src/sdoserv.c ****     //               send mailbox is full it should be stored
 567:../SSC/Src/sdoserv.c ****     if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
 939              	 .loc 1 567 0
 940 014c F869     	 ldr r0,[r7,#28]
 941 014e 0221     	 movs r1,#2
 942 0150 FFF7FEFF 	 bl MBX_MailboxSendReq
 943 0154 0346     	 mov r3,r0
 944 0156 002B     	 cmp r3,#0
 945 0158 02D0     	 beq .L39
 568:../SSC/Src/sdoserv.c ****     {
 569:../SSC/Src/sdoserv.c ****         /* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox 
 570:../SSC/Src/sdoserv.c ****         pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
 946              	 .loc 1 570 0
 947 015a 044A     	 ldr r2,.L51+4
 948 015c FB69     	 ldr r3,[r7,#28]
 949 015e 1360     	 str r3,[r2]
 950              	.L39:
 571:../SSC/Src/sdoserv.c ****     }
 572:../SSC/Src/sdoserv.c **** }
 951              	 .loc 1 572 0
 952 0160 0C37     	 adds r7,r7,#12
 953              	.LCFI13:
 954              	 .cfi_def_cfa_offset 12
 955 0162 BD46     	 mov sp,r7
 956              	.LCFI14:
 957              	 .cfi_def_cfa_register 13
 958              	 
 959 0164 90BD     	 pop {r4,r7,pc}
 960              	.L52:
 961 0166 00BF     	 .align 2
 962              	.L51:
 963 0168 00000000 	 .word cAbortCode
 964 016c 00000000 	 .word pCoeSendStored
 965              	 .cfi_endproc
 966              	.LFE181:
 968              	 .section .text.SDOS_SdoInd,"ax",%progbits
 969              	 .align 2
 970              	 .global SDOS_SdoInd
 971              	 .thumb
 972              	 .thumb_func
 974              	SDOS_SdoInd:
 975              	.LFB182:
 573:../SSC/Src/sdoserv.c **** 
 574:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 575:../SSC/Src/sdoserv.c **** /**
 576:../SSC/Src/sdoserv.c ****  \param     pSdoInd    Pointer to the received mailbox data from the master.
 577:../SSC/Src/sdoserv.c **** 
 578:../SSC/Src/sdoserv.c ****  \return    Indicates if an error occurred while the operation ( good = 0 ).
 579:../SSC/Src/sdoserv.c **** 
 580:../SSC/Src/sdoserv.c ****  \brief    This function is called when a SDO request service
 581:../SSC/Src/sdoserv.c ****             is received from the master and calls depending from
 582:../SSC/Src/sdoserv.c ****             the command the concerning function.
 583:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 584:../SSC/Src/sdoserv.c **** 
 585:../SSC/Src/sdoserv.c **** UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
 586:../SSC/Src/sdoserv.c **** {
 976              	 .loc 1 586 0
 977              	 .cfi_startproc
 978              	 
 979              	 
 980 0000 90B5     	 push {r4,r7,lr}
 981              	.LCFI15:
 982              	 .cfi_def_cfa_offset 12
 983              	 .cfi_offset 4,-12
 984              	 .cfi_offset 7,-8
 985              	 .cfi_offset 14,-4
 986 0002 91B0     	 sub sp,sp,#68
 987              	.LCFI16:
 988              	 .cfi_def_cfa_offset 80
 989 0004 02AF     	 add r7,sp,#8
 990              	.LCFI17:
 991              	 .cfi_def_cfa 7,72
 992 0006 7860     	 str r0,[r7,#4]
 587:../SSC/Src/sdoserv.c ****     UINT8 abort = 0;
 993              	 .loc 1 587 0
 994 0008 0023     	 movs r3,#0
 995 000a 87F83730 	 strb r3,[r7,#55]
 588:../SSC/Src/sdoserv.c ****     UINT8 sdoHeader = (pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK);
 996              	 .loc 1 588 0
 997 000e 7B68     	 ldr r3,[r7,#4]
 998 0010 1B7A     	 ldrb r3,[r3,#8]
 999 0012 87F82230 	 strb r3,[r7,#34]
 589:../SSC/Src/sdoserv.c ****     /* the SDO-command is in bit 5-7 of the first SDO-Byte */
 590:../SSC/Src/sdoserv.c ****     UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
 1000              	 .loc 1 590 0
 1001 0016 97F82230 	 ldrb r3,[r7,#34]
 1002 001a 23F01F03 	 bic r3,r3,#31
 1003 001e 87F82130 	 strb r3,[r7,#33]
 591:../SSC/Src/sdoserv.c ****     /* mbxSize contains the size of the mailbox (CoE-Header (2 Bytes) + SDO-Header (8 Bytes) + SDO-
 592:../SSC/Src/sdoserv.c ****     UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
 1004              	 .loc 1 592 0
 1005 0022 7B68     	 ldr r3,[r7,#4]
 1006 0024 1B88     	 ldrh r3,[r3]
 1007 0026 FB83     	 strh r3,[r7,#30]
 593:../SSC/Src/sdoserv.c ****     UINT16 index;
 594:../SSC/Src/sdoserv.c ****     UINT8 subindex;
 595:../SSC/Src/sdoserv.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry;
 596:../SSC/Src/sdoserv.c ****     /* this variable contains the information, if all entries of an object will be read (bCompleteA
 597:../SSC/Src/sdoserv.c ****     UINT8 bCompleteAccess = 0;
 1008              	 .loc 1 597 0
 1009 0028 0023     	 movs r3,#0
 1010 002a 87F83630 	 strb r3,[r7,#54]
 598:../SSC/Src/sdoserv.c ****     UINT32 objLength = 0;
 1011              	 .loc 1 598 0
 1012 002e 0023     	 movs r3,#0
 1013 0030 3B63     	 str r3,[r7,#48]
 599:../SSC/Src/sdoserv.c ****     UINT32 dataSize = 0;
 1014              	 .loc 1 599 0
 1015 0032 0023     	 movs r3,#0
 1016 0034 FB62     	 str r3,[r7,#44]
 600:../SSC/Src/sdoserv.c **** 
 601:../SSC/Src/sdoserv.c ****     if ( bSdoInWork )
 1017              	 .loc 1 601 0
 1018 0036 AC4B     	 ldr r3,.L96
 1019 0038 1B78     	 ldrb r3,[r3]
 1020 003a 002B     	 cmp r3,#0
 1021 003c 01D0     	 beq .L54
 602:../SSC/Src/sdoserv.c ****     {
 603:../SSC/Src/sdoserv.c ****         /* the last SDO is still in work */
 604:../SSC/Src/sdoserv.c ****         return MBXERR_SERVICEINWORK;
 1022              	 .loc 1 604 0
 1023 003e 0923     	 movs r3,#9
 1024 0040 A3E2     	 b .L55
 1025              	.L54:
 605:../SSC/Src/sdoserv.c ****     }
 606:../SSC/Src/sdoserv.c **** 
 607:../SSC/Src/sdoserv.c **** 
 608:../SSC/Src/sdoserv.c ****     switch (command)
 1026              	 .loc 1 608 0
 1027 0042 97F82130 	 ldrb r3,[r7,#33]
 1028 0046 202B     	 cmp r3,#32
 1029 0048 0BD0     	 beq .L57
 1030 004a 202B     	 cmp r3,#32
 1031 004c 03DC     	 bgt .L58
 1032 004e 002B     	 cmp r3,#0
 1033 0050 00F06482 	 beq .L59
 1034 0054 7EE2     	 b .L56
 1035              	.L58:
 1036 0056 402B     	 cmp r3,#64
 1037 0058 03D0     	 beq .L57
 1038 005a 602B     	 cmp r3,#96
 1039 005c 00F05E82 	 beq .L59
 1040 0060 78E2     	 b .L56
 1041              	.L57:
 609:../SSC/Src/sdoserv.c ****     {
 610:../SSC/Src/sdoserv.c ****     case SDOSERVICE_INITIATEDOWNLOADREQ:
 611:../SSC/Src/sdoserv.c ****     case SDOSERVICE_INITIATEUPLOADREQ:
 612:../SSC/Src/sdoserv.c ****         /* the variable index contains the requested index of the SDO service */
 613:../SSC/Src/sdoserv.c **** /*ECATCHANGE_START(V5.12) COE5*/
 614:../SSC/Src/sdoserv.c ****         index = ((UINT16)(pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK))
 1042              	 .loc 1 614 0
 1043 0062 7B68     	 ldr r3,[r7,#4]
 1044 0064 9B7A     	 ldrb r3,[r3,#10]
 1045 0066 BB83     	 strh r3,[r7,#28]
 615:../SSC/Src/sdoserv.c **** /*ECATCHANGE_END(V5.12) COE5*/
 616:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12) ECAT2*/
 617:../SSC/Src/sdoserv.c ****         index <<= 8;
 1046              	 .loc 1 617 0
 1047 0068 BB8B     	 ldrh r3,[r7,#28]
 1048 006a 1B02     	 lsls r3,r3,#8
 1049 006c BB83     	 strh r3,[r7,#28]
 618:../SSC/Src/sdoserv.c **** /*ECATCHANGE_START(V5.12) COE5*/
 619:../SSC/Src/sdoserv.c ****         index += (pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET]);
 1050              	 .loc 1 619 0
 1051 006e 7B68     	 ldr r3,[r7,#4]
 1052 0070 5B7A     	 ldrb r3,[r3,#9]
 1053 0072 9AB2     	 uxth r2,r3
 1054 0074 BB8B     	 ldrh r3,[r7,#28]
 1055 0076 1344     	 add r3,r3,r2
 1056 0078 BB83     	 strh r3,[r7,#28]
 620:../SSC/Src/sdoserv.c ****         /* the variable subindex contains the requested subindex of the SDO service */
 621:../SSC/Src/sdoserv.c ****         subindex = pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET];
 1057              	 .loc 1 621 0
 1058 007a 7B68     	 ldr r3,[r7,#4]
 1059 007c DB7A     	 ldrb r3,[r3,#11]
 1060 007e FB76     	 strb r3,[r7,#27]
 622:../SSC/Src/sdoserv.c **** /*ECATCHANGE_END(V5.12) COE5*/
 623:../SSC/Src/sdoserv.c **** 
 624:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12) ECAT2*/
 625:../SSC/Src/sdoserv.c **** 
 626:../SSC/Src/sdoserv.c **** 
 627:../SSC/Src/sdoserv.c **** 
 628:../SSC/Src/sdoserv.c **** 
 629:../SSC/Src/sdoserv.c ****         /* OBJ_GetObjectHandle checks if the requested index is defined in the object dictionary */
 630:../SSC/Src/sdoserv.c ****         pObjEntry = OBJ_GetObjectHandle( index );
 1061              	 .loc 1 630 0
 1062 0080 BB8B     	 ldrh r3,[r7,#28]
 1063 0082 1846     	 mov r0,r3
 1064 0084 FFF7FEFF 	 bl OBJ_GetObjectHandle
 1065 0088 7861     	 str r0,[r7,#20]
 631:../SSC/Src/sdoserv.c **** 
 632:../SSC/Src/sdoserv.c ****         if ( pObjEntry )
 1066              	 .loc 1 632 0
 1067 008a 7B69     	 ldr r3,[r7,#20]
 1068 008c 002B     	 cmp r3,#0
 1069 008e 00F04082 	 beq .L60
 1070              	.LBB5:
 633:../SSC/Src/sdoserv.c ****         {
 634:../SSC/Src/sdoserv.c ****             /* transferType contains the information if the SDO Download Request or the SDO Upload 
 635:../SSC/Src/sdoserv.c ****                can be an expedited service (SDO data length <= 4, that means the data is stored in 
 636:../SSC/Src/sdoserv.c ****                 SDO-Header completely */
 637:../SSC/Src/sdoserv.c ****             UINT8 bTransferType = 0;
 1071              	 .loc 1 637 0
 1072 0092 0023     	 movs r3,#0
 1073 0094 87F82B30 	 strb r3,[r7,#43]
 638:../SSC/Src/sdoserv.c ****             /* pData is the pointer to the received (SDO-Download) or sent (SDO-Upload) SDO data in
 639:../SSC/Src/sdoserv.c ****             UINT16 MBXMEM * pData = NULL;
 1074              	 .loc 1 639 0
 1075 0098 0023     	 movs r3,#0
 1076 009a 7B62     	 str r3,[r7,#36]
 640:../SSC/Src/sdoserv.c ****             UINT8 segTransfer = 0;
 1077              	 .loc 1 640 0
 1078 009c 0023     	 movs r3,#0
 1079 009e 87F82330 	 strb r3,[r7,#35]
 1080              	.LBB6:
 641:../SSC/Src/sdoserv.c **** 
 642:../SSC/Src/sdoserv.c ****             {
 643:../SSC/Src/sdoserv.c **** /*ECATCHANGE_START(V5.12) COE6*/
 644:../SSC/Src/sdoserv.c ****                 UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJ
 1081              	 .loc 1 644 0
 1082 00a2 7B69     	 ldr r3,[r7,#20]
 1083 00a4 9B89     	 ldrh r3,[r3,#12]
 1084 00a6 FB74     	 strb r3,[r7,#19]
 645:../SSC/Src/sdoserv.c **** 
 646:../SSC/Src/sdoserv.c ****                 if (subindex > maxSubindex)
 1085              	 .loc 1 646 0
 1086 00a8 FA7E     	 ldrb r2,[r7,#27]
 1087 00aa FB7C     	 ldrb r3,[r7,#19]
 1088 00ac 9A42     	 cmp r2,r3
 1089 00ae 03D9     	 bls .L61
 647:../SSC/Src/sdoserv.c ****                 {
 648:../SSC/Src/sdoserv.c ****                     abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
 1090              	 .loc 1 648 0
 1091 00b0 1123     	 movs r3,#17
 1092 00b2 87F83730 	 strb r3,[r7,#55]
 1093 00b6 0EE0     	 b .L62
 1094              	.L61:
 649:../SSC/Src/sdoserv.c ****                 }
 650:../SSC/Src/sdoserv.c ****                 else
 651:../SSC/Src/sdoserv.c ****                 {
 652:../SSC/Src/sdoserv.c ****                     dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(
 1095              	 .loc 1 652 0
 1096 00b8 97F82230 	 ldrb r3,[r7,#34]
 1097 00bc 03F01003 	 and r3,r3,#16
 1098 00c0 DBB2     	 uxtb r3,r3
 1099 00c2 B98B     	 ldrh r1,[r7,#28]
 1100 00c4 FA7E     	 ldrb r2,[r7,#27]
 1101 00c6 0846     	 mov r0,r1
 1102 00c8 1146     	 mov r1,r2
 1103 00ca 7A69     	 ldr r2,[r7,#20]
 1104 00cc FFF7FEFF 	 bl OBJ_GetObjectLength
 1105 00d0 3863     	 str r0,[r7,#48]
 1106 00d2 3B6B     	 ldr r3,[r7,#48]
 1107 00d4 FB62     	 str r3,[r7,#44]
 1108              	.L62:
 653:../SSC/Src/sdoserv.c ****                 }
 654:../SSC/Src/sdoserv.c **** 
 655:../SSC/Src/sdoserv.c ****                 if( abort == 0)
 1109              	 .loc 1 655 0
 1110 00d6 97F83730 	 ldrb r3,[r7,#55]
 1111 00da 002B     	 cmp r3,#0
 1112 00dc 32D1     	 bne .L63
 656:../SSC/Src/sdoserv.c **** /*ECATCHANGE_END(V5.12) COE6*/
 657:../SSC/Src/sdoserv.c ****                 {
 658:../SSC/Src/sdoserv.c ****                     if (command == SDOSERVICE_INITIATEUPLOADREQ)
 1113              	 .loc 1 658 0
 1114 00de 97F82130 	 ldrb r3,[r7,#33]
 1115 00e2 402B     	 cmp r3,#64
 1116 00e4 28D1     	 bne .L64
 659:../SSC/Src/sdoserv.c ****                     {
 660:../SSC/Src/sdoserv.c ****                             /* SDO Upload */
 661:../SSC/Src/sdoserv.c ****                             if (mbxSize != EXPEDITED_FRAME_SIZE)
 1117              	 .loc 1 661 0
 1118 00e6 FB8B     	 ldrh r3,[r7,#30]
 1119 00e8 0A2B     	 cmp r3,#10
 1120 00ea 01D0     	 beq .L65
 662:../SSC/Src/sdoserv.c ****                             {
 663:../SSC/Src/sdoserv.c ****                                     /* a SDO Upload request has always a fixed size (2 Byte CoE-Hea
 664:../SSC/Src/sdoserv.c ****                                     return MBXERR_INVALIDSIZE;
 1121              	 .loc 1 664 0
 1122 00ec 0823     	 movs r3,#8
 1123 00ee 4CE2     	 b .L55
 1124              	.L65:
 665:../SSC/Src/sdoserv.c ****                             }
 666:../SSC/Src/sdoserv.c ****                         /* distinguish between expedited and normal upload response within the leng
 667:../SSC/Src/sdoserv.c ****                         if ((objLength <= MAX_EXPEDITED_DATA) && objLength != 0)
 1125              	 .loc 1 667 0
 1126 00f0 3B6B     	 ldr r3,[r7,#48]
 1127 00f2 042B     	 cmp r3,#4
 1128 00f4 10D8     	 bhi .L66
 1129              	 .loc 1 667 0 is_stmt 0 discriminator 1
 1130 00f6 3B6B     	 ldr r3,[r7,#48]
 1131 00f8 002B     	 cmp r3,#0
 1132 00fa 0DD0     	 beq .L66
 668:../SSC/Src/sdoserv.c ****                         {
 669:../SSC/Src/sdoserv.c ****                                 /* Expedited Upload */
 670:../SSC/Src/sdoserv.c ****                                 bTransferType = 1;
 1133              	 .loc 1 670 0 is_stmt 1
 1134 00fc 0123     	 movs r3,#1
 1135 00fe 87F82B30 	 strb r3,[r7,#43]
 671:../SSC/Src/sdoserv.c ****                             /* pData is the pointer where the object data has to be copied for the 
 672:../SSC/Src/sdoserv.c ****     /* ECATCHANGE_START(V5.12)*/
 673:../SSC/Src/sdoserv.c ****                             pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)-
 1136              	 .loc 1 673 0
 1137 0102 7B68     	 ldr r3,[r7,#4]
 1138 0104 0C33     	 adds r3,r3,#12
 1139 0106 7B62     	 str r3,[r7,#36]
 674:../SSC/Src/sdoserv.c ****     /* ECATCHANGE_END(V5.12)*/
 675:../SSC/Src/sdoserv.c ****                                                     /* initialize the 4 data bytes of the SDO uploa
 676:../SSC/Src/sdoserv.c ****                                                        could be less than 4 */
 677:../SSC/Src/sdoserv.c ****                             pData[0] = 0;
 1140              	 .loc 1 677 0
 1141 0108 7B6A     	 ldr r3,[r7,#36]
 1142 010a 0022     	 movs r2,#0
 1143 010c 1A80     	 strh r2,[r3]
 678:../SSC/Src/sdoserv.c ****                             pData[1] = 0;
 1144              	 .loc 1 678 0
 1145 010e 7B6A     	 ldr r3,[r7,#36]
 1146 0110 0233     	 adds r3,r3,#2
 1147 0112 0022     	 movs r2,#0
 1148 0114 1A80     	 strh r2,[r3]
 1149 0116 15E0     	 b .L63
 1150              	.L66:
 679:../SSC/Src/sdoserv.c ****                         }
 680:../SSC/Src/sdoserv.c ****                         else
 681:../SSC/Src/sdoserv.c ****                         {
 682:../SSC/Src/sdoserv.c ****                                 /* HBu 06.02.06: the variable dataSize has to be set to the availab
 683:../SSC/Src/sdoserv.c ****                                 dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
 1151              	 .loc 1 683 0
 1152 0118 744B     	 ldr r3,.L96+4
 1153 011a 1B88     	 ldrh r3,[r3]
 1154 011c 103B     	 subs r3,r3,#16
 1155 011e FB62     	 str r3,[r7,#44]
 684:../SSC/Src/sdoserv.c ****                             if (dataSize < objLength)
 1156              	 .loc 1 684 0
 1157 0120 FA6A     	 ldr r2,[r7,#44]
 1158 0122 3B6B     	 ldr r3,[r7,#48]
 1159 0124 9A42     	 cmp r2,r3
 1160 0126 03D2     	 bcs .L68
 685:../SSC/Src/sdoserv.c ****                             {
 686:../SSC/Src/sdoserv.c ****                                     /* Segmented Upload */
 687:../SSC/Src/sdoserv.c ****                                     segTransfer = 1;
 1161              	 .loc 1 687 0
 1162 0128 0123     	 movs r3,#1
 1163 012a 87F82330 	 strb r3,[r7,#35]
 1164 012e 09E0     	 b .L63
 1165              	.L68:
 688:../SSC/Src/sdoserv.c ****                             }
 689:../SSC/Src/sdoserv.c ****                             else
 690:../SSC/Src/sdoserv.c ****                             {
 691:../SSC/Src/sdoserv.c ****                                     /* Normal Upload */
 692:../SSC/Src/sdoserv.c ****         /* ECATCHANGE_START(V5.12)*/
 693:../SSC/Src/sdoserv.c ****                                     pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADNORMRESMBX MBXMEM *) 
 1166              	 .loc 1 693 0
 1167 0130 7B68     	 ldr r3,[r7,#4]
 1168 0132 1033     	 adds r3,r3,#16
 1169 0134 7B62     	 str r3,[r7,#36]
 1170 0136 05E0     	 b .L63
 1171              	.L64:
 694:../SSC/Src/sdoserv.c ****                                 /* ECATCHANGE_END(V5.12)*/
 695:../SSC/Src/sdoserv.c ****                             }
 696:../SSC/Src/sdoserv.c ****                                 }
 697:../SSC/Src/sdoserv.c ****                         }
 698:../SSC/Src/sdoserv.c ****                     else
 699:../SSC/Src/sdoserv.c ****                     {
 700:../SSC/Src/sdoserv.c ****                         /* SDO-Download: store if the request is a expedited or normal request  */
 701:../SSC/Src/sdoserv.c ****                         bTransferType = sdoHeader & SDOHEADER_TRANSFERTYPE;
 1172              	 .loc 1 701 0
 1173 0138 97F82230 	 ldrb r3,[r7,#34]
 1174 013c 03F00203 	 and r3,r3,#2
 1175 0140 87F82B30 	 strb r3,[r7,#43]
 1176              	.L63:
 1177              	.LBE6:
 702:../SSC/Src/sdoserv.c ****                     }
 703:../SSC/Src/sdoserv.c ****                  }
 704:../SSC/Src/sdoserv.c ****             }
 705:../SSC/Src/sdoserv.c **** 
 706:../SSC/Src/sdoserv.c **** /*ECATCHANGE_START(V5.12) COE6*/
 707:../SSC/Src/sdoserv.c ****             if ((abort == 0 ) && (command == SDOSERVICE_INITIATEDOWNLOADREQ ))
 1178              	 .loc 1 707 0
 1179 0144 97F83730 	 ldrb r3,[r7,#55]
 1180 0148 002B     	 cmp r3,#0
 1181 014a 42D1     	 bne .L69
 1182              	 .loc 1 707 0 is_stmt 0 discriminator 1
 1183 014c 97F82130 	 ldrb r3,[r7,#33]
 1184 0150 202B     	 cmp r3,#32
 1185 0152 3ED1     	 bne .L69
 708:../SSC/Src/sdoserv.c **** /*ECATCHANGE_END(V5.12) COE6*/
 709:../SSC/Src/sdoserv.c ****             {
 710:../SSC/Src/sdoserv.c ****                 /* SDO Download */
 711:../SSC/Src/sdoserv.c ****                 if ( bTransferType )
 1186              	 .loc 1 711 0 is_stmt 1
 1187 0154 97F82B30 	 ldrb r3,[r7,#43]
 1188 0158 002B     	 cmp r3,#0
 1189 015a 10D0     	 beq .L70
 712:../SSC/Src/sdoserv.c ****                 {
 713:../SSC/Src/sdoserv.c ****                     /* Expedited Download */
 714:../SSC/Src/sdoserv.c ****                     if ( mbxSize != EXPEDITED_FRAME_SIZE )
 1190              	 .loc 1 714 0
 1191 015c FB8B     	 ldrh r3,[r7,#30]
 1192 015e 0A2B     	 cmp r3,#10
 1193 0160 01D0     	 beq .L71
 715:../SSC/Src/sdoserv.c ****                     {
 716:../SSC/Src/sdoserv.c ****                         /* an Expedited SDO Download request has always a fixed size (2 Byte CoE-He
 717:../SSC/Src/sdoserv.c ****                         return MBXERR_INVALIDSIZE;
 1194              	 .loc 1 717 0
 1195 0162 0823     	 movs r3,#8
 1196 0164 11E2     	 b .L55
 1197              	.L71:
 718:../SSC/Src/sdoserv.c ****                     }
 719:../SSC/Src/sdoserv.c ****                     /* dataSize gets the real size of the downloaded object data (1,2,3 or 4) */
 720:../SSC/Src/sdoserv.c ****                     dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEAD
 1198              	 .loc 1 720 0
 1199 0166 97F82230 	 ldrb r3,[r7,#34]
 1200 016a 03F00C03 	 and r3,r3,#12
 1201 016e 9B10     	 asrs r3,r3,#2
 1202 0170 C3F10403 	 rsb r3,r3,#4
 1203 0174 FB62     	 str r3,[r7,#44]
 721:../SSC/Src/sdoserv.c ****                     /* pData is the pointer to the downloaded object data */
 722:../SSC/Src/sdoserv.c ****                     pData = (UINT16 MBXMEM *) &pSdoInd[1];
 1204              	 .loc 1 722 0
 1205 0176 7B68     	 ldr r3,[r7,#4]
 1206 0178 0C33     	 adds r3,r3,#12
 1207 017a 7B62     	 str r3,[r7,#36]
 1208 017c 29E0     	 b .L69
 1209              	.L70:
 1210              	.LBB7:
 723:../SSC/Src/sdoserv.c ****                 }
 724:../SSC/Src/sdoserv.c ****                 else
 725:../SSC/Src/sdoserv.c ****                 {
 726:../SSC/Src/sdoserv.c ****                     /* Normal Download */
 727:../SSC/Src/sdoserv.c ****                     /* downloadSize gets the real size of the downloaded data */
 728:../SSC/Src/sdoserv.c ****                     /* '&' operator was too much */
 729:../SSC/Src/sdoserv.c **** 
 730:../SSC/Src/sdoserv.c ****                     UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *)
 1211              	 .loc 1 730 0
 1212 017e 7B68     	 ldr r3,[r7,#4]
 1213 0180 DB89     	 ldrh r3,[r3,#14]
 1214 0182 1B04     	 lsls r3,r3,#16
 1215 0184 7A68     	 ldr r2,[r7,#4]
 1216 0186 9289     	 ldrh r2,[r2,#12]
 1217 0188 1344     	 add r3,r3,r2
 1218 018a FB60     	 str r3,[r7,#12]
 731:../SSC/Src/sdoserv.c **** 
 732:../SSC/Src/sdoserv.c ****                     /* HBu 29.03.06: if it is a segmented download the mbxSize has to be the comple
 733:../SSC/Src/sdoserv.c ****                     if ( (MBX_HEADER_SIZE+EXPEDITED_FRAME_SIZE+downloadSize) > u16ReceiveMbxSize )
 1219              	 .loc 1 733 0
 1220 018c FB68     	 ldr r3,[r7,#12]
 1221 018e 1033     	 adds r3,r3,#16
 1222 0190 574A     	 ldr r2,.L96+8
 1223 0192 1288     	 ldrh r2,[r2]
 1224 0194 9342     	 cmp r3,r2
 1225 0196 07D9     	 bls .L72
 734:../SSC/Src/sdoserv.c ****                     {
 735:../SSC/Src/sdoserv.c ****                         if ( mbxSize != (u16ReceiveMbxSize-MBX_HEADER_SIZE) )
 1226              	 .loc 1 735 0
 1227 0198 FA8B     	 ldrh r2,[r7,#30]
 1228 019a 554B     	 ldr r3,.L96+8
 1229 019c 1B88     	 ldrh r3,[r3]
 1230 019e 063B     	 subs r3,r3,#6
 1231 01a0 9A42     	 cmp r2,r3
 1232 01a2 08D0     	 beq .L73
 736:../SSC/Src/sdoserv.c ****                         {
 737:../SSC/Src/sdoserv.c ****                             return MBXERR_INVALIDSIZE;
 1233              	 .loc 1 737 0
 1234 01a4 0823     	 movs r3,#8
 1235 01a6 F0E1     	 b .L55
 1236              	.L72:
 738:../SSC/Src/sdoserv.c ****                         }
 739:../SSC/Src/sdoserv.c ****                     }
 740:../SSC/Src/sdoserv.c ****                     else
 741:../SSC/Src/sdoserv.c ****                     {
 742:../SSC/Src/sdoserv.c ****                         if ( mbxSize != (EXPEDITED_FRAME_SIZE+downloadSize) )
 1237              	 .loc 1 742 0
 1238 01a8 FA8B     	 ldrh r2,[r7,#30]
 1239 01aa FB68     	 ldr r3,[r7,#12]
 1240 01ac 0A33     	 adds r3,r3,#10
 1241 01ae 9A42     	 cmp r2,r3
 1242 01b0 01D0     	 beq .L73
 743:../SSC/Src/sdoserv.c ****                         {
 744:../SSC/Src/sdoserv.c ****                             /* the mbxSize and the downloadSize are not consistent (mbxSize = downl
 745:../SSC/Src/sdoserv.c ****                             return MBXERR_INVALIDSIZE;
 1243              	 .loc 1 745 0
 1244 01b2 0823     	 movs r3,#8
 1245 01b4 E9E1     	 b .L55
 1246              	.L73:
 746:../SSC/Src/sdoserv.c ****                         }
 747:../SSC/Src/sdoserv.c ****                     }
 748:../SSC/Src/sdoserv.c **** 
 749:../SSC/Src/sdoserv.c ****                     /* pData is the pointer to the downloaded object data */
 750:../SSC/Src/sdoserv.c ****                     pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data
 1247              	 .loc 1 750 0
 1248 01b6 7B68     	 ldr r3,[r7,#4]
 1249 01b8 1033     	 adds r3,r3,#16
 1250 01ba 7B62     	 str r3,[r7,#36]
 751:../SSC/Src/sdoserv.c ****                     /* the received dataSize will be checked in the object specific functions calle
 752:../SSC/Src/sdoserv.c ****                        OBJ_Write (in objdef.c) */
 753:../SSC/Src/sdoserv.c ****                     dataSize = downloadSize;
 1251              	 .loc 1 753 0
 1252 01bc FB68     	 ldr r3,[r7,#12]
 1253 01be FB62     	 str r3,[r7,#44]
 754:../SSC/Src/sdoserv.c ****                     if ( dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE) )
 1254              	 .loc 1 754 0
 1255 01c0 FB8B     	 ldrh r3,[r7,#30]
 1256 01c2 0A3B     	 subs r3,r3,#10
 1257 01c4 1A46     	 mov r2,r3
 1258 01c6 FB6A     	 ldr r3,[r7,#44]
 1259 01c8 9A42     	 cmp r2,r3
 1260 01ca 02D2     	 bcs .L69
 755:../SSC/Src/sdoserv.c ****                     {
 756:../SSC/Src/sdoserv.c ****                         /* Segmented Download */
 757:../SSC/Src/sdoserv.c ****                         segTransfer = 1;
 1261              	 .loc 1 757 0
 1262 01cc 0123     	 movs r3,#1
 1263 01ce 87F82330 	 strb r3,[r7,#35]
 1264              	.L69:
 1265              	.LBE7:
 758:../SSC/Src/sdoserv.c ****                     }
 759:../SSC/Src/sdoserv.c ****                 }
 760:../SSC/Src/sdoserv.c ****             }
 761:../SSC/Src/sdoserv.c **** 
 762:../SSC/Src/sdoserv.c **** /*ECATCHANGE_START(V5.12) COE6*/
 763:../SSC/Src/sdoserv.c ****             if ((abort == 0) && (sdoHeader & SDOHEADER_COMPLETEACCESS ))
 1266              	 .loc 1 763 0
 1267 01d2 97F83730 	 ldrb r3,[r7,#55]
 1268 01d6 002B     	 cmp r3,#0
 1269 01d8 0ED1     	 bne .L74
 1270              	 .loc 1 763 0 is_stmt 0 discriminator 1
 1271 01da 97F82230 	 ldrb r3,[r7,#34]
 1272 01de 03F01003 	 and r3,r3,#16
 1273 01e2 002B     	 cmp r3,#0
 1274 01e4 08D0     	 beq .L74
 764:../SSC/Src/sdoserv.c **** /*ECATCHANGE_END(V5.12) COE6*/
 765:../SSC/Src/sdoserv.c ****             {
 766:../SSC/Src/sdoserv.c ****                 bCompleteAccess = 1;
 1275              	 .loc 1 766 0 is_stmt 1
 1276 01e6 0123     	 movs r3,#1
 1277 01e8 87F83630 	 strb r3,[r7,#54]
 767:../SSC/Src/sdoserv.c ****                 // HBu 02.05.06: Complete Access is only supported with subindex 0 and 1
 768:../SSC/Src/sdoserv.c ****                 if (subindex > 1)
 1278              	 .loc 1 768 0
 1279 01ec FB7E     	 ldrb r3,[r7,#27]
 1280 01ee 012B     	 cmp r3,#1
 1281 01f0 02D9     	 bls .L74
 769:../SSC/Src/sdoserv.c ****                 {
 770:../SSC/Src/sdoserv.c ****                     abort = ABORTIDX_UNSUPPORTED_ACCESS;
 1282              	 .loc 1 770 0
 1283 01f2 0523     	 movs r3,#5
 1284 01f4 87F83730 	 strb r3,[r7,#55]
 1285              	.L74:
 771:../SSC/Src/sdoserv.c ****                 }
 772:../SSC/Src/sdoserv.c ****             }
 773:../SSC/Src/sdoserv.c **** 
 774:../SSC/Src/sdoserv.c ****             if ( abort == 0 )
 1286              	 .loc 1 774 0
 1287 01f8 97F83730 	 ldrb r3,[r7,#55]
 1288 01fc 002B     	 cmp r3,#0
 1289 01fe 40F08781 	 bne .L75
 775:../SSC/Src/sdoserv.c ****             {
 776:../SSC/Src/sdoserv.c ****                 if ( segTransfer )
 1290              	 .loc 1 776 0
 1291 0202 97F82330 	 ldrb r3,[r7,#35]
 1292 0206 002B     	 cmp r3,#0
 1293 0208 00F0DB80 	 beq .L76
 777:../SSC/Src/sdoserv.c ****                 {
 778:../SSC/Src/sdoserv.c ****                     bSdoSegFollows         = TRUE;
 1294              	 .loc 1 778 0
 1295 020c 394B     	 ldr r3,.L96+12
 1296 020e 0122     	 movs r2,#1
 1297 0210 1A70     	 strb r2,[r3]
 779:../SSC/Src/sdoserv.c ****                     bSdoSegLastToggle     = 1;
 1298              	 .loc 1 779 0
 1299 0212 394B     	 ldr r3,.L96+16
 1300 0214 0122     	 movs r2,#1
 1301 0216 1A70     	 strb r2,[r3]
 780:../SSC/Src/sdoserv.c ****                     bSdoSegAccess             = bCompleteAccess;
 1302              	 .loc 1 780 0
 1303 0218 384A     	 ldr r2,.L96+20
 1304 021a 97F83630 	 ldrb r3,[r7,#54]
 1305 021e 1370     	 strb r3,[r2]
 781:../SSC/Src/sdoserv.c ****                     nSdoSegIndex             = index;
 1306              	 .loc 1 781 0
 1307 0220 374A     	 ldr r2,.L96+24
 1308 0222 BB8B     	 ldrh r3,[r7,#28]
 1309 0224 1380     	 strh r3,[r2]
 782:../SSC/Src/sdoserv.c ****                     nSdoSegSubindex         = subindex;
 1310              	 .loc 1 782 0
 1311 0226 374A     	 ldr r2,.L96+28
 1312 0228 FB7E     	 ldrb r3,[r7,#27]
 1313 022a 1370     	 strb r3,[r2]
 783:../SSC/Src/sdoserv.c ****                     pSdoSegObjEntry        = pObjEntry;
 1314              	 .loc 1 783 0
 1315 022c 364A     	 ldr r2,.L96+32
 1316 022e 7B69     	 ldr r3,[r7,#20]
 1317 0230 1360     	 str r3,[r2]
 784:../SSC/Src/sdoserv.c ****                     if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 1318              	 .loc 1 784 0
 1319 0232 97F82130 	 ldrb r3,[r7,#33]
 1320 0236 402B     	 cmp r3,#64
 1321 0238 03D1     	 bne .L77
 785:../SSC/Src/sdoserv.c ****                     {
 786:../SSC/Src/sdoserv.c ****                         nSdoSegCompleteSize    = objLength;
 1322              	 .loc 1 786 0
 1323 023a 344A     	 ldr r2,.L96+36
 1324 023c 3B6B     	 ldr r3,[r7,#48]
 1325 023e 1360     	 str r3,[r2]
 1326 0240 02E0     	 b .L78
 1327              	.L77:
 787:../SSC/Src/sdoserv.c ****                     }
 788:../SSC/Src/sdoserv.c ****                     else
 789:../SSC/Src/sdoserv.c ****                     {
 790:../SSC/Src/sdoserv.c ****                         nSdoSegCompleteSize    = dataSize;
 1328              	 .loc 1 790 0
 1329 0242 324A     	 ldr r2,.L96+36
 1330 0244 FB6A     	 ldr r3,[r7,#44]
 1331 0246 1360     	 str r3,[r2]
 1332              	.L78:
 791:../SSC/Src/sdoserv.c ****                     }
 792:../SSC/Src/sdoserv.c **** 
 793:../SSC/Src/sdoserv.c ****                     if (pSdoSegData != NULL)
 1333              	 .loc 1 793 0
 1334 0248 314B     	 ldr r3,.L96+40
 1335 024a 1B68     	 ldr r3,[r3]
 1336 024c 002B     	 cmp r3,#0
 1337 024e 07D0     	 beq .L79
 794:../SSC/Src/sdoserv.c ****                     {
 795:../SSC/Src/sdoserv.c ****                         FREEMEM( (UINT16 VARMEM *) pSdoSegData);
 1338              	 .loc 1 795 0
 1339 0250 2F4B     	 ldr r3,.L96+40
 1340 0252 1B68     	 ldr r3,[r3]
 1341 0254 1846     	 mov r0,r3
 1342 0256 FFF7FEFF 	 bl free
 796:../SSC/Src/sdoserv.c ****                         pSdoSegData = NULL;
 1343              	 .loc 1 796 0
 1344 025a 2D4B     	 ldr r3,.L96+40
 1345 025c 0022     	 movs r2,#0
 1346 025e 1A60     	 str r2,[r3]
 1347              	.L79:
 797:../SSC/Src/sdoserv.c ****                     }
 798:../SSC/Src/sdoserv.c ****                     pSdoSegData = (UINT16 VARMEM *) ALLOCMEM( ROUNDUPBYTE2WORD(nSdoSegCompleteSize)
 1348              	 .loc 1 798 0
 1349 0260 2A4B     	 ldr r3,.L96+36
 1350 0262 1B68     	 ldr r3,[r3]
 1351 0264 0133     	 adds r3,r3,#1
 1352 0266 23F00103 	 bic r3,r3,#1
 1353 026a 1846     	 mov r0,r3
 1354 026c FFF7FEFF 	 bl malloc
 1355 0270 0346     	 mov r3,r0
 1356 0272 1A46     	 mov r2,r3
 1357 0274 264B     	 ldr r3,.L96+40
 1358 0276 1A60     	 str r2,[r3]
 799:../SSC/Src/sdoserv.c **** 
 800:../SSC/Src/sdoserv.c ****                     if ( pSdoSegData == NULL )
 1359              	 .loc 1 800 0
 1360 0278 254B     	 ldr r3,.L96+40
 1361 027a 1B68     	 ldr r3,[r3]
 1362 027c 002B     	 cmp r3,#0
 1363 027e 0BD1     	 bne .L80
 801:../SSC/Src/sdoserv.c ****                     {
 802:../SSC/Src/sdoserv.c ****                         if(bCompleteAccess)
 1364              	 .loc 1 802 0
 1365 0280 97F83630 	 ldrb r3,[r7,#54]
 1366 0284 002B     	 cmp r3,#0
 1367 0286 03D0     	 beq .L81
 803:../SSC/Src/sdoserv.c ****                         {
 804:../SSC/Src/sdoserv.c ****                             abort = ABORTIDX_UNSUPPORTED_ACCESS;
 1368              	 .loc 1 804 0
 1369 0288 0523     	 movs r3,#5
 1370 028a 87F83730 	 strb r3,[r7,#55]
 1371 028e 3FE1     	 b .L75
 1372              	.L81:
 805:../SSC/Src/sdoserv.c ****                         }
 806:../SSC/Src/sdoserv.c ****                         else
 807:../SSC/Src/sdoserv.c ****                         {
 808:../SSC/Src/sdoserv.c ****                             abort = ABORTIDX_OUT_OF_MEMORY;
 1373              	 .loc 1 808 0
 1374 0290 0423     	 movs r3,#4
 1375 0292 87F83730 	 strb r3,[r7,#55]
 1376 0296 3BE1     	 b .L75
 1377              	.L80:
 809:../SSC/Src/sdoserv.c ****                         }
 810:../SSC/Src/sdoserv.c ****                     }
 811:../SSC/Src/sdoserv.c ****                     else
 812:../SSC/Src/sdoserv.c ****                     {
 813:../SSC/Src/sdoserv.c ****                         if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 1378              	 .loc 1 813 0
 1379 0298 97F82130 	 ldrb r3,[r7,#33]
 1380 029c 402B     	 cmp r3,#64
 1381 029e 7AD1     	 bne .L84
 814:../SSC/Src/sdoserv.c ****                         {
 815:../SSC/Src/sdoserv.c ****                             /* Segmented Upload */
 816:../SSC/Src/sdoserv.c ****                             abort = OBJ_Read( index, subindex, objLength, pObjEntry, (UINT16 MBXMEM
 1382              	 .loc 1 816 0
 1383 02a0 1B4B     	 ldr r3,.L96+40
 1384 02a2 1B68     	 ldr r3,[r3]
 1385 02a4 B98B     	 ldrh r1,[r7,#28]
 1386 02a6 FA7E     	 ldrb r2,[r7,#27]
 1387 02a8 0093     	 str r3,[sp]
 1388 02aa 97F83630 	 ldrb r3,[r7,#54]
 1389 02ae 0193     	 str r3,[sp,#4]
 1390 02b0 0846     	 mov r0,r1
 1391 02b2 1146     	 mov r1,r2
 1392 02b4 3A6B     	 ldr r2,[r7,#48]
 1393 02b6 7B69     	 ldr r3,[r7,#20]
 1394 02b8 FFF7FEFF 	 bl OBJ_Read
 1395 02bc 0346     	 mov r3,r0
 1396 02be 87F83730 	 strb r3,[r7,#55]
 817:../SSC/Src/sdoserv.c ****                             if ( abort == 0 )
 1397              	 .loc 1 817 0
 1398 02c2 97F83730 	 ldrb r3,[r7,#55]
 1399 02c6 002B     	 cmp r3,#0
 1400 02c8 26D1     	 bne .L85
 818:../SSC/Src/sdoserv.c ****                             {
 819:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12)*/
 820:../SSC/Src/sdoserv.c ****                                 MBXMEMCPY((UINT16 *) ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)-
 1401              	 .loc 1 820 0
 1402 02ca 7B68     	 ldr r3,[r7,#4]
 1403 02cc 03F11002 	 add r2,r3,#16
 1404 02d0 0F4B     	 ldr r3,.L96+40
 1405 02d2 1B68     	 ldr r3,[r3]
 1406 02d4 1046     	 mov r0,r2
 1407 02d6 1946     	 mov r1,r3
 1408 02d8 FA6A     	 ldr r2,[r7,#44]
 1409 02da FFF7FEFF 	 bl memcpy
 821:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12)*/
 822:../SSC/Src/sdoserv.c ****                                 nSdoSegService    = SDOSERVICE_UPLOADSEGMENTREQ;
 1410              	 .loc 1 822 0
 1411 02de 0D4B     	 ldr r3,.L96+44
 1412 02e0 6022     	 movs r2,#96
 1413 02e2 1A70     	 strb r2,[r3]
 1414 02e4 69E0     	 b .L86
 1415              	.L97:
 1416 02e6 00BF     	 .align 2
 1417              	.L96:
 1418 02e8 00000000 	 .word bSdoInWork
 1419 02ec 00000000 	 .word u16SendMbxSize
 1420 02f0 00000000 	 .word u16ReceiveMbxSize
 1421 02f4 00000000 	 .word bSdoSegFollows
 1422 02f8 00000000 	 .word bSdoSegLastToggle
 1423 02fc 00000000 	 .word bSdoSegAccess
 1424 0300 00000000 	 .word nSdoSegIndex
 1425 0304 00000000 	 .word nSdoSegSubindex
 1426 0308 00000000 	 .word pSdoSegObjEntry
 1427 030c 00000000 	 .word nSdoSegCompleteSize
 1428 0310 00000000 	 .word pSdoSegData
 1429 0314 00000000 	 .word nSdoSegService
 1430              	.L85:
 823:../SSC/Src/sdoserv.c ****                             }
 824:../SSC/Src/sdoserv.c ****                             else if ( abort == ABORTIDX_WORKING )
 1431              	 .loc 1 824 0
 1432 0318 97F83730 	 ldrb r3,[r7,#55]
 1433 031c FF2B     	 cmp r3,#255
 1434 031e 4CD1     	 bne .L86
 825:../SSC/Src/sdoserv.c ****                             {
 826:../SSC/Src/sdoserv.c ****                                 /* the application generates the SDO-Response later on by calling S
 827:../SSC/Src/sdoserv.c ****                                 u8PendingSdo = SDO_PENDING_SEG_READ;
 1435              	 .loc 1 827 0
 1436 0320 9C4B     	 ldr r3,.L98
 1437 0322 0422     	 movs r2,#4
 1438 0324 1A70     	 strb r2,[r3]
 828:../SSC/Src/sdoserv.c ****                                 bStoreCompleteAccess = bCompleteAccess;
 1439              	 .loc 1 828 0
 1440 0326 97F83630 	 ldrb r3,[r7,#54]
 1441 032a 002B     	 cmp r3,#0
 1442 032c 14BF     	 ite ne
 1443 032e 0123     	 movne r3,#1
 1444 0330 0023     	 moveq r3,#0
 1445 0332 DAB2     	 uxtb r2,r3
 1446 0334 984B     	 ldr r3,.L98+4
 1447 0336 1A70     	 strb r2,[r3]
 829:../SSC/Src/sdoserv.c ****                                 u8StoreSubindex = subindex;
 1448              	 .loc 1 829 0
 1449 0338 984A     	 ldr r2,.L98+8
 1450 033a FB7E     	 ldrb r3,[r7,#27]
 1451 033c 1370     	 strb r3,[r2]
 830:../SSC/Src/sdoserv.c ****                                 u16StoreIndex = index;
 1452              	 .loc 1 830 0
 1453 033e 984A     	 ldr r2,.L98+12
 1454 0340 BB8B     	 ldrh r3,[r7,#28]
 1455 0342 1380     	 strh r3,[r2]
 831:../SSC/Src/sdoserv.c ****                                 u32StoreDataSize = objLength;
 1456              	 .loc 1 831 0
 1457 0344 974A     	 ldr r2,.L98+16
 1458 0346 3B6B     	 ldr r3,[r7,#48]
 1459 0348 1360     	 str r3,[r2]
 832:../SSC/Src/sdoserv.c ****                                 pStoreData = pSdoSegData;
 1460              	 .loc 1 832 0
 1461 034a 974B     	 ldr r3,.L98+20
 1462 034c 1B68     	 ldr r3,[r3]
 1463 034e 974A     	 ldr r2,.L98+24
 1464 0350 1360     	 str r3,[r2]
 833:../SSC/Src/sdoserv.c ****                                 pSdoPendFunc = pObjEntry->Read;
 1465              	 .loc 1 833 0
 1466 0352 7B69     	 ldr r3,[r7,#20]
 1467 0354 DB69     	 ldr r3,[r3,#28]
 1468 0356 964A     	 ldr r2,.L98+28
 1469 0358 1360     	 str r3,[r2]
 834:../SSC/Src/sdoserv.c **** 
 835:../SSC/Src/sdoserv.c ****                                 bSdoInWork = TRUE;
 1470              	 .loc 1 835 0
 1471 035a 964B     	 ldr r3,.L98+32
 1472 035c 0122     	 movs r2,#1
 1473 035e 1A70     	 strb r2,[r3]
 836:../SSC/Src/sdoserv.c ****                                 /* we have to store the buffer and the response header */
 837:../SSC/Src/sdoserv.c ****                                 pSdoResStored = pSdoInd;
 1474              	 .loc 1 837 0
 1475 0360 954A     	 ldr r2,.L98+36
 1476 0362 7B68     	 ldr r3,[r7,#4]
 1477 0364 1360     	 str r3,[r2]
 838:../SSC/Src/sdoserv.c **** 
 839:../SSC/Src/sdoserv.c ****                                 /*update command field*/
 840:../SSC/Src/sdoserv.c ****                                 pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]   &= ~SDOHEAD
 1478              	 .loc 1 840 0
 1479 0366 944B     	 ldr r3,.L98+36
 1480 0368 1B68     	 ldr r3,[r3]
 1481 036a 0022     	 movs r2,#0
 1482 036c 1A72     	 strb r2,[r3,#8]
 841:../SSC/Src/sdoserv.c ****                                 pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]   |= (sdoHead
 1483              	 .loc 1 841 0
 1484 036e 924B     	 ldr r3,.L98+36
 1485 0370 1B68     	 ldr r3,[r3]
 1486 0372 914A     	 ldr r2,.L98+36
 1487 0374 1268     	 ldr r2,[r2]
 1488 0376 127A     	 ldrb r2,[r2,#8]
 1489 0378 D1B2     	 uxtb r1,r2
 1490 037a 97F82220 	 ldrb r2,[r7,#34]
 1491 037e 22F00F02 	 bic r2,r2,#15
 1492 0382 D2B2     	 uxtb r2,r2
 1493 0384 0A43     	 orrs r2,r2,r1
 1494 0386 D2B2     	 uxtb r2,r2
 1495 0388 D2B2     	 uxtb r2,r2
 1496 038a 1A72     	 strb r2,[r3,#8]
 842:../SSC/Src/sdoserv.c ****                                 nSdoSegService    = SDOSERVICE_UPLOADSEGMENTREQ;
 1497              	 .loc 1 842 0
 1498 038c 8B4B     	 ldr r3,.L98+40
 1499 038e 6022     	 movs r2,#96
 1500 0390 1A70     	 strb r2,[r3]
 843:../SSC/Src/sdoserv.c ****                                 return 0;
 1501              	 .loc 1 843 0
 1502 0392 0023     	 movs r3,#0
 1503 0394 F9E0     	 b .L55
 1504              	.L84:
 844:../SSC/Src/sdoserv.c ****                             }
 845:../SSC/Src/sdoserv.c ****                         }
 846:../SSC/Src/sdoserv.c ****                         else
 847:../SSC/Src/sdoserv.c ****                         {
 848:../SSC/Src/sdoserv.c ****                             /* Segmented Download */
 849:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12)*/
 850:../SSC/Src/sdoserv.c ****                             MBXMEMCPY( pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *
 1505              	 .loc 1 850 0
 1506 0396 844B     	 ldr r3,.L98+20
 1507 0398 1968     	 ldr r1,[r3]
 1508 039a 7B68     	 ldr r3,[r7,#4]
 1509 039c 03F11002 	 add r2,r3,#16
 1510 03a0 FB8B     	 ldrh r3,[r7,#30]
 1511 03a2 0A3B     	 subs r3,r3,#10
 1512 03a4 0846     	 mov r0,r1
 1513 03a6 1146     	 mov r1,r2
 1514 03a8 1A46     	 mov r2,r3
 1515 03aa FFF7FEFF 	 bl memcpy
 851:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12)*/
 852:../SSC/Src/sdoserv.c ****                             nSdoSegService    = SDOSERVICE_DOWNLOADSEGMENTREQ;
 1516              	 .loc 1 852 0
 1517 03ae 834B     	 ldr r3,.L98+40
 1518 03b0 0022     	 movs r2,#0
 1519 03b2 1A70     	 strb r2,[r3]
 853:../SSC/Src/sdoserv.c ****                             dataSize = (mbxSize-DOWNLOAD_NORM_REQ_SIZE);
 1520              	 .loc 1 853 0
 1521 03b4 FB8B     	 ldrh r3,[r7,#30]
 1522 03b6 0A3B     	 subs r3,r3,#10
 1523 03b8 FB62     	 str r3,[r7,#44]
 1524              	.L86:
 854:../SSC/Src/sdoserv.c ****                         }
 855:../SSC/Src/sdoserv.c **** 
 856:../SSC/Src/sdoserv.c ****                         nSdoSegBytesToHandle = dataSize;
 1525              	 .loc 1 856 0
 1526 03ba 814A     	 ldr r2,.L98+44
 1527 03bc FB6A     	 ldr r3,[r7,#44]
 1528 03be 1360     	 str r3,[r2]
 1529              	.LBE5:
 1530 03c0 ABE0     	 b .L89
 1531              	.L76:
 1532              	.LBB8:
 857:../SSC/Src/sdoserv.c ****                     }
 858:../SSC/Src/sdoserv.c ****                 }
 859:../SSC/Src/sdoserv.c ****                 else
 860:../SSC/Src/sdoserv.c ****                 {
 861:../SSC/Src/sdoserv.c ****                     if ( objLength == 0 )
 1533              	 .loc 1 861 0
 1534 03c2 3B6B     	 ldr r3,[r7,#48]
 1535 03c4 002B     	 cmp r3,#0
 1536 03c6 08D1     	 bne .L87
 862:../SSC/Src/sdoserv.c ****                     {
 863:../SSC/Src/sdoserv.c ****                         /* the objLength is not known, therefore the variables for a possible segme
 864:../SSC/Src/sdoserv.c ****                             should be initialized */
 865:../SSC/Src/sdoserv.c ****                         nSdoSegIndex             = index;
 1537              	 .loc 1 865 0
 1538 03c8 7E4A     	 ldr r2,.L98+48
 1539 03ca BB8B     	 ldrh r3,[r7,#28]
 1540 03cc 1380     	 strh r3,[r2]
 866:../SSC/Src/sdoserv.c ****                         nSdoSegSubindex         = subindex;
 1541              	 .loc 1 866 0
 1542 03ce 7E4A     	 ldr r2,.L98+52
 1543 03d0 FB7E     	 ldrb r3,[r7,#27]
 1544 03d2 1370     	 strb r3,[r2]
 867:../SSC/Src/sdoserv.c ****                         pSdoSegObjEntry        = pObjEntry;
 1545              	 .loc 1 867 0
 1546 03d4 7D4A     	 ldr r2,.L98+56
 1547 03d6 7B69     	 ldr r3,[r7,#20]
 1548 03d8 1360     	 str r3,[r2]
 1549              	.L87:
 868:../SSC/Src/sdoserv.c ****                     }
 869:../SSC/Src/sdoserv.c ****                     if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 1550              	 .loc 1 869 0
 1551 03da 97F82130 	 ldrb r3,[r7,#33]
 1552 03de 402B     	 cmp r3,#64
 1553 03e0 4BD1     	 bne .L88
 870:../SSC/Src/sdoserv.c ****                     {
 871:../SSC/Src/sdoserv.c ****                         /* Expedited or Normal Upload */
 872:../SSC/Src/sdoserv.c ****                         abort = OBJ_Read( index, subindex, objLength, pObjEntry, pData, bCompleteAc
 1554              	 .loc 1 872 0
 1555 03e2 B98B     	 ldrh r1,[r7,#28]
 1556 03e4 FA7E     	 ldrb r2,[r7,#27]
 1557 03e6 7B6A     	 ldr r3,[r7,#36]
 1558 03e8 0093     	 str r3,[sp]
 1559 03ea 97F83630 	 ldrb r3,[r7,#54]
 1560 03ee 0193     	 str r3,[sp,#4]
 1561 03f0 0846     	 mov r0,r1
 1562 03f2 1146     	 mov r1,r2
 1563 03f4 3A6B     	 ldr r2,[r7,#48]
 1564 03f6 7B69     	 ldr r3,[r7,#20]
 1565 03f8 FFF7FEFF 	 bl OBJ_Read
 1566 03fc 0346     	 mov r3,r0
 1567 03fe 87F83730 	 strb r3,[r7,#55]
 873:../SSC/Src/sdoserv.c ****                         if ( abort == ABORTIDX_WORKING )
 1568              	 .loc 1 873 0
 1569 0402 97F83730 	 ldrb r3,[r7,#55]
 1570 0406 FF2B     	 cmp r3,#255
 1571 0408 40F08280 	 bne .L75
 874:../SSC/Src/sdoserv.c ****                         {
 875:../SSC/Src/sdoserv.c ****                             /* the application generates the SDO-Response later on by calling SDOS_
 876:../SSC/Src/sdoserv.c ****                             u8PendingSdo = SDO_PENDING_READ;
 1572              	 .loc 1 876 0
 1573 040c 614B     	 ldr r3,.L98
 1574 040e 0322     	 movs r2,#3
 1575 0410 1A70     	 strb r2,[r3]
 877:../SSC/Src/sdoserv.c ****                             bStoreCompleteAccess = bCompleteAccess;
 1576              	 .loc 1 877 0
 1577 0412 97F83630 	 ldrb r3,[r7,#54]
 1578 0416 002B     	 cmp r3,#0
 1579 0418 14BF     	 ite ne
 1580 041a 0123     	 movne r3,#1
 1581 041c 0023     	 moveq r3,#0
 1582 041e DAB2     	 uxtb r2,r3
 1583 0420 5D4B     	 ldr r3,.L98+4
 1584 0422 1A70     	 strb r2,[r3]
 878:../SSC/Src/sdoserv.c ****                             u8StoreSubindex = subindex;
 1585              	 .loc 1 878 0
 1586 0424 5D4A     	 ldr r2,.L98+8
 1587 0426 FB7E     	 ldrb r3,[r7,#27]
 1588 0428 1370     	 strb r3,[r2]
 879:../SSC/Src/sdoserv.c ****                             u16StoreIndex = index;
 1589              	 .loc 1 879 0
 1590 042a 5D4A     	 ldr r2,.L98+12
 1591 042c BB8B     	 ldrh r3,[r7,#28]
 1592 042e 1380     	 strh r3,[r2]
 880:../SSC/Src/sdoserv.c ****                             u32StoreDataSize = objLength;
 1593              	 .loc 1 880 0
 1594 0430 5C4A     	 ldr r2,.L98+16
 1595 0432 3B6B     	 ldr r3,[r7,#48]
 1596 0434 1360     	 str r3,[r2]
 881:../SSC/Src/sdoserv.c ****                             pStoreData = pData;
 1597              	 .loc 1 881 0
 1598 0436 5D4A     	 ldr r2,.L98+24
 1599 0438 7B6A     	 ldr r3,[r7,#36]
 1600 043a 1360     	 str r3,[r2]
 882:../SSC/Src/sdoserv.c ****                             pSdoPendFunc = pObjEntry->Read;
 1601              	 .loc 1 882 0
 1602 043c 7B69     	 ldr r3,[r7,#20]
 1603 043e DB69     	 ldr r3,[r3,#28]
 1604 0440 5B4A     	 ldr r2,.L98+28
 1605 0442 1360     	 str r3,[r2]
 883:../SSC/Src/sdoserv.c **** 
 884:../SSC/Src/sdoserv.c ****                             bSdoInWork = TRUE;
 1606              	 .loc 1 884 0
 1607 0444 5B4B     	 ldr r3,.L98+32
 1608 0446 0122     	 movs r2,#1
 1609 0448 1A70     	 strb r2,[r3]
 885:../SSC/Src/sdoserv.c ****                             /* we have to store the buffer and the response header */
 886:../SSC/Src/sdoserv.c ****                             pSdoResStored = pSdoInd;
 1610              	 .loc 1 886 0
 1611 044a 5B4A     	 ldr r2,.L98+36
 1612 044c 7B68     	 ldr r3,[r7,#4]
 1613 044e 1360     	 str r3,[r2]
 887:../SSC/Src/sdoserv.c ****                             
 888:../SSC/Src/sdoserv.c ****                             /*update command field*/
 889:../SSC/Src/sdoserv.c ****                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COM
 1614              	 .loc 1 889 0
 1615 0450 594B     	 ldr r3,.L98+36
 1616 0452 1B68     	 ldr r3,[r3]
 1617 0454 0022     	 movs r2,#0
 1618 0456 1A72     	 strb r2,[r3,#8]
 890:../SSC/Src/sdoserv.c ****                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= (sdoHeader 
 1619              	 .loc 1 890 0
 1620 0458 574B     	 ldr r3,.L98+36
 1621 045a 1B68     	 ldr r3,[r3]
 1622 045c 564A     	 ldr r2,.L98+36
 1623 045e 1268     	 ldr r2,[r2]
 1624 0460 127A     	 ldrb r2,[r2,#8]
 1625 0462 D1B2     	 uxtb r1,r2
 1626 0464 97F82220 	 ldrb r2,[r7,#34]
 1627 0468 22F00F02 	 bic r2,r2,#15
 1628 046c D2B2     	 uxtb r2,r2
 1629 046e 0A43     	 orrs r2,r2,r1
 1630 0470 D2B2     	 uxtb r2,r2
 1631 0472 D2B2     	 uxtb r2,r2
 1632 0474 1A72     	 strb r2,[r3,#8]
 891:../SSC/Src/sdoserv.c ****                             return 0;
 1633              	 .loc 1 891 0
 1634 0476 0023     	 movs r3,#0
 1635 0478 87E0     	 b .L55
 1636              	.L88:
 892:../SSC/Src/sdoserv.c ****                         }
 893:../SSC/Src/sdoserv.c ****                     }
 894:../SSC/Src/sdoserv.c ****                     else
 895:../SSC/Src/sdoserv.c ****                     {
 896:../SSC/Src/sdoserv.c ****                         /* Expedited or Normal Download */
 897:../SSC/Src/sdoserv.c ****                         abort = OBJ_Write( index, subindex, dataSize, pObjEntry, pData, bCompleteAc
 1637              	 .loc 1 897 0
 1638 047a B98B     	 ldrh r1,[r7,#28]
 1639 047c FA7E     	 ldrb r2,[r7,#27]
 1640 047e 7B6A     	 ldr r3,[r7,#36]
 1641 0480 0093     	 str r3,[sp]
 1642 0482 97F83630 	 ldrb r3,[r7,#54]
 1643 0486 0193     	 str r3,[sp,#4]
 1644 0488 0846     	 mov r0,r1
 1645 048a 1146     	 mov r1,r2
 1646 048c FA6A     	 ldr r2,[r7,#44]
 1647 048e 7B69     	 ldr r3,[r7,#20]
 1648 0490 FFF7FEFF 	 bl OBJ_Write
 1649 0494 0346     	 mov r3,r0
 1650 0496 87F83730 	 strb r3,[r7,#55]
 898:../SSC/Src/sdoserv.c ****                         if ( abort == ABORTIDX_WORKING )
 1651              	 .loc 1 898 0
 1652 049a 97F83730 	 ldrb r3,[r7,#55]
 1653 049e FF2B     	 cmp r3,#255
 1654 04a0 36D1     	 bne .L75
 899:../SSC/Src/sdoserv.c ****                         {
 900:../SSC/Src/sdoserv.c ****                             /* the application generates the SDO-Response later on by calling SDOS_
 901:../SSC/Src/sdoserv.c ****                             u8PendingSdo = SDO_PENDING_WRITE;
 1655              	 .loc 1 901 0
 1656 04a2 3C4B     	 ldr r3,.L98
 1657 04a4 0122     	 movs r2,#1
 1658 04a6 1A70     	 strb r2,[r3]
 902:../SSC/Src/sdoserv.c ****                             bStoreCompleteAccess = bCompleteAccess;
 1659              	 .loc 1 902 0
 1660 04a8 97F83630 	 ldrb r3,[r7,#54]
 1661 04ac 002B     	 cmp r3,#0
 1662 04ae 14BF     	 ite ne
 1663 04b0 0123     	 movne r3,#1
 1664 04b2 0023     	 moveq r3,#0
 1665 04b4 DAB2     	 uxtb r2,r3
 1666 04b6 384B     	 ldr r3,.L98+4
 1667 04b8 1A70     	 strb r2,[r3]
 903:../SSC/Src/sdoserv.c ****                             u8StoreSubindex = subindex;
 1668              	 .loc 1 903 0
 1669 04ba 384A     	 ldr r2,.L98+8
 1670 04bc FB7E     	 ldrb r3,[r7,#27]
 1671 04be 1370     	 strb r3,[r2]
 904:../SSC/Src/sdoserv.c ****                             u16StoreIndex = index;
 1672              	 .loc 1 904 0
 1673 04c0 374A     	 ldr r2,.L98+12
 1674 04c2 BB8B     	 ldrh r3,[r7,#28]
 1675 04c4 1380     	 strh r3,[r2]
 905:../SSC/Src/sdoserv.c ****                             u32StoreDataSize = dataSize;
 1676              	 .loc 1 905 0
 1677 04c6 374A     	 ldr r2,.L98+16
 1678 04c8 FB6A     	 ldr r3,[r7,#44]
 1679 04ca 1360     	 str r3,[r2]
 906:../SSC/Src/sdoserv.c ****                             pStoreData = pData;
 1680              	 .loc 1 906 0
 1681 04cc 374A     	 ldr r2,.L98+24
 1682 04ce 7B6A     	 ldr r3,[r7,#36]
 1683 04d0 1360     	 str r3,[r2]
 907:../SSC/Src/sdoserv.c ****                             pSdoPendFunc = pObjEntry->Write;
 1684              	 .loc 1 907 0
 1685 04d2 7B69     	 ldr r3,[r7,#20]
 1686 04d4 1B6A     	 ldr r3,[r3,#32]
 1687 04d6 364A     	 ldr r2,.L98+28
 1688 04d8 1360     	 str r3,[r2]
 908:../SSC/Src/sdoserv.c **** 
 909:../SSC/Src/sdoserv.c ****                             bSdoInWork = TRUE;
 1689              	 .loc 1 909 0
 1690 04da 364B     	 ldr r3,.L98+32
 1691 04dc 0122     	 movs r2,#1
 1692 04de 1A70     	 strb r2,[r3]
 910:../SSC/Src/sdoserv.c ****                             /* we have to store the buffer and the response header */
 911:../SSC/Src/sdoserv.c ****                             pSdoResStored = pSdoInd;
 1693              	 .loc 1 911 0
 1694 04e0 354A     	 ldr r2,.L98+36
 1695 04e2 7B68     	 ldr r3,[r7,#4]
 1696 04e4 1360     	 str r3,[r2]
 912:../SSC/Src/sdoserv.c **** 
 913:../SSC/Src/sdoserv.c ****                             /*update command field*/
 914:../SSC/Src/sdoserv.c ****                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COM
 1697              	 .loc 1 914 0
 1698 04e6 344B     	 ldr r3,.L98+36
 1699 04e8 1B68     	 ldr r3,[r3]
 1700 04ea 0022     	 movs r2,#0
 1701 04ec 1A72     	 strb r2,[r3,#8]
 915:../SSC/Src/sdoserv.c ****                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= (sdoHeader 
 1702              	 .loc 1 915 0
 1703 04ee 324B     	 ldr r3,.L98+36
 1704 04f0 1B68     	 ldr r3,[r3]
 1705 04f2 314A     	 ldr r2,.L98+36
 1706 04f4 1268     	 ldr r2,[r2]
 1707 04f6 127A     	 ldrb r2,[r2,#8]
 1708 04f8 D1B2     	 uxtb r1,r2
 1709 04fa 97F82220 	 ldrb r2,[r7,#34]
 1710 04fe 22F00F02 	 bic r2,r2,#15
 1711 0502 D2B2     	 uxtb r2,r2
 1712 0504 0A43     	 orrs r2,r2,r1
 1713 0506 D2B2     	 uxtb r2,r2
 1714 0508 D2B2     	 uxtb r2,r2
 1715 050a 1A72     	 strb r2,[r3,#8]
 916:../SSC/Src/sdoserv.c ****                             return 0;
 1716              	 .loc 1 916 0
 1717 050c 0023     	 movs r3,#0
 1718 050e 3CE0     	 b .L55
 1719              	.L75:
 1720              	.LBE8:
 1721 0510 03E0     	 b .L89
 1722              	.L60:
 917:../SSC/Src/sdoserv.c ****                         }
 918:../SSC/Src/sdoserv.c ****                     }
 919:../SSC/Src/sdoserv.c ****                 } /* else if ( objLength == 0 ) */
 920:../SSC/Src/sdoserv.c ****             } /* if ( abort == 0 ) */
 921:../SSC/Src/sdoserv.c **** 
 922:../SSC/Src/sdoserv.c ****         } //if(pObjEntry) (Object handle found)
 923:../SSC/Src/sdoserv.c ****         else
 924:../SSC/Src/sdoserv.c ****         {
 925:../SSC/Src/sdoserv.c ****             abort = ABORTIDX_OBJECT_NOT_EXISTING;
 1723              	 .loc 1 925 0
 1724 0512 0823     	 movs r3,#8
 1725 0514 87F83730 	 strb r3,[r7,#55]
 926:../SSC/Src/sdoserv.c ****         }
 927:../SSC/Src/sdoserv.c ****         break;
 1726              	 .loc 1 927 0
 1727 0518 20E0     	 b .L90
 1728              	.L89:
 1729              	 .loc 1 927 0 is_stmt 0 discriminator 4
 1730 051a 1FE0     	 b .L90
 1731              	.L59:
 928:../SSC/Src/sdoserv.c **** 
 929:../SSC/Src/sdoserv.c ****     case SDOSERVICE_DOWNLOADSEGMENTREQ:
 930:../SSC/Src/sdoserv.c ****     case SDOSERVICE_UPLOADSEGMENTREQ:
 931:../SSC/Src/sdoserv.c ****         if ( command == nSdoSegService )
 1732              	 .loc 1 931 0 is_stmt 1
 1733 051c 274B     	 ldr r3,.L98+40
 1734 051e 1B78     	 ldrb r3,[r3]
 1735 0520 97F82120 	 ldrb r2,[r7,#33]
 1736 0524 9A42     	 cmp r2,r3
 1737 0526 11D1     	 bne .L91
 932:../SSC/Src/sdoserv.c ****         {
 933:../SSC/Src/sdoserv.c ****             if ( command == SDOSERVICE_DOWNLOADSEGMENTREQ )
 1738              	 .loc 1 933 0
 1739 0528 97F82130 	 ldrb r3,[r7,#33]
 1740 052c 002B     	 cmp r3,#0
 1741 052e 06D1     	 bne .L92
 934:../SSC/Src/sdoserv.c ****             {
 935:../SSC/Src/sdoserv.c ****                 abort = SdoDownloadSegmentInd( (TDOWNLOADSDOSEGREQMBX MBXMEM *) pSdoInd );
 1742              	 .loc 1 935 0
 1743 0530 7868     	 ldr r0,[r7,#4]
 1744 0532 FFF7FEFF 	 bl SdoDownloadSegmentInd
 1745 0536 0346     	 mov r3,r0
 1746 0538 87F83730 	 strb r3,[r7,#55]
 936:../SSC/Src/sdoserv.c ****             }
 937:../SSC/Src/sdoserv.c ****             else
 938:../SSC/Src/sdoserv.c ****             {
 939:../SSC/Src/sdoserv.c ****                 abort = SdoUploadSegmentInd( (TUPLOADSDOSEGREQMBX MBXMEM *) pSdoInd );
 940:../SSC/Src/sdoserv.c ****             }
 941:../SSC/Src/sdoserv.c ****         }
 942:../SSC/Src/sdoserv.c ****         else
 943:../SSC/Src/sdoserv.c ****         {
 944:../SSC/Src/sdoserv.c ****             abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 945:../SSC/Src/sdoserv.c ****         }
 946:../SSC/Src/sdoserv.c ****         break;
 1747              	 .loc 1 946 0
 1748 053c 0EE0     	 b .L90
 1749              	.L92:
 939:../SSC/Src/sdoserv.c ****             }
 1750              	 .loc 1 939 0
 1751 053e 7868     	 ldr r0,[r7,#4]
 1752 0540 FFF7FEFF 	 bl SdoUploadSegmentInd
 1753 0544 0346     	 mov r3,r0
 1754 0546 87F83730 	 strb r3,[r7,#55]
 1755              	 .loc 1 946 0
 1756 054a 07E0     	 b .L90
 1757              	.L91:
 944:../SSC/Src/sdoserv.c ****         }
 1758              	 .loc 1 944 0
 1759 054c 0323     	 movs r3,#3
 1760 054e 87F83730 	 strb r3,[r7,#55]
 1761              	 .loc 1 946 0
 1762 0552 03E0     	 b .L90
 1763              	.L56:
 947:../SSC/Src/sdoserv.c **** 
 948:../SSC/Src/sdoserv.c ****     default:
 949:../SSC/Src/sdoserv.c ****         abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 1764              	 .loc 1 949 0
 1765 0554 0323     	 movs r3,#3
 1766 0556 87F83730 	 strb r3,[r7,#55]
 950:../SSC/Src/sdoserv.c ****         break;
 1767              	 .loc 1 950 0
 1768 055a 00BF     	 nop
 1769              	.L90:
 951:../SSC/Src/sdoserv.c ****     }
 952:../SSC/Src/sdoserv.c **** 
 953:../SSC/Src/sdoserv.c ****     if(abort != ABORTIDX_WORKING)
 1770              	 .loc 1 953 0
 1771 055c 97F83730 	 ldrb r3,[r7,#55]
 1772 0560 FF2B     	 cmp r3,#255
 1773 0562 11D0     	 beq .L95
 954:../SSC/Src/sdoserv.c ****     {
 955:../SSC/Src/sdoserv.c ****         /*  type cast was added because of warning */
 956:../SSC/Src/sdoserv.c ****         SdoRes(abort, command, (UINT8) (sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16) dataSize, o
 1774              	 .loc 1 956 0
 1775 0564 97F82230 	 ldrb r3,[r7,#34]
 1776 0568 03F01003 	 and r3,r3,#16
 1777 056c DAB2     	 uxtb r2,r3
 1778 056e FB6A     	 ldr r3,[r7,#44]
 1779 0570 9CB2     	 uxth r4,r3
 1780 0572 97F83700 	 ldrb r0,[r7,#55]
 1781 0576 97F82110 	 ldrb r1,[r7,#33]
 1782 057a 3B6B     	 ldr r3,[r7,#48]
 1783 057c 0093     	 str r3,[sp]
 1784 057e 7B68     	 ldr r3,[r7,#4]
 1785 0580 0193     	 str r3,[sp,#4]
 1786 0582 2346     	 mov r3,r4
 1787 0584 FFF7FEFF 	 bl SdoRes
 1788              	.L95:
 957:../SSC/Src/sdoserv.c ****     }
 958:../SSC/Src/sdoserv.c **** 
 959:../SSC/Src/sdoserv.c ****     return 0;
 1789              	 .loc 1 959 0
 1790 0588 0023     	 movs r3,#0
 1791              	.L55:
 960:../SSC/Src/sdoserv.c **** }
 1792              	 .loc 1 960 0
 1793 058a 1846     	 mov r0,r3
 1794 058c 3C37     	 adds r7,r7,#60
 1795              	.LCFI18:
 1796              	 .cfi_def_cfa_offset 12
 1797 058e BD46     	 mov sp,r7
 1798              	.LCFI19:
 1799              	 .cfi_def_cfa_register 13
 1800              	 
 1801 0590 90BD     	 pop {r4,r7,pc}
 1802              	.L99:
 1803 0592 00BF     	 .align 2
 1804              	.L98:
 1805 0594 00000000 	 .word u8PendingSdo
 1806 0598 00000000 	 .word bStoreCompleteAccess
 1807 059c 00000000 	 .word u8StoreSubindex
 1808 05a0 00000000 	 .word u16StoreIndex
 1809 05a4 00000000 	 .word u32StoreDataSize
 1810 05a8 00000000 	 .word pSdoSegData
 1811 05ac 00000000 	 .word pStoreData
 1812 05b0 00000000 	 .word pSdoPendFunc
 1813 05b4 00000000 	 .word bSdoInWork
 1814 05b8 00000000 	 .word pSdoResStored
 1815 05bc 00000000 	 .word nSdoSegService
 1816 05c0 00000000 	 .word nSdoSegBytesToHandle
 1817 05c4 00000000 	 .word nSdoSegIndex
 1818 05c8 00000000 	 .word nSdoSegSubindex
 1819 05cc 00000000 	 .word pSdoSegObjEntry
 1820              	 .cfi_endproc
 1821              	.LFE182:
 1823              	 .section .text.SDOS_SdoRes,"ax",%progbits
 1824              	 .align 2
 1825              	 .global SDOS_SdoRes
 1826              	 .thumb
 1827              	 .thumb_func
 1829              	SDOS_SdoRes:
 1830              	.LFB183:
 961:../SSC/Src/sdoserv.c **** 
 962:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 963:../SSC/Src/sdoserv.c **** /**
 964:../SSC/Src/sdoserv.c ****  \param    abort                Result of the SDO access
 965:../SSC/Src/sdoserv.c ****  \param    objLength            Complete size of the object
 966:../SSC/Src/sdoserv.c ****  \param    pData                Pointer to the mailbox buffer
 967:../SSC/Src/sdoserv.c **** 
 968:../SSC/Src/sdoserv.c ****  \brief    This function is called when a SDO response shall be sent
 969:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 970:../SSC/Src/sdoserv.c **** 
 971:../SSC/Src/sdoserv.c **** void SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData)
 972:../SSC/Src/sdoserv.c **** {
 1831              	 .loc 1 972 0
 1832              	 .cfi_startproc
 1833              	 
 1834              	 
 1835 0000 B0B5     	 push {r4,r5,r7,lr}
 1836              	.LCFI20:
 1837              	 .cfi_def_cfa_offset 16
 1838              	 .cfi_offset 4,-16
 1839              	 .cfi_offset 5,-12
 1840              	 .cfi_offset 7,-8
 1841              	 .cfi_offset 14,-4
 1842 0002 88B0     	 sub sp,sp,#32
 1843              	.LCFI21:
 1844              	 .cfi_def_cfa_offset 48
 1845 0004 02AF     	 add r7,sp,#8
 1846              	.LCFI22:
 1847              	 .cfi_def_cfa 7,40
 1848 0006 0346     	 mov r3,r0
 1849 0008 B960     	 str r1,[r7,#8]
 1850 000a 7A60     	 str r2,[r7,#4]
 1851 000c FB73     	 strb r3,[r7,#15]
 973:../SSC/Src/sdoserv.c ****     UINT16 dataSize = 0;
 1852              	 .loc 1 973 0
 1853 000e 0023     	 movs r3,#0
 1854 0010 FB82     	 strh r3,[r7,#22]
 974:../SSC/Src/sdoserv.c **** 
 975:../SSC/Src/sdoserv.c ****     if (bSdoInWork)
 1855              	 .loc 1 975 0
 1856 0012 3A4B     	 ldr r3,.L106
 1857 0014 1B78     	 ldrb r3,[r3]
 1858 0016 002B     	 cmp r3,#0
 1859 0018 6CD0     	 beq .L100
 1860              	.LBB9:
 976:../SSC/Src/sdoserv.c ****     {
 977:../SSC/Src/sdoserv.c ****         /* SDO-Response is expected */
 978:../SSC/Src/sdoserv.c ****         UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
 1861              	 .loc 1 978 0
 1862 001a 394B     	 ldr r3,.L106+4
 1863 001c 1B68     	 ldr r3,[r3]
 1864 001e 1B7A     	 ldrb r3,[r3,#8]
 1865 0020 23F01F03 	 bic r3,r3,#31
 1866 0024 7B75     	 strb r3,[r7,#21]
 979:../SSC/Src/sdoserv.c ****         UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_CO
 1867              	 .loc 1 979 0
 1868 0026 364B     	 ldr r3,.L106+4
 1869 0028 1B68     	 ldr r3,[r3]
 1870 002a 1B7A     	 ldrb r3,[r3,#8]
 1871 002c 03F01003 	 and r3,r3,#16
 1872 0030 3B75     	 strb r3,[r7,#20]
 980:../SSC/Src/sdoserv.c **** 
 981:../SSC/Src/sdoserv.c ****         if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 1873              	 .loc 1 981 0
 1874 0032 7B7D     	 ldrb r3,[r7,#21]
 1875 0034 402B     	 cmp r3,#64
 1876 0036 4DD1     	 bne .L102
 982:../SSC/Src/sdoserv.c ****         {
 983:../SSC/Src/sdoserv.c ****             /* dataSize contains the available size in one mailbox */
 984:../SSC/Src/sdoserv.c ****             dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
 1877              	 .loc 1 984 0
 1878 0038 324B     	 ldr r3,.L106+8
 1879 003a 1B88     	 ldrh r3,[r3]
 1880 003c 103B     	 subs r3,r3,#16
 1881 003e FB82     	 strh r3,[r7,#22]
 985:../SSC/Src/sdoserv.c ****             if ( dataSize < objLength )
 1882              	 .loc 1 985 0
 1883 0040 FA8A     	 ldrh r2,[r7,#22]
 1884 0042 BB68     	 ldr r3,[r7,#8]
 1885 0044 9A42     	 cmp r2,r3
 1886 0046 1FD2     	 bcs .L103
 986:../SSC/Src/sdoserv.c ****             {
 987:../SSC/Src/sdoserv.c ****                 /* Segmented Upload, the variables for the segmented transfer should be initialized
 988:../SSC/Src/sdoserv.c ****                 bSdoSegFollows         = TRUE;
 1887              	 .loc 1 988 0
 1888 0048 2F4B     	 ldr r3,.L106+12
 1889 004a 0122     	 movs r2,#1
 1890 004c 1A70     	 strb r2,[r3]
 989:../SSC/Src/sdoserv.c ****                 bSdoSegLastToggle     = 1;
 1891              	 .loc 1 989 0
 1892 004e 2F4B     	 ldr r3,.L106+16
 1893 0050 0122     	 movs r2,#1
 1894 0052 1A70     	 strb r2,[r3]
 990:../SSC/Src/sdoserv.c ****                 bSdoSegAccess             = completeAccess;
 1895              	 .loc 1 990 0
 1896 0054 2E4A     	 ldr r2,.L106+20
 1897 0056 3B7D     	 ldrb r3,[r7,#20]
 1898 0058 1370     	 strb r3,[r2]
 991:../SSC/Src/sdoserv.c ****                 nSdoSegCompleteSize    = objLength;
 1899              	 .loc 1 991 0
 1900 005a 2E4A     	 ldr r2,.L106+24
 1901 005c BB68     	 ldr r3,[r7,#8]
 1902 005e 1360     	 str r3,[r2]
 992:../SSC/Src/sdoserv.c ****                 nSdoSegService            = SDOSERVICE_UPLOADSEGMENTREQ;
 1903              	 .loc 1 992 0
 1904 0060 2D4B     	 ldr r3,.L106+28
 1905 0062 6022     	 movs r2,#96
 1906 0064 1A70     	 strb r2,[r3]
 993:../SSC/Src/sdoserv.c ****                 pSdoSegData                = (UINT16 VARMEM *) pData;
 1907              	 .loc 1 993 0
 1908 0066 2D4A     	 ldr r2,.L106+32
 1909 0068 7B68     	 ldr r3,[r7,#4]
 1910 006a 1360     	 str r3,[r2]
 994:../SSC/Src/sdoserv.c ****                 /* the first segment shall be copied */
 995:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12)*/
 996:../SSC/Src/sdoserv.c ****                 MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pDat
 1911              	 .loc 1 996 0
 1912 006c 244B     	 ldr r3,.L106+4
 1913 006e 1B68     	 ldr r3,[r3]
 1914 0070 03F11002 	 add r2,r3,#16
 1915 0074 FB8A     	 ldrh r3,[r7,#22]
 1916 0076 1046     	 mov r0,r2
 1917 0078 7968     	 ldr r1,[r7,#4]
 1918 007a 1A46     	 mov r2,r3
 1919 007c FFF7FEFF 	 bl memcpy
 997:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12)*/
 998:../SSC/Src/sdoserv.c ****                 nSdoSegBytesToHandle = dataSize;
 1920              	 .loc 1 998 0
 1921 0080 FB8A     	 ldrh r3,[r7,#22]
 1922 0082 274A     	 ldr r2,.L106+36
 1923 0084 1360     	 str r3,[r2]
 1924 0086 25E0     	 b .L102
 1925              	.L103:
 999:../SSC/Src/sdoserv.c ****             }
1000:../SSC/Src/sdoserv.c ****             else
1001:../SSC/Src/sdoserv.c ****             if ( (objLength <= 4) && (objLength > 0) )
 1926              	 .loc 1 1001 0
 1927 0088 BB68     	 ldr r3,[r7,#8]
 1928 008a 042B     	 cmp r3,#4
 1929 008c 13D8     	 bhi .L104
 1930              	 .loc 1 1001 0 is_stmt 0 discriminator 1
 1931 008e BB68     	 ldr r3,[r7,#8]
 1932 0090 002B     	 cmp r3,#0
 1933 0092 10D0     	 beq .L104
1002:../SSC/Src/sdoserv.c ****             {
1003:../SSC/Src/sdoserv.c ****                 /* Expedited response */
1004:../SSC/Src/sdoserv.c ****                 if ( pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data )
 1934              	 .loc 1 1004 0 is_stmt 1
 1935 0094 1A4B     	 ldr r3,.L106+4
 1936 0096 1B68     	 ldr r3,[r3]
 1937 0098 03F10C02 	 add r2,r3,#12
 1938 009c 7B68     	 ldr r3,[r7,#4]
 1939 009e 9A42     	 cmp r2,r3
 1940 00a0 08D0     	 beq .L105
1005:../SSC/Src/sdoserv.c ****                 {
1006:../SSC/Src/sdoserv.c ****                     /* the data is not in the response buffer yet, it shall be copied */
1007:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12)*/
1008:../SSC/Src/sdoserv.c ****                     MBXMEMCPY((UINT16 *)((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data, p
 1941              	 .loc 1 1008 0
 1942 00a2 174B     	 ldr r3,.L106+4
 1943 00a4 1B68     	 ldr r3,[r3]
 1944 00a6 0C33     	 adds r3,r3,#12
 1945 00a8 1846     	 mov r0,r3
 1946 00aa 7968     	 ldr r1,[r7,#4]
 1947 00ac BA68     	 ldr r2,[r7,#8]
 1948 00ae FFF7FEFF 	 bl memcpy
1004:../SSC/Src/sdoserv.c ****                 {
 1949              	 .loc 1 1004 0
 1950 00b2 0FE0     	 b .L102
 1951              	.L105:
 1952 00b4 0EE0     	 b .L102
 1953              	.L104:
1009:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12)*/
1010:../SSC/Src/sdoserv.c ****                 }
1011:../SSC/Src/sdoserv.c ****             }
1012:../SSC/Src/sdoserv.c ****             else
1013:../SSC/Src/sdoserv.c ****             {
1014:../SSC/Src/sdoserv.c ****                 /* Normal response */
1015:../SSC/Src/sdoserv.c ****                 if ( pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data )
 1954              	 .loc 1 1015 0
 1955 00b6 124B     	 ldr r3,.L106+4
 1956 00b8 1B68     	 ldr r3,[r3]
 1957 00ba 03F11002 	 add r2,r3,#16
 1958 00be 7B68     	 ldr r3,[r7,#4]
 1959 00c0 9A42     	 cmp r2,r3
 1960 00c2 07D0     	 beq .L102
1016:../SSC/Src/sdoserv.c ****                 {
1017:../SSC/Src/sdoserv.c ****                     /* the data is not in the response buffer yet, it shall be copied */
1018:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12)*/
1019:../SSC/Src/sdoserv.c ****                     MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, 
 1961              	 .loc 1 1019 0
 1962 00c4 0E4B     	 ldr r3,.L106+4
 1963 00c6 1B68     	 ldr r3,[r3]
 1964 00c8 1033     	 adds r3,r3,#16
 1965 00ca 1846     	 mov r0,r3
 1966 00cc 7968     	 ldr r1,[r7,#4]
 1967 00ce BA68     	 ldr r2,[r7,#8]
 1968 00d0 FFF7FEFF 	 bl memcpy
 1969              	.L102:
1020:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12)*/
1021:../SSC/Src/sdoserv.c ****                 }
1022:../SSC/Src/sdoserv.c ****             }
1023:../SSC/Src/sdoserv.c ****         }
1024:../SSC/Src/sdoserv.c **** 
1025:../SSC/Src/sdoserv.c ****         /* SDO access is finished, send the response */
1026:../SSC/Src/sdoserv.c ****         bSdoInWork = FALSE;
 1970              	 .loc 1 1026 0
 1971 00d4 094B     	 ldr r3,.L106
 1972 00d6 0022     	 movs r2,#0
 1973 00d8 1A70     	 strb r2,[r3]
1027:../SSC/Src/sdoserv.c ****         SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
 1974              	 .loc 1 1027 0
 1975 00da 094B     	 ldr r3,.L106+4
 1976 00dc 1B68     	 ldr r3,[r3]
 1977 00de F87B     	 ldrb r0,[r7,#15]
 1978 00e0 797D     	 ldrb r1,[r7,#21]
 1979 00e2 3D7D     	 ldrb r5,[r7,#20]
 1980 00e4 FC8A     	 ldrh r4,[r7,#22]
 1981 00e6 BA68     	 ldr r2,[r7,#8]
 1982 00e8 0092     	 str r2,[sp]
 1983 00ea 0193     	 str r3,[sp,#4]
 1984 00ec 2A46     	 mov r2,r5
 1985 00ee 2346     	 mov r3,r4
 1986 00f0 FFF7FEFF 	 bl SdoRes
 1987              	.L100:
 1988              	.LBE9:
1028:../SSC/Src/sdoserv.c ****     }
1029:../SSC/Src/sdoserv.c **** }
 1989              	 .loc 1 1029 0
 1990 00f4 1837     	 adds r7,r7,#24
 1991              	.LCFI23:
 1992              	 .cfi_def_cfa_offset 16
 1993 00f6 BD46     	 mov sp,r7
 1994              	.LCFI24:
 1995              	 .cfi_def_cfa_register 13
 1996              	 
 1997 00f8 B0BD     	 pop {r4,r5,r7,pc}
 1998              	.L107:
 1999 00fa 00BF     	 .align 2
 2000              	.L106:
 2001 00fc 00000000 	 .word bSdoInWork
 2002 0100 00000000 	 .word pSdoResStored
 2003 0104 00000000 	 .word u16SendMbxSize
 2004 0108 00000000 	 .word bSdoSegFollows
 2005 010c 00000000 	 .word bSdoSegLastToggle
 2006 0110 00000000 	 .word bSdoSegAccess
 2007 0114 00000000 	 .word nSdoSegCompleteSize
 2008 0118 00000000 	 .word nSdoSegService
 2009 011c 00000000 	 .word pSdoSegData
 2010 0120 00000000 	 .word nSdoSegBytesToHandle
 2011              	 .cfi_endproc
 2012              	.LFE183:
 2014              	 .section .text.SODS_ClearPendingResponse,"ax",%progbits
 2015              	 .align 2
 2016              	 .global SODS_ClearPendingResponse
 2017              	 .thumb
 2018              	 .thumb_func
 2020              	SODS_ClearPendingResponse:
 2021              	.LFB184:
1030:../SSC/Src/sdoserv.c **** 
1031:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.12) MBX3*/
1032:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1033:../SSC/Src/sdoserv.c **** /**
1034:../SSC/Src/sdoserv.c **** \brief    Clear the variables handling a pending SDO Response
1035:../SSC/Src/sdoserv.c ****            This function shall be called before the other mailbox data pointer are set to NULL
1036:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1037:../SSC/Src/sdoserv.c **** 
1038:../SSC/Src/sdoserv.c **** void  SODS_ClearPendingResponse()
1039:../SSC/Src/sdoserv.c **** {
 2022              	 .loc 1 1039 0
 2023              	 .cfi_startproc
 2024              	 
 2025              	 
 2026 0000 80B5     	 push {r7,lr}
 2027              	.LCFI25:
 2028              	 .cfi_def_cfa_offset 8
 2029              	 .cfi_offset 7,-8
 2030              	 .cfi_offset 14,-4
 2031 0002 00AF     	 add r7,sp,#0
 2032              	.LCFI26:
 2033              	 .cfi_def_cfa_register 7
1040:../SSC/Src/sdoserv.c ****     if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRep
 2034              	 .loc 1 1040 0
 2035 0004 234B     	 ldr r3,.L111
 2036 0006 1B78     	 ldrb r3,[r3]
 2037 0008 002B     	 cmp r3,#0
 2038 000a 17D0     	 beq .L109
 2039              	 .loc 1 1040 0 is_stmt 0 discriminator 1
 2040 000c 224B     	 ldr r3,.L111+4
 2041 000e 1B68     	 ldr r3,[r3]
 2042 0010 002B     	 cmp r3,#0
 2043 0012 13D0     	 beq .L109
 2044              	 .loc 1 1040 0 discriminator 2
 2045 0014 204B     	 ldr r3,.L111+4
 2046 0016 1A68     	 ldr r2,[r3]
 2047 0018 204B     	 ldr r3,.L111+8
 2048 001a 1B68     	 ldr r3,[r3]
 2049 001c 9A42     	 cmp r2,r3
 2050 001e 0DD0     	 beq .L109
 2051              	 .loc 1 1040 0 discriminator 3
 2052 0020 1D4B     	 ldr r3,.L111+4
 2053 0022 1A68     	 ldr r2,[r3]
 2054 0024 1E4B     	 ldr r3,.L111+12
 2055 0026 1B68     	 ldr r3,[r3]
 2056 0028 9A42     	 cmp r2,r3
 2057 002a 07D0     	 beq .L109
1041:../SSC/Src/sdoserv.c ****     {
1042:../SSC/Src/sdoserv.c ****         APPL_FreeMailboxBuffer(pSdoResStored);
 2058              	 .loc 1 1042 0 is_stmt 1
 2059 002c 1A4B     	 ldr r3,.L111+4
 2060 002e 1B68     	 ldr r3,[r3]
 2061 0030 1846     	 mov r0,r3
 2062 0032 FFF7FEFF 	 bl free
1043:../SSC/Src/sdoserv.c ****         pSdoResStored = NULL;
 2063              	 .loc 1 1043 0
 2064 0036 184B     	 ldr r3,.L111+4
 2065 0038 0022     	 movs r2,#0
 2066 003a 1A60     	 str r2,[r3]
 2067              	.L109:
1044:../SSC/Src/sdoserv.c ****     }
1045:../SSC/Src/sdoserv.c **** 
1046:../SSC/Src/sdoserv.c ****     u8PendingSdo = 0;
 2068              	 .loc 1 1046 0
 2069 003c 194B     	 ldr r3,.L111+16
 2070 003e 0022     	 movs r2,#0
 2071 0040 1A70     	 strb r2,[r3]
1047:../SSC/Src/sdoserv.c ****     bStoreCompleteAccess = FALSE;
 2072              	 .loc 1 1047 0
 2073 0042 194B     	 ldr r3,.L111+20
 2074 0044 0022     	 movs r2,#0
 2075 0046 1A70     	 strb r2,[r3]
1048:../SSC/Src/sdoserv.c ****     u16StoreIndex = 0;
 2076              	 .loc 1 1048 0
 2077 0048 184B     	 ldr r3,.L111+24
 2078 004a 0022     	 movs r2,#0
 2079 004c 1A80     	 strh r2,[r3]
1049:../SSC/Src/sdoserv.c ****     u8StoreSubindex = 0;
 2080              	 .loc 1 1049 0
 2081 004e 184B     	 ldr r3,.L111+28
 2082 0050 0022     	 movs r2,#0
 2083 0052 1A70     	 strb r2,[r3]
1050:../SSC/Src/sdoserv.c ****     u32StoreDataSize = 0;
 2084              	 .loc 1 1050 0
 2085 0054 174B     	 ldr r3,.L111+32
 2086 0056 0022     	 movs r2,#0
 2087 0058 1A60     	 str r2,[r3]
1051:../SSC/Src/sdoserv.c ****     pStoreData = NULL;
 2088              	 .loc 1 1051 0
 2089 005a 174B     	 ldr r3,.L111+36
 2090 005c 0022     	 movs r2,#0
 2091 005e 1A60     	 str r2,[r3]
1052:../SSC/Src/sdoserv.c ****     pSdoPendFunc = NULL;
 2092              	 .loc 1 1052 0
 2093 0060 164B     	 ldr r3,.L111+40
 2094 0062 0022     	 movs r2,#0
 2095 0064 1A60     	 str r2,[r3]
1053:../SSC/Src/sdoserv.c ****     bSdoInWork = FALSE;
 2096              	 .loc 1 1053 0
 2097 0066 0B4B     	 ldr r3,.L111
 2098 0068 0022     	 movs r2,#0
 2099 006a 1A70     	 strb r2,[r3]
1054:../SSC/Src/sdoserv.c **** 
1055:../SSC/Src/sdoserv.c ****     if (pSdoSegData != NULL)
 2100              	 .loc 1 1055 0
 2101 006c 144B     	 ldr r3,.L111+44
 2102 006e 1B68     	 ldr r3,[r3]
 2103 0070 002B     	 cmp r3,#0
 2104 0072 07D0     	 beq .L110
1056:../SSC/Src/sdoserv.c ****     {
1057:../SSC/Src/sdoserv.c ****         FREEMEM((UINT16 VARMEM *) pSdoSegData);
 2105              	 .loc 1 1057 0
 2106 0074 124B     	 ldr r3,.L111+44
 2107 0076 1B68     	 ldr r3,[r3]
 2108 0078 1846     	 mov r0,r3
 2109 007a FFF7FEFF 	 bl free
1058:../SSC/Src/sdoserv.c ****         pSdoSegData = NULL;
 2110              	 .loc 1 1058 0
 2111 007e 104B     	 ldr r3,.L111+44
 2112 0080 0022     	 movs r2,#0
 2113 0082 1A60     	 str r2,[r3]
 2114              	.L110:
1059:../SSC/Src/sdoserv.c ****     }
1060:../SSC/Src/sdoserv.c ****     
1061:../SSC/Src/sdoserv.c ****     nSdoSegBytesToHandle = 0;
 2115              	 .loc 1 1061 0
 2116 0084 0F4B     	 ldr r3,.L111+48
 2117 0086 0022     	 movs r2,#0
 2118 0088 1A60     	 str r2,[r3]
1062:../SSC/Src/sdoserv.c ****     nSdoSegService = 0;
 2119              	 .loc 1 1062 0
 2120 008a 0F4B     	 ldr r3,.L111+52
 2121 008c 0022     	 movs r2,#0
 2122 008e 1A70     	 strb r2,[r3]
1063:../SSC/Src/sdoserv.c ****     
1064:../SSC/Src/sdoserv.c **** }
 2123              	 .loc 1 1064 0
 2124 0090 80BD     	 pop {r7,pc}
 2125              	.L112:
 2126 0092 00BF     	 .align 2
 2127              	.L111:
 2128 0094 00000000 	 .word bSdoInWork
 2129 0098 00000000 	 .word pSdoResStored
 2130 009c 00000000 	 .word psRepeatMbx
 2131 00a0 00000000 	 .word psStoreMbx
 2132 00a4 00000000 	 .word u8PendingSdo
 2133 00a8 00000000 	 .word bStoreCompleteAccess
 2134 00ac 00000000 	 .word u16StoreIndex
 2135 00b0 00000000 	 .word u8StoreSubindex
 2136 00b4 00000000 	 .word u32StoreDataSize
 2137 00b8 00000000 	 .word pStoreData
 2138 00bc 00000000 	 .word pSdoPendFunc
 2139 00c0 00000000 	 .word pSdoSegData
 2140 00c4 00000000 	 .word nSdoSegBytesToHandle
 2141 00c8 00000000 	 .word nSdoSegService
 2142              	 .cfi_endproc
 2143              	.LFE184:
 2145              	 .section .text.SDOS_SdoInfoInd,"ax",%progbits
 2146              	 .align 2
 2147              	 .global SDOS_SdoInfoInd
 2148              	 .thumb
 2149              	 .thumb_func
 2151              	SDOS_SdoInfoInd:
 2152              	.LFB185:
1065:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.12) MBX3*/
1066:../SSC/Src/sdoserv.c **** 
1067:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1068:../SSC/Src/sdoserv.c **** /**
1069:../SSC/Src/sdoserv.c ****  \param    pSdoInfoInd      Pointer to the received mailbox data from the master.
1070:../SSC/Src/sdoserv.c **** 
1071:../SSC/Src/sdoserv.c ****  \return    Indicates if an error occurred while the operation ( good = 0 ).
1072:../SSC/Src/sdoserv.c **** 
1073:../SSC/Src/sdoserv.c ****  \brief    This function is called when a SDO-Info request service
1074:../SSC/Src/sdoserv.c ****             is received from the master and calls depending from
1075:../SSC/Src/sdoserv.c ****             the opcode the concerning function.
1076:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1077:../SSC/Src/sdoserv.c **** 
1078:../SSC/Src/sdoserv.c **** UINT8 SDOS_SdoInfoInd( TSDOINFORMATION MBXMEM *pSdoInfoInd )
1079:../SSC/Src/sdoserv.c **** {
 2153              	 .loc 1 1079 0
 2154              	 .cfi_startproc
 2155              	 
 2156              	 
 2157 0000 90B5     	 push {r4,r7,lr}
 2158              	.LCFI27:
 2159              	 .cfi_def_cfa_offset 12
 2160              	 .cfi_offset 4,-12
 2161              	 .cfi_offset 7,-8
 2162              	 .cfi_offset 14,-4
 2163 0002 8FB0     	 sub sp,sp,#60
 2164              	.LCFI28:
 2165              	 .cfi_def_cfa_offset 72
 2166 0004 02AF     	 add r7,sp,#8
 2167              	.LCFI29:
 2168              	 .cfi_def_cfa 7,64
 2169 0006 7860     	 str r0,[r7,#4]
1080:../SSC/Src/sdoserv.c ****     UINT8 abort = 0;
 2170              	 .loc 1 1080 0
 2171 0008 0023     	 movs r3,#0
 2172 000a FB73     	 strb r3,[r7,#15]
1081:../SSC/Src/sdoserv.c ****     /* the variable opCode contains the requested SDO Information type */
1082:../SSC/Src/sdoserv.c ****     UINT8 opCode = (UINT8) ((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OP
 2173              	 .loc 1 1082 0
 2174 000c 7B68     	 ldr r3,[r7,#4]
 2175 000e 1B89     	 ldrh r3,[r3,#8]
 2176 0010 DBB2     	 uxtb r3,r3
 2177 0012 03F07F03 	 and r3,r3,#127
 2178 0016 87F82130 	 strb r3,[r7,#33]
1083:../SSC/Src/sdoserv.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry;
1084:../SSC/Src/sdoserv.c ****     UINT16 index;
1085:../SSC/Src/sdoserv.c ****     UINT8 flags = COE_SERVICE;
 2179              	 .loc 1 1085 0
 2180 001a 0223     	 movs r3,#2
 2181 001c 87F82F30 	 strb r3,[r7,#47]
1086:../SSC/Src/sdoserv.c **** 
1087:../SSC/Src/sdoserv.c ****     /* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
1088:../SSC/Src/sdoserv.c ****        great enough for the service header of the requested SDO Information type */
1089:../SSC/Src/sdoserv.c ****     if ( opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q )
 2182              	 .loc 1 1089 0
 2183 0020 97F82130 	 ldrb r3,[r7,#33]
 2184 0024 052B     	 cmp r3,#5
 2185 0026 05D1     	 bne .L114
1090:../SSC/Src/sdoserv.c ****     {
1091:../SSC/Src/sdoserv.c ****         if ( pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT )
 2186              	 .loc 1 1091 0
 2187 0028 7B68     	 ldr r3,[r7,#4]
 2188 002a 1B88     	 ldrh r3,[r3]
 2189 002c 092B     	 cmp r3,#9
 2190 002e 07D8     	 bhi .L115
1092:../SSC/Src/sdoserv.c ****         {
1093:../SSC/Src/sdoserv.c ****             return MBXERR_SIZETOOSHORT;
 2191              	 .loc 1 1093 0
 2192 0030 0623     	 movs r3,#6
 2193 0032 D9E1     	 b .L144
 2194              	.L114:
1094:../SSC/Src/sdoserv.c ****         }
1095:../SSC/Src/sdoserv.c ****     }
1096:../SSC/Src/sdoserv.c ****     else
1097:../SSC/Src/sdoserv.c ****     {
1098:../SSC/Src/sdoserv.c ****         if ( pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT )
 2195              	 .loc 1 1098 0
 2196 0034 7B68     	 ldr r3,[r7,#4]
 2197 0036 1B88     	 ldrh r3,[r3]
 2198 0038 072B     	 cmp r3,#7
 2199 003a 01D8     	 bhi .L115
1099:../SSC/Src/sdoserv.c ****         {
1100:../SSC/Src/sdoserv.c ****             return MBXERR_SIZETOOSHORT;
 2200              	 .loc 1 1100 0
 2201 003c 0623     	 movs r3,#6
 2202 003e D3E1     	 b .L144
 2203              	.L115:
1101:../SSC/Src/sdoserv.c ****         }
1102:../SSC/Src/sdoserv.c ****     }
1103:../SSC/Src/sdoserv.c **** 
1104:../SSC/Src/sdoserv.c ****     switch (opCode)
 2204              	 .loc 1 1104 0
 2205 0040 97F82130 	 ldrb r3,[r7,#33]
 2206 0044 032B     	 cmp r3,#3
 2207 0046 00F0CA80 	 beq .L118
 2208 004a 052B     	 cmp r3,#5
 2209 004c 00F0C780 	 beq .L118
 2210 0050 012B     	 cmp r3,#1
 2211 0052 40F09981 	 bne .L145
1105:../SSC/Src/sdoserv.c ****     {
1106:../SSC/Src/sdoserv.c ****     case SDOINFOSERVICE_OBJDICTIONARYLIST_Q:
1107:../SSC/Src/sdoserv.c ****         /* an object list is requested, check if the list type is supported */
1108:../SSC/Src/sdoserv.c ****         if (SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX)
 2212              	 .loc 1 1108 0
 2213 0056 7B68     	 ldr r3,[r7,#4]
 2214 0058 9B89     	 ldrh r3,[r3,#12]
 2215 005a 052B     	 cmp r3,#5
 2216 005c 00F2BE80 	 bhi .L120
 2217              	.LBB10:
1109:../SSC/Src/sdoserv.c ****         {
1110:../SSC/Src/sdoserv.c ****             UINT16 size = 0;
 2218              	 .loc 1 1110 0
 2219 0060 0023     	 movs r3,#0
 2220 0062 BB85     	 strh r3,[r7,#44]
1111:../SSC/Src/sdoserv.c ****             /* the variable listType contains the requested listType */
1112:../SSC/Src/sdoserv.c ****             UINT8 listType = (UINT8)SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType);
 2221              	 .loc 1 1112 0
 2222 0064 7B68     	 ldr r3,[r7,#4]
 2223 0066 9B89     	 ldrh r3,[r3,#12]
 2224 0068 87F82030 	 strb r3,[r7,#32]
1113:../SSC/Src/sdoserv.c **** 
1114:../SSC/Src/sdoserv.c ****             /* the SDO Information Header has to be stored because this function will be
1115:../SSC/Src/sdoserv.c ****                called again if the response could not be sent with one mailbox service, the
1116:../SSC/Src/sdoserv.c ****                variable nSdoInfoFragmentsLeft is 0 zero for the first call and unequal 0
1117:../SSC/Src/sdoserv.c ****                for the following calls */
1118:../SSC/Src/sdoserv.c ****             MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
 2225              	 .loc 1 1118 0
 2226 006c A848     	 ldr r0,.L146
 2227 006e 7968     	 ldr r1,[r7,#4]
 2228 0070 0E22     	 movs r2,#14
 2229 0072 FFF7FEFF 	 bl memcpy
1119:../SSC/Src/sdoserv.c ****             if (listType-- == 0)
 2230              	 .loc 1 1119 0
 2231 0076 97F82030 	 ldrb r3,[r7,#32]
 2232 007a 5A1E     	 subs r2,r3,#1
 2233 007c 87F82020 	 strb r2,[r7,#32]
 2234 0080 002B     	 cmp r3,#0
 2235 0082 22D1     	 bne .L121
 2236              	.LBB11:
1120:../SSC/Src/sdoserv.c ****             {
1121:../SSC/Src/sdoserv.c ****                 /* List-Type 0: length of the lists */
1122:../SSC/Src/sdoserv.c ****                 UINT8 i;
1123:../SSC/Src/sdoserv.c **** 
1124:../SSC/Src/sdoserv.c ****                 /* the needed mailbox size for List-Type 0 response is just 24 bytes, the mailbox h
1125:../SSC/Src/sdoserv.c ****                    to be at least 24 bytes to support the SDO Information service */
1126:../SSC/Src/sdoserv.c ****                 nSdoInfoFragmentsLeft = 0;
 2237              	 .loc 1 1126 0
 2238 0084 A34B     	 ldr r3,.L146+4
 2239 0086 0022     	 movs r2,#0
 2240 0088 1A80     	 strh r2,[r3]
1127:../SSC/Src/sdoserv.c ****                 for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
 2241              	 .loc 1 1127 0
 2242 008a 0023     	 movs r3,#0
 2243 008c 87F82B30 	 strb r3,[r7,#43]
 2244 0090 14E0     	 b .L122
 2245              	.L123:
 2246              	.LBB12:
1128:../SSC/Src/sdoserv.c ****                 {
1129:../SSC/Src/sdoserv.c ****                     UINT16 n = OBJ_GetNoOfObjects(i);
 2247              	 .loc 1 1129 0 discriminator 3
 2248 0092 97F82B30 	 ldrb r3,[r7,#43]
 2249 0096 1846     	 mov r0,r3
 2250 0098 FFF7FEFF 	 bl OBJ_GetNoOfObjects
 2251 009c 0346     	 mov r3,r0
 2252 009e FB83     	 strh r3,[r7,#30]
1130:../SSC/Src/sdoserv.c **** 
1131:../SSC/Src/sdoserv.c ****                     /* copy the number of objects of the list type in the SDO Information response 
1132:../SSC/Src/sdoserv.c ****                     ((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT >> 1) + i
 2253              	 .loc 1 1132 0 discriminator 3
 2254 00a0 7B68     	 ldr r3,[r7,#4]
 2255 00a2 9A1D     	 adds r2,r3,#6
 2256 00a4 97F82B30 	 ldrb r3,[r7,#43]
 2257 00a8 0433     	 adds r3,r3,#4
 2258 00aa 5B00     	 lsls r3,r3,#1
 2259 00ac 1344     	 add r3,r3,r2
 2260 00ae FA8B     	 ldrh r2,[r7,#30]
 2261 00b0 1A80     	 strh r2,[r3]
 2262              	.LBE12:
1127:../SSC/Src/sdoserv.c ****                 {
 2263              	 .loc 1 1127 0 discriminator 3
 2264 00b2 97F82B30 	 ldrb r3,[r7,#43]
 2265 00b6 0133     	 adds r3,r3,#1
 2266 00b8 87F82B30 	 strb r3,[r7,#43]
 2267              	.L122:
1127:../SSC/Src/sdoserv.c ****                 {
 2268              	 .loc 1 1127 0 is_stmt 0 discriminator 1
 2269 00bc 97F82B30 	 ldrb r3,[r7,#43]
 2270 00c0 042B     	 cmp r3,#4
 2271 00c2 E6D9     	 bls .L123
1133:../SSC/Src/sdoserv.c ****                 }
1134:../SSC/Src/sdoserv.c **** 
1135:../SSC/Src/sdoserv.c ****                 /* size of the mailbox service response */
1136:../SSC/Src/sdoserv.c ****                 size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
 2272              	 .loc 1 1136 0 is_stmt 1
 2273 00c4 1223     	 movs r3,#18
 2274 00c6 BB85     	 strh r3,[r7,#44]
 2275              	.LBE11:
 2276 00c8 5AE0     	 b .L124
 2277              	.L121:
 2278              	.LBB13:
1137:../SSC/Src/sdoserv.c ****             }
1138:../SSC/Src/sdoserv.c ****             else
1139:../SSC/Src/sdoserv.c ****             {
1140:../SSC/Src/sdoserv.c ****                 /* object list with indexes is requested */
1141:../SSC/Src/sdoserv.c ****                 UINT16 MBXMEM * pData;
1142:../SSC/Src/sdoserv.c ****                 UINT16 n = 0;
 2279              	 .loc 1 1142 0
 2280 00ca 0023     	 movs r3,#0
 2281 00cc BB83     	 strh r3,[r7,#28]
1143:../SSC/Src/sdoserv.c **** 
1144:../SSC/Src/sdoserv.c ****                 if (nSdoInfoFragmentsLeft)
 2282              	 .loc 1 1144 0
 2283 00ce 914B     	 ldr r3,.L146+4
 2284 00d0 1B88     	 ldrh r3,[r3]
 2285 00d2 002B     	 cmp r3,#0
 2286 00d4 11D0     	 beq .L125
1145:../SSC/Src/sdoserv.c ****                 {
1146:../SSC/Src/sdoserv.c ****                     /* the next fragment of the SDO Information response shall be sent */
1147:../SSC/Src/sdoserv.c ****                     /* initialize size with the maximum size fits into one mailbox service */
1148:../SSC/Src/sdoserv.c ****                     {
1149:../SSC/Src/sdoserv.c ****                         size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
 2287              	 .loc 1 1149 0
 2288 00d6 904B     	 ldr r3,.L146+8
 2289 00d8 1B88     	 ldrh r3,[r3]
 2290 00da 0C3B     	 subs r3,r3,#12
 2291 00dc BB85     	 strh r3,[r7,#44]
1150:../SSC/Src/sdoserv.c ****                     }
1151:../SSC/Src/sdoserv.c ****                     /* initialize pData with the pointer where the fragment has to be copied */
1152:../SSC/Src/sdoserv.c ****                     pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO >> 1];
 2292              	 .loc 1 1152 0
 2293 00de 7B68     	 ldr r3,[r7,#4]
 2294 00e0 0633     	 adds r3,r3,#6
 2295 00e2 0633     	 adds r3,r3,#6
 2296 00e4 7B62     	 str r3,[r7,#36]
1153:../SSC/Src/sdoserv.c ****                     /* initialize index with the next index to be sent */
1154:../SSC/Src/sdoserv.c ****                     index = nSdoInfoIndex;
 2297              	 .loc 1 1154 0
 2298 00e6 8D4B     	 ldr r3,.L146+12
 2299 00e8 1B88     	 ldrh r3,[r3]
 2300 00ea BB81     	 strh r3,[r7,#12]
1155:../SSC/Src/sdoserv.c ****                     /* decrement the number of fragments to be sent */
1156:../SSC/Src/sdoserv.c ****                     nSdoInfoFragmentsLeft--;
 2301              	 .loc 1 1156 0
 2302 00ec 894B     	 ldr r3,.L146+4
 2303 00ee 1B88     	 ldrh r3,[r3]
 2304 00f0 013B     	 subs r3,r3,#1
 2305 00f2 9AB2     	 uxth r2,r3
 2306 00f4 874B     	 ldr r3,.L146+4
 2307 00f6 1A80     	 strh r2,[r3]
 2308 00f8 2AE0     	 b .L126
 2309              	.L125:
1157:../SSC/Src/sdoserv.c ****                 }
1158:../SSC/Src/sdoserv.c ****                 else
1159:../SSC/Src/sdoserv.c ****                 {
1160:../SSC/Src/sdoserv.c ****                     /* the first fragment of the SDO Information response has to be sent */
1161:../SSC/Src/sdoserv.c ****                     /* get the number of objects of the requested object list */
1162:../SSC/Src/sdoserv.c ****                     n = OBJ_GetNoOfObjects(listType);
 2310              	 .loc 1 1162 0
 2311 00fa 97F82030 	 ldrb r3,[r7,#32]
 2312 00fe 1846     	 mov r0,r3
 2313 0100 FFF7FEFF 	 bl OBJ_GetNoOfObjects
 2314 0104 0346     	 mov r3,r0
 2315 0106 BB83     	 strh r3,[r7,#28]
1163:../SSC/Src/sdoserv.c ****                     /* we start with index 0x1000 */
1164:../SSC/Src/sdoserv.c ****                     index = 0x1000;
 2316              	 .loc 1 1164 0
 2317 0108 4FF48053 	 mov r3,#4096
 2318 010c BB81     	 strh r3,[r7,#12]
1165:../SSC/Src/sdoserv.c ****                     /* initialize size with the maximum size fits into one mailbox service */
1166:../SSC/Src/sdoserv.c ****                     {
1167:../SSC/Src/sdoserv.c ****                         size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
 2319              	 .loc 1 1167 0
 2320 010e 824B     	 ldr r3,.L146+8
 2321 0110 1B88     	 ldrh r3,[r3]
 2322 0112 0E3B     	 subs r3,r3,#14
 2323 0114 BB85     	 strh r3,[r7,#44]
1168:../SSC/Src/sdoserv.c ****                     }
1169:../SSC/Src/sdoserv.c ****                     /* initialize pData with the pointer where the fragment has to be copied */
1170:../SSC/Src/sdoserv.c ****                     pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT >
 2324              	 .loc 1 1170 0
 2325 0116 7B68     	 ldr r3,[r7,#4]
 2326 0118 0633     	 adds r3,r3,#6
 2327 011a 0833     	 adds r3,r3,#8
 2328 011c 7B62     	 str r3,[r7,#36]
1171:../SSC/Src/sdoserv.c ****                     /*Check if List need to be send in fragments*/
1172:../SSC/Src/sdoserv.c ****                     if ((n << 1) > size)
 2329              	 .loc 1 1172 0
 2330 011e BB8B     	 ldrh r3,[r7,#28]
 2331 0120 5A00     	 lsls r2,r3,#1
 2332 0122 BB8D     	 ldrh r3,[r7,#44]
 2333 0124 9A42     	 cmp r2,r3
 2334 0126 10DD     	 ble .L127
 2335              	.LBB14:
1173:../SSC/Src/sdoserv.c ****                     {
1174:../SSC/Src/sdoserv.c ****                         /*number of Bytes to transmit don't fit into one mailbox datagram*/
1175:../SSC/Src/sdoserv.c **** 
1176:../SSC/Src/sdoserv.c ****                         /*calculate number of fragments which need to be send
1177:../SSC/Src/sdoserv.c ****                         total number of bytes - bytes which will be transmitted with the current re
1178:../SSC/Src/sdoserv.c ****                         */
1179:../SSC/Src/sdoserv.c ****                         UINT16 Fragsize = size + 2;
 2336              	 .loc 1 1179 0
 2337 0128 BB8D     	 ldrh r3,[r7,#44]
 2338 012a 0233     	 adds r3,r3,#2
 2339 012c 7B83     	 strh r3,[r7,#26]
1180:../SSC/Src/sdoserv.c ****                         
1181:../SSC/Src/sdoserv.c ****                         nSdoInfoFragmentsLeft = (((n << 1) - size + (Fragsize - 1)) / Fragsize);
 2340              	 .loc 1 1181 0
 2341 012e BB8B     	 ldrh r3,[r7,#28]
 2342 0130 5A00     	 lsls r2,r3,#1
 2343 0132 BB8D     	 ldrh r3,[r7,#44]
 2344 0134 D21A     	 subs r2,r2,r3
 2345 0136 7B8B     	 ldrh r3,[r7,#26]
 2346 0138 013B     	 subs r3,r3,#1
 2347 013a 1A44     	 add r2,r2,r3
 2348 013c 7B8B     	 ldrh r3,[r7,#26]
 2349 013e 92FBF3F3 	 sdiv r3,r2,r3
 2350 0142 9AB2     	 uxth r2,r3
 2351 0144 734B     	 ldr r3,.L146+4
 2352 0146 1A80     	 strh r2,[r3]
 2353              	.LBE14:
 2354 0148 02E0     	 b .L126
 2355              	.L127:
1182:../SSC/Src/sdoserv.c ****                     }
1183:../SSC/Src/sdoserv.c ****                     else
1184:../SSC/Src/sdoserv.c ****                     {
1185:../SSC/Src/sdoserv.c ****                         nSdoInfoFragmentsLeft = 0;
 2356              	 .loc 1 1185 0
 2357 014a 724B     	 ldr r3,.L146+4
 2358 014c 0022     	 movs r2,#0
 2359 014e 1A80     	 strh r2,[r3]
 2360              	.L126:
1186:../SSC/Src/sdoserv.c ****                     }
1187:../SSC/Src/sdoserv.c ****                 }
1188:../SSC/Src/sdoserv.c **** 
1189:../SSC/Src/sdoserv.c ****                 /* get the next part of the requested object list */
1190:../SSC/Src/sdoserv.c ****                 size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
 2361              	 .loc 1 1190 0
 2362 0150 97F82030 	 ldrb r3,[r7,#32]
 2363 0154 98B2     	 uxth r0,r3
 2364 0156 07F10C01 	 add r1,r7,#12
 2365 015a BA8D     	 ldrh r2,[r7,#44]
 2366 015c 07F10F03 	 add r3,r7,#15
 2367 0160 0093     	 str r3,[sp]
 2368 0162 7B6A     	 ldr r3,[r7,#36]
 2369 0164 FFF7FEFF 	 bl OBJ_GetObjectList
 2370 0168 0346     	 mov r3,r0
 2371 016a BB85     	 strh r3,[r7,#44]
1191:../SSC/Src/sdoserv.c **** 
1192:../SSC/Src/sdoserv.c ****                 /* store index for next fragment */
1193:../SSC/Src/sdoserv.c ****                 nSdoInfoIndex = index;
 2372              	 .loc 1 1193 0
 2373 016c BA89     	 ldrh r2,[r7,#12]
 2374 016e 6B4B     	 ldr r3,.L146+12
 2375 0170 1A80     	 strh r2,[r3]
1194:../SSC/Src/sdoserv.c ****                 /* size contains before the instruction the size still available in the mailbox buf
1195:../SSC/Src/sdoserv.c ****                     and shall contain the size of the mailbox response data after the next instruct
1196:../SSC/Src/sdoserv.c ****                 {
1197:../SSC/Src/sdoserv.c ****                     size = u16SendMbxSize - size - MBX_HEADER_SIZE;
 2376              	 .loc 1 1197 0
 2377 0172 694B     	 ldr r3,.L146+8
 2378 0174 1A88     	 ldrh r2,[r3]
 2379 0176 BB8D     	 ldrh r3,[r7,#44]
 2380 0178 D31A     	 subs r3,r2,r3
 2381 017a 9BB2     	 uxth r3,r3
 2382 017c 063B     	 subs r3,r3,#6
 2383 017e BB85     	 strh r3,[r7,#44]
 2384              	.L124:
 2385              	.LBE13:
1198:../SSC/Src/sdoserv.c ****                 }
1199:../SSC/Src/sdoserv.c ****             }
1200:../SSC/Src/sdoserv.c **** 
1201:../SSC/Src/sdoserv.c ****             /* size of the mailbox response data */
1202:../SSC/Src/sdoserv.c ****             pSdoInfoInd->MbxHeader.Length = size;
 2386              	 .loc 1 1202 0
 2387 0180 7B68     	 ldr r3,[r7,#4]
 2388 0182 BA8D     	 ldrh r2,[r7,#44]
 2389 0184 1A80     	 strh r2,[r3]
1203:../SSC/Src/sdoserv.c **** 
1204:../SSC/Src/sdoserv.c ****             if (abort == 0)
 2390              	 .loc 1 1204 0
 2391 0186 FB7B     	 ldrb r3,[r7,#15]
 2392 0188 002B     	 cmp r3,#0
 2393 018a 27D1     	 bne .L120
1205:../SSC/Src/sdoserv.c ****             {
1206:../SSC/Src/sdoserv.c ****                 pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
 2394              	 .loc 1 1206 0
 2395 018c 7B68     	 ldr r3,[r7,#4]
 2396 018e 1B89     	 ldrh r3,[r3,#8]
 2397 0190 23F07F03 	 bic r3,r3,#127
 2398 0194 9AB2     	 uxth r2,r3
 2399 0196 7B68     	 ldr r3,[r7,#4]
 2400 0198 1A81     	 strh r2,[r3,#8]
1207:../SSC/Src/sdoserv.c ****                 pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_OBJDICTIONARYLIST_S << I
 2401              	 .loc 1 1207 0
 2402 019a 7B68     	 ldr r3,[r7,#4]
 2403 019c 1B89     	 ldrh r3,[r3,#8]
 2404 019e 43F00203 	 orr r3,r3,#2
 2405 01a2 9AB2     	 uxth r2,r3
 2406 01a4 7B68     	 ldr r3,[r7,#4]
 2407 01a6 1A81     	 strh r2,[r3,#8]
1208:../SSC/Src/sdoserv.c ****                 /* number of fragments still has to be sent */
1209:../SSC/Src/sdoserv.c ****                 pSdoInfoInd->SdoHeader.FragmentsLeft = SWAPWORD(nSdoInfoFragmentsLeft);
 2408              	 .loc 1 1209 0
 2409 01a8 5A4B     	 ldr r3,.L146+4
 2410 01aa 1A88     	 ldrh r2,[r3]
 2411 01ac 7B68     	 ldr r3,[r7,#4]
 2412 01ae 5A81     	 strh r2,[r3,#10]
1210:../SSC/Src/sdoserv.c **** 
1211:../SSC/Src/sdoserv.c ****                 if (nSdoInfoFragmentsLeft)
 2413              	 .loc 1 1211 0
 2414 01b0 584B     	 ldr r3,.L146+4
 2415 01b2 1B88     	 ldrh r3,[r3]
 2416 01b4 002B     	 cmp r3,#0
 2417 01b6 11D0     	 beq .L120
1212:../SSC/Src/sdoserv.c ****                 {
1213:../SSC/Src/sdoserv.c ****                     /* there still are fragments to be sent,
1214:../SSC/Src/sdoserv.c ****                        the InComplete flag in the SDO Information response has to be sent */
1215:../SSC/Src/sdoserv.c ****                     pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEADER_INCOMPLETE_MASK;
 2418              	 .loc 1 1215 0
 2419 01b8 7B68     	 ldr r3,[r7,#4]
 2420 01ba 1B89     	 ldrh r3,[r3,#8]
 2421 01bc 23F08003 	 bic r3,r3,#128
 2422 01c0 9AB2     	 uxth r2,r3
 2423 01c2 7B68     	 ldr r3,[r7,#4]
 2424 01c4 1A81     	 strh r2,[r3,#8]
1216:../SSC/Src/sdoserv.c ****                     pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_INCOMPLETE << INFOHE
 2425              	 .loc 1 1216 0
 2426 01c6 7B68     	 ldr r3,[r7,#4]
 2427 01c8 1B89     	 ldrh r3,[r3,#8]
 2428 01ca 43F08003 	 orr r3,r3,#128
 2429 01ce 9AB2     	 uxth r2,r3
 2430 01d0 7B68     	 ldr r3,[r7,#4]
 2431 01d2 1A81     	 strh r2,[r3,#8]
1217:../SSC/Src/sdoserv.c ****                     /* the FRAGMENTS_FOLLOW flag has to be set for the function MBX_MailboxSendReq 
1218:../SSC/Src/sdoserv.c ****                        indicate the mailbox handler that still fragments has to be sent so that thi
1219:../SSC/Src/sdoserv.c ****                         function shall be called again from COE_ContinueInd when the actual mailbox
1220:../SSC/Src/sdoserv.c ****                         was sent */
1221:../SSC/Src/sdoserv.c ****                     flags = FRAGMENTS_FOLLOW | COE_SERVICE;
 2432              	 .loc 1 1221 0
 2433 01d4 8223     	 movs r3,#130
 2434 01d6 87F82F30 	 strb r3,[r7,#47]
 2435              	.LBE10:
1222:../SSC/Src/sdoserv.c ****                 }
1223:../SSC/Src/sdoserv.c ****             }
1224:../SSC/Src/sdoserv.c ****         }
1225:../SSC/Src/sdoserv.c ****         break;
 2436              	 .loc 1 1225 0
 2437 01da D7E0     	 b .L128
 2438              	.L120:
 2439 01dc D6E0     	 b .L128
 2440              	.L118:
1226:../SSC/Src/sdoserv.c **** 
1227:../SSC/Src/sdoserv.c ****     case SDOINFOSERVICE_OBJDESCRIPTION_Q:
1228:../SSC/Src/sdoserv.c ****     case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
1229:../SSC/Src/sdoserv.c ****         /* get the requested index */
1230:../SSC/Src/sdoserv.c ****         index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
 2441              	 .loc 1 1230 0
 2442 01de 7B68     	 ldr r3,[r7,#4]
 2443 01e0 9B89     	 ldrh r3,[r3,#12]
 2444 01e2 BB81     	 strh r3,[r7,#12]
1231:../SSC/Src/sdoserv.c **** 
1232:../SSC/Src/sdoserv.c **** 
1233:../SSC/Src/sdoserv.c **** 
1234:../SSC/Src/sdoserv.c ****         if(index < 0x1000)
 2445              	 .loc 1 1234 0
 2446 01e4 BB89     	 ldrh r3,[r7,#12]
 2447 01e6 B3F5805F 	 cmp r3,#4096
 2448 01ea 02D2     	 bcs .L129
1235:../SSC/Src/sdoserv.c ****         {
1236:../SSC/Src/sdoserv.c ****             /*SDO Info access is only allowed for objects >= 0x1000*/
1237:../SSC/Src/sdoserv.c ****             abort = ABORTIDX_UNSUPPORTED_ACCESS;
 2449              	 .loc 1 1237 0
 2450 01ec 0523     	 movs r3,#5
 2451 01ee FB73     	 strb r3,[r7,#15]
 2452 01f0 C9E0     	 b .L130
 2453              	.L129:
1238:../SSC/Src/sdoserv.c ****         }
1239:../SSC/Src/sdoserv.c ****         else
1240:../SSC/Src/sdoserv.c ****         {
1241:../SSC/Src/sdoserv.c ****             /* get the object handle of the requested index */
1242:../SSC/Src/sdoserv.c ****             pObjEntry = OBJ_GetObjectHandle( index );
 2454              	 .loc 1 1242 0
 2455 01f2 BB89     	 ldrh r3,[r7,#12]
 2456 01f4 1846     	 mov r0,r3
 2457 01f6 FFF7FEFF 	 bl OBJ_GetObjectHandle
 2458 01fa 7861     	 str r0,[r7,#20]
1243:../SSC/Src/sdoserv.c **** 
1244:../SSC/Src/sdoserv.c ****             if ( pObjEntry )
 2459              	 .loc 1 1244 0
 2460 01fc 7B69     	 ldr r3,[r7,#20]
 2461 01fe 002B     	 cmp r3,#0
 2462 0200 00F0BE80 	 beq .L131
 2463              	.LBB15:
1245:../SSC/Src/sdoserv.c ****             {
1246:../SSC/Src/sdoserv.c ****                 /* object exists */
1247:../SSC/Src/sdoserv.c ****                 UINT16 size = 0;
 2464              	 .loc 1 1247 0
 2465 0204 0023     	 movs r3,#0
 2466 0206 7B84     	 strh r3,[r7,#34]
1248:../SSC/Src/sdoserv.c ****                 
1249:../SSC/Src/sdoserv.c ****                 if ( opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q )
 2467              	 .loc 1 1249 0
 2468 0208 97F82130 	 ldrb r3,[r7,#33]
 2469 020c 032B     	 cmp r3,#3
 2470 020e 2BD1     	 bne .L132
1250:../SSC/Src/sdoserv.c ****                 {
1251:../SSC/Src/sdoserv.c ****                     /* object description is requested */
1252:../SSC/Src/sdoserv.c ****                     OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry),
 2471              	 .loc 1 1252 0
 2472 0210 7B68     	 ldr r3,[r7,#4]
 2473 0212 03F10E04 	 add r4,r3,#14
 2474 0216 7869     	 ldr r0,[r7,#20]
 2475 0218 FFF7FEFF 	 bl OBJ_GetObjDesc
 2476 021c 0346     	 mov r3,r0
 2477 021e 2046     	 mov r0,r4
 2478 0220 1946     	 mov r1,r3
 2479 0222 0422     	 movs r2,#4
 2480 0224 FFF7FEFF 	 bl memcpy
1253:../SSC/Src/sdoserv.c **** 
1254:../SSC/Src/sdoserv.c **** 
1255:../SSC/Src/sdoserv.c ****                     /* the mailbox should be big enough that the maximum object description
1256:../SSC/Src/sdoserv.c ****                     fits in the mailbox (the fragmentation is not done in the sample code),
1257:../SSC/Src/sdoserv.c ****                     so it will be checked only if the object description fits */
1258:../SSC/Src/sdoserv.c ****                     size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
 2481              	 .loc 1 1258 0
 2482 0228 BB89     	 ldrh r3,[r7,#12]
 2483 022a 1846     	 mov r0,r3
 2484 022c 0021     	 movs r1,#0
 2485 022e 7A69     	 ldr r2,[r7,#20]
 2486 0230 0023     	 movs r3,#0
 2487 0232 FFF7FEFF 	 bl OBJ_GetDesc
 2488 0236 0346     	 mov r3,r0
 2489 0238 0C33     	 adds r3,r3,#12
 2490 023a 7B84     	 strh r3,[r7,#34]
1259:../SSC/Src/sdoserv.c **** 
1260:../SSC/Src/sdoserv.c ****                     if ( size > (u16SendMbxSize - MBX_HEADER_SIZE) )
 2491              	 .loc 1 1260 0
 2492 023c 7A8C     	 ldrh r2,[r7,#34]
 2493 023e 364B     	 ldr r3,.L146+8
 2494 0240 1B88     	 ldrh r3,[r3]
 2495 0242 063B     	 subs r3,r3,#6
 2496 0244 9A42     	 cmp r2,r3
 2497 0246 02DD     	 ble .L133
1261:../SSC/Src/sdoserv.c ****                     {
1262:../SSC/Src/sdoserv.c ****                         /* size of the object description does not fit in the mailbox,
1263:../SSC/Src/sdoserv.c ****                         the object description will be sent without the name */
1264:../SSC/Src/sdoserv.c ****                         size = SIZEOF_SDOINFOOBJSTRUCT;
 2498              	 .loc 1 1264 0
 2499 0248 0C23     	 movs r3,#12
 2500 024a 7B84     	 strh r3,[r7,#34]
 2501 024c 7BE0     	 b .L135
 2502              	.L133:
1265:../SSC/Src/sdoserv.c ****                     }
1266:../SSC/Src/sdoserv.c ****                     else
1267:../SSC/Src/sdoserv.c ****                     {
1268:../SSC/Src/sdoserv.c ****                         /* object description fits in the mailbox, get the name of the object */
1269:../SSC/Src/sdoserv.c ****                         size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->
 2503              	 .loc 1 1269 0
 2504 024e BA89     	 ldrh r2,[r7,#12]
 2505 0250 7B68     	 ldr r3,[r7,#4]
 2506 0252 0E33     	 adds r3,r3,#14
 2507 0254 0433     	 adds r3,r3,#4
 2508 0256 1046     	 mov r0,r2
 2509 0258 0021     	 movs r1,#0
 2510 025a 7A69     	 ldr r2,[r7,#20]
 2511 025c FFF7FEFF 	 bl OBJ_GetDesc
 2512 0260 0346     	 mov r3,r0
 2513 0262 0C33     	 adds r3,r3,#12
 2514 0264 7B84     	 strh r3,[r7,#34]
 2515 0266 6EE0     	 b .L135
 2516              	.L132:
 2517              	.LBB16:
1270:../SSC/Src/sdoserv.c ****                     }
1271:../SSC/Src/sdoserv.c ****                 }
1272:../SSC/Src/sdoserv.c ****                 else
1273:../SSC/Src/sdoserv.c ****                 {
1274:../SSC/Src/sdoserv.c ****                     /* entry description is requested,
1275:../SSC/Src/sdoserv.c ****                     get the requested subindex */
1276:../SSC/Src/sdoserv.c ****                     UINT8 subindex = (UINT8) ((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_
 2518              	 .loc 1 1276 0
 2519 0268 7B68     	 ldr r3,[r7,#4]
 2520 026a DB89     	 ldrh r3,[r3,#14]
 2521 026c FB74     	 strb r3,[r7,#19]
1277:../SSC/Src/sdoserv.c **** 
1278:../SSC/Src/sdoserv.c ****                     /* get the maximum subindex */
1279:../SSC/Src/sdoserv.c ****                     UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEX
 2522              	 .loc 1 1279 0
 2523 026e 7869     	 ldr r0,[r7,#20]
 2524 0270 FFF7FEFF 	 bl OBJ_GetObjDesc
 2525 0274 0346     	 mov r3,r0
 2526 0276 5B88     	 ldrh r3,[r3,#2]
 2527 0278 BB74     	 strb r3,[r7,#18]
1280:../SSC/Src/sdoserv.c **** 
1281:../SSC/Src/sdoserv.c ****                     if ( subindex <= maxSubindex )
 2528              	 .loc 1 1281 0
 2529 027a FA7C     	 ldrb r2,[r7,#19]
 2530 027c BB7C     	 ldrb r3,[r7,#18]
 2531 027e 9A42     	 cmp r2,r3
 2532 0280 5FD8     	 bhi .L136
 2533              	.LBB17:
1282:../SSC/Src/sdoserv.c ****                     {
1283:../SSC/Src/sdoserv.c ****                         UINT16 ObjectFlags;
1284:../SSC/Src/sdoserv.c ****                         /* requested subindex is not too great */
1285:../SSC/Src/sdoserv.c ****                         /* get the entry description of the requested entry */
1286:../SSC/Src/sdoserv.c ****                         OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pOb
 2534              	 .loc 1 1286 0
 2535 0282 7B68     	 ldr r3,[r7,#4]
 2536 0284 03F11004 	 add r4,r3,#16
 2537 0288 FB7C     	 ldrb r3,[r7,#19]
 2538 028a 7869     	 ldr r0,[r7,#20]
 2539 028c 1946     	 mov r1,r3
 2540 028e FFF7FEFF 	 bl OBJ_GetEntryDesc
 2541 0292 0346     	 mov r3,r0
 2542 0294 2046     	 mov r0,r4
 2543 0296 1946     	 mov r1,r3
 2544 0298 0622     	 movs r2,#6
 2545 029a FFF7FEFF 	 bl memcpy
1287:../SSC/Src/sdoserv.c **** 
1288:../SSC/Src/sdoserv.c ****                         /* the transmission of the value info is not supported yet of the sample co
1289:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
 2546              	 .loc 1 1289 0
 2547 029e 7B68     	 ldr r3,[r7,#4]
 2548 02a0 DB89     	 ldrh r3,[r3,#14]
 2549 02a2 DBB2     	 uxtb r3,r3
 2550 02a4 9AB2     	 uxth r2,r3
 2551 02a6 7B68     	 ldr r3,[r7,#4]
 2552 02a8 DA81     	 strh r2,[r3,#14]
1290:../SSC/Src/sdoserv.c ****                         ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
 2553              	 .loc 1 1290 0
 2554 02aa 7869     	 ldr r0,[r7,#20]
 2555 02ac FFF7FEFF 	 bl OBJ_GetObjDesc
 2556 02b0 0346     	 mov r3,r0
 2557 02b2 5B88     	 ldrh r3,[r3,#2]
 2558 02b4 3B82     	 strh r3,[r7,#16]
1291:../SSC/Src/sdoserv.c ****                         ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT
 2559              	 .loc 1 1291 0
 2560 02b6 3B8A     	 ldrh r3,[r7,#16]
 2561 02b8 03F47063 	 and r3,r3,#3840
 2562 02bc 1B12     	 asrs r3,r3,#8
 2563 02be 3B82     	 strh r3,[r7,#16]
1292:../SSC/Src/sdoserv.c **** 
1293:../SSC/Src/sdoserv.c ****                         if(((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subin
 2564              	 .loc 1 1293 0
 2565 02c0 3B8A     	 ldrh r3,[r7,#16]
 2566 02c2 082B     	 cmp r3,#8
 2567 02c4 02D0     	 beq .L137
 2568              	 .loc 1 1293 0 is_stmt 0 discriminator 2
 2569 02c6 3B8A     	 ldrh r3,[r7,#16]
 2570 02c8 092B     	 cmp r3,#9
 2571 02ca 0DD1     	 bne .L138
 2572              	.L137:
 2573              	 .loc 1 1293 0 discriminator 3
 2574 02cc FB7C     	 ldrb r3,[r7,#19]
 2575 02ce 002B     	 cmp r3,#0
 2576 02d0 0AD1     	 bne .L138
1294:../SSC/Src/sdoserv.c ****                         {
1295:../SSC/Src/sdoserv.c ****                             OBJTOMBXSTRCPY( ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry
 2577              	 .loc 1 1295 0 is_stmt 1
 2578 02d2 7B68     	 ldr r3,[r7,#4]
 2579 02d4 1033     	 adds r3,r3,#16
 2580 02d6 0633     	 adds r3,r3,#6
 2581 02d8 1846     	 mov r0,r3
 2582 02da 1149     	 ldr r1,.L146+16
 2583 02dc 0D22     	 movs r2,#13
 2584 02de FFF7FEFF 	 bl memcpy
1296:../SSC/Src/sdoserv.c ****                             size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "S
 2585              	 .loc 1 1296 0
 2586 02e2 1C23     	 movs r3,#28
 2587 02e4 7B84     	 strh r3,[r7,#34]
 2588 02e6 2BE0     	 b .L139
 2589              	.L138:
1297:../SSC/Src/sdoserv.c ****                         }
1298:../SSC/Src/sdoserv.c ****                         else
1299:../SSC/Src/sdoserv.c ****                         {
1300:../SSC/Src/sdoserv.c ****                             /* the mailbox should be big enough that the maximum entry description
1301:../SSC/Src/sdoserv.c ****                             fits in the mailbox (the fragmentation is not done in the sample code),
1302:../SSC/Src/sdoserv.c ****                             so it will be checked only if the entry description fits */
1303:../SSC/Src/sdoserv.c ****                             size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO +
 2590              	 .loc 1 1303 0
 2591 02e8 BA89     	 ldrh r2,[r7,#12]
 2592 02ea FB7C     	 ldrb r3,[r7,#19]
 2593 02ec 1046     	 mov r0,r2
 2594 02ee 1946     	 mov r1,r3
 2595 02f0 7A69     	 ldr r2,[r7,#20]
 2596 02f2 0023     	 movs r3,#0
 2597 02f4 FFF7FEFF 	 bl OBJ_GetDesc
 2598 02f8 0346     	 mov r3,r0
 2599 02fa 1033     	 adds r3,r3,#16
 2600 02fc 7B84     	 strh r3,[r7,#34]
1304:../SSC/Src/sdoserv.c ****                             if ( size > (u16SendMbxSize - MBX_HEADER_SIZE) )
 2601              	 .loc 1 1304 0
 2602 02fe 7A8C     	 ldrh r2,[r7,#34]
 2603 0300 054B     	 ldr r3,.L146+8
 2604 0302 1B88     	 ldrh r3,[r3]
 2605 0304 063B     	 subs r3,r3,#6
 2606 0306 9A42     	 cmp r2,r3
 2607 0308 0CDD     	 ble .L140
1305:../SSC/Src/sdoserv.c ****                             {
1306:../SSC/Src/sdoserv.c ****                                 /* size of the object description does not fit in the mailbox,
1307:../SSC/Src/sdoserv.c ****                                 the object description will be sent without the name */
1308:../SSC/Src/sdoserv.c ****                                 size =  SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
 2608              	 .loc 1 1308 0
 2609 030a 1023     	 movs r3,#16
 2610 030c 7B84     	 strh r3,[r7,#34]
 2611 030e 17E0     	 b .L139
 2612              	.L147:
 2613              	 .align 2
 2614              	.L146:
 2615 0310 00000000 	 .word aSdoInfoHeader
 2616 0314 00000000 	 .word nSdoInfoFragmentsLeft
 2617 0318 00000000 	 .word u16SendMbxSize
 2618 031c 00000000 	 .word nSdoInfoIndex
 2619 0320 00000000 	 .word aSubindexDesc
 2620              	.L140:
1309:../SSC/Src/sdoserv.c ****                             }
1310:../SSC/Src/sdoserv.c ****                             else
1311:../SSC/Src/sdoserv.c ****                             {
1312:../SSC/Src/sdoserv.c ****                                 /* object description fits in the mailbox, get the name of the entr
1313:../SSC/Src/sdoserv.c ****                                 size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &
 2621              	 .loc 1 1313 0
 2622 0324 B989     	 ldrh r1,[r7,#12]
 2623 0326 7B68     	 ldr r3,[r7,#4]
 2624 0328 1033     	 adds r3,r3,#16
 2625 032a 0633     	 adds r3,r3,#6
 2626 032c FA7C     	 ldrb r2,[r7,#19]
 2627 032e 0846     	 mov r0,r1
 2628 0330 1146     	 mov r1,r2
 2629 0332 7A69     	 ldr r2,[r7,#20]
 2630 0334 FFF7FEFF 	 bl OBJ_GetDesc
 2631 0338 0346     	 mov r3,r0
 2632 033a 1033     	 adds r3,r3,#16
 2633 033c 7B84     	 strh r3,[r7,#34]
 2634              	.LBE17:
 2635 033e 02E0     	 b .L135
 2636              	.L139:
 2637 0340 01E0     	 b .L135
 2638              	.L136:
1314:../SSC/Src/sdoserv.c ****                             }
1315:../SSC/Src/sdoserv.c ****                         }
1316:../SSC/Src/sdoserv.c ****                     }
1317:../SSC/Src/sdoserv.c ****                     else
1318:../SSC/Src/sdoserv.c ****                     {
1319:../SSC/Src/sdoserv.c ****                         abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
 2639              	 .loc 1 1319 0
 2640 0342 1123     	 movs r3,#17
 2641 0344 FB73     	 strb r3,[r7,#15]
 2642              	.L135:
 2643              	.LBE16:
1320:../SSC/Src/sdoserv.c ****                     }
1321:../SSC/Src/sdoserv.c ****                 }
1322:../SSC/Src/sdoserv.c **** 
1323:../SSC/Src/sdoserv.c ****                 if ( abort == 0 )
 2644              	 .loc 1 1323 0
 2645 0346 FB7B     	 ldrb r3,[r7,#15]
 2646 0348 002B     	 cmp r3,#0
 2647 034a 18D1     	 bne .L141
1324:../SSC/Src/sdoserv.c ****                 {
1325:../SSC/Src/sdoserv.c ****                     {
1326:../SSC/Src/sdoserv.c ****                         /* for the object and entry description the sample code does not support th
1327:../SSC/Src/sdoserv.c ****                         the mailbox has to be big enough */
1328:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
 2648              	 .loc 1 1328 0
 2649 034c 7B68     	 ldr r3,[r7,#4]
 2650 034e 0022     	 movs r2,#0
 2651 0350 5A81     	 strh r2,[r3,#10]
1329:../SSC/Src/sdoserv.c ****                         /* store the size of the mailbox data in the mailbox buffer */
1330:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->MbxHeader.Length = size;
 2652              	 .loc 1 1330 0
 2653 0352 7B68     	 ldr r3,[r7,#4]
 2654 0354 7A8C     	 ldrh r2,[r7,#34]
 2655 0356 1A80     	 strh r2,[r3]
1331:../SSC/Src/sdoserv.c ****                         /* set the opCode of the SDO Information response */
1332:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
 2656              	 .loc 1 1332 0
 2657 0358 7B68     	 ldr r3,[r7,#4]
 2658 035a 1B89     	 ldrh r3,[r3,#8]
 2659 035c 23F07F03 	 bic r3,r3,#127
 2660 0360 9AB2     	 uxth r2,r3
 2661 0362 7B68     	 ldr r3,[r7,#4]
 2662 0364 1A81     	 strh r2,[r3,#8]
1333:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE
 2663              	 .loc 1 1333 0
 2664 0366 7B68     	 ldr r3,[r7,#4]
 2665 0368 1A89     	 ldrh r2,[r3,#8]
 2666 036a 97F82130 	 ldrb r3,[r7,#33]
 2667 036e 9BB2     	 uxth r3,r3
 2668 0370 0133     	 adds r3,r3,#1
 2669 0372 9BB2     	 uxth r3,r3
 2670 0374 1343     	 orrs r3,r3,r2
 2671 0376 9AB2     	 uxth r2,r3
 2672 0378 7B68     	 ldr r3,[r7,#4]
 2673 037a 1A81     	 strh r2,[r3,#8]
 2674              	.LBE15:
 2675 037c 03E0     	 b .L130
 2676              	.L141:
 2677 037e 02E0     	 b .L130
 2678              	.L131:
1334:../SSC/Src/sdoserv.c ****                     }
1335:../SSC/Src/sdoserv.c ****                 }
1336:../SSC/Src/sdoserv.c ****             }
1337:../SSC/Src/sdoserv.c ****             else
1338:../SSC/Src/sdoserv.c ****             {
1339:../SSC/Src/sdoserv.c ****                 abort = ABORTIDX_OBJECT_NOT_EXISTING;
 2679              	 .loc 1 1339 0
 2680 0380 0823     	 movs r3,#8
 2681 0382 FB73     	 strb r3,[r7,#15]
1340:../SSC/Src/sdoserv.c ****             }
1341:../SSC/Src/sdoserv.c ****         }
1342:../SSC/Src/sdoserv.c ****         break;
 2682              	 .loc 1 1342 0
 2683 0384 02E0     	 b .L128
 2684              	.L130:
 2685              	 .loc 1 1342 0 is_stmt 0 discriminator 1
 2686 0386 01E0     	 b .L128
 2687              	.L145:
1343:../SSC/Src/sdoserv.c ****     default:
1344:../SSC/Src/sdoserv.c ****         abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 2688              	 .loc 1 1344 0 is_stmt 1
 2689 0388 0323     	 movs r3,#3
 2690 038a FB73     	 strb r3,[r7,#15]
 2691              	.L128:
1345:../SSC/Src/sdoserv.c ****     }
1346:../SSC/Src/sdoserv.c **** 
1347:../SSC/Src/sdoserv.c ****     if ( abort )
 2692              	 .loc 1 1347 0
 2693 038c FB7B     	 ldrb r3,[r7,#15]
 2694 038e 002B     	 cmp r3,#0
 2695 0390 1DD0     	 beq .L142
1348:../SSC/Src/sdoserv.c ****     {
1349:../SSC/Src/sdoserv.c ****         /* send a SDO Information Error response */
1350:../SSC/Src/sdoserv.c ****         pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
 2696              	 .loc 1 1350 0
 2697 0392 7B68     	 ldr r3,[r7,#4]
 2698 0394 0A22     	 movs r2,#10
 2699 0396 1A80     	 strh r2,[r3]
1351:../SSC/Src/sdoserv.c **** 
1352:../SSC/Src/sdoserv.c ****         pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
 2700              	 .loc 1 1352 0
 2701 0398 7B68     	 ldr r3,[r7,#4]
 2702 039a 1B89     	 ldrh r3,[r3,#8]
 2703 039c 23F07F03 	 bic r3,r3,#127
 2704 03a0 9AB2     	 uxth r2,r3
 2705 03a2 7B68     	 ldr r3,[r7,#4]
 2706 03a4 1A81     	 strh r2,[r3,#8]
1353:../SSC/Src/sdoserv.c ****         pSdoInfoInd->SdoHeader.InfoHead |= (UINT16) ((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SH
 2707              	 .loc 1 1353 0
 2708 03a6 7B68     	 ldr r3,[r7,#4]
 2709 03a8 1B89     	 ldrh r3,[r3,#8]
 2710 03aa 43F00703 	 orr r3,r3,#7
 2711 03ae 9AB2     	 uxth r2,r3
 2712 03b0 7B68     	 ldr r3,[r7,#4]
 2713 03b2 1A81     	 strh r2,[r3,#8]
1354:../SSC/Src/sdoserv.c **** 
1355:../SSC/Src/sdoserv.c ****         pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
 2714              	 .loc 1 1355 0
 2715 03b4 7B68     	 ldr r3,[r7,#4]
 2716 03b6 0022     	 movs r2,#0
 2717 03b8 5A81     	 strh r2,[r3,#10]
1356:../SSC/Src/sdoserv.c ****         pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
 2718              	 .loc 1 1356 0
 2719 03ba FB7B     	 ldrb r3,[r7,#15]
 2720 03bc 1A46     	 mov r2,r3
 2721 03be 0C4B     	 ldr r3,.L148
 2722 03c0 53F82220 	 ldr r2,[r3,r2,lsl#2]
 2723 03c4 7B68     	 ldr r3,[r7,#4]
 2724 03c6 DA60     	 str r2,[r3,#12]
1357:../SSC/Src/sdoserv.c **** 
1358:../SSC/Src/sdoserv.c ****         nSdoInfoFragmentsLeft = 0;
 2725              	 .loc 1 1358 0
 2726 03c8 0A4B     	 ldr r3,.L148+4
 2727 03ca 0022     	 movs r2,#0
 2728 03cc 1A80     	 strh r2,[r3]
 2729              	.L142:
1359:../SSC/Src/sdoserv.c ****     }
1360:../SSC/Src/sdoserv.c **** 
1361:../SSC/Src/sdoserv.c ****     if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
 2730              	 .loc 1 1361 0
 2731 03ce 97F82F30 	 ldrb r3,[r7,#47]
 2732 03d2 7868     	 ldr r0,[r7,#4]
 2733 03d4 1946     	 mov r1,r3
 2734 03d6 FFF7FEFF 	 bl MBX_MailboxSendReq
 2735 03da 0346     	 mov r3,r0
 2736 03dc 002B     	 cmp r3,#0
 2737 03de 02D0     	 beq .L143
1362:../SSC/Src/sdoserv.c ****     {
1363:../SSC/Src/sdoserv.c ****         /* if the mailbox response could not be sent (or stored), the response will be
1364:../SSC/Src/sdoserv.c ****            stored in the variable pCoeSendStored and will be sent automatically
1365:../SSC/Src/sdoserv.c ****             from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
1366:../SSC/Src/sdoserv.c ****             the next time from the master */
1367:../SSC/Src/sdoserv.c ****         pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
 2738              	 .loc 1 1367 0
 2739 03e0 054A     	 ldr r2,.L148+8
 2740 03e2 7B68     	 ldr r3,[r7,#4]
 2741 03e4 1360     	 str r3,[r2]
 2742              	.L143:
1368:../SSC/Src/sdoserv.c ****     }
1369:../SSC/Src/sdoserv.c **** 
1370:../SSC/Src/sdoserv.c ****     return 0;
 2743              	 .loc 1 1370 0
 2744 03e6 0023     	 movs r3,#0
 2745              	.L144:
1371:../SSC/Src/sdoserv.c **** }
 2746              	 .loc 1 1371 0 discriminator 2
 2747 03e8 1846     	 mov r0,r3
 2748 03ea 3437     	 adds r7,r7,#52
 2749              	.LCFI30:
 2750              	 .cfi_def_cfa_offset 12
 2751 03ec BD46     	 mov sp,r7
 2752              	.LCFI31:
 2753              	 .cfi_def_cfa_register 13
 2754              	 
 2755 03ee 90BD     	 pop {r4,r7,pc}
 2756              	.L149:
 2757              	 .align 2
 2758              	.L148:
 2759 03f0 00000000 	 .word cAbortCode
 2760 03f4 00000000 	 .word nSdoInfoFragmentsLeft
 2761 03f8 00000000 	 .word pCoeSendStored
 2762              	 .cfi_endproc
 2763              	.LFE185:
 2765              	 .text
 2766              	.Letext0:
 2767              	 .file 2 "c:\\tools\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2768              	 .file 3 "c:\\tools\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2769              	 .file 4 "../SSC/Src/mailbox.h"
 2770              	 .file 5 "../SSC/Src/ecatcoe.h"
 2771              	 .file 6 "../SSC/Src/sdoserv.h"
 2772              	 .file 7 "../SSC/Src/objdef.h"
 2773              	 .file 8 "C:/Users/Admin/DaveWorkspaces/XMC4300_PWMTest/Libraries/CMSIS/Include/cmsis_gcc.h"
 2774              	 .file 9 "C:/Users/Admin/DaveWorkspaces/XMC4300_PWMTest/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 sdoserv.c
                            *COM*:00000001 u8PendingSdo
                            *COM*:00000001 bStoreCompleteAccess
                            *COM*:00000001 u8StoreSubindex
                            *COM*:00000002 u16StoreIndex
                            *COM*:00000004 u32StoreDataSize
                            *COM*:00000004 pStoreData
                            *COM*:00000004 pSdoPendFunc
                            *COM*:00000010 aSdoInfoHeader
                            *COM*:00000004 pSdoSegData
                            *COM*:00000002 nSdoInfoFragmentsLeft
    {standard input}:34     .rodata.cAbortCode:00000000 cAbortCode
    {standard input}:31     .rodata.cAbortCode:00000000 $d
                            *COM*:00000002 nSdoInfoIndex
                            *COM*:00000004 pSdoInfoObjEntry
                            *COM*:00000004 pSdoResStored
    {standard input}:72     .bss.bSdoInWork:00000000 bSdoInWork
    {standard input}:73     .bss.bSdoInWork:00000000 $d
                            *COM*:00000001 nSdoSegService
                            *COM*:00000001 bSdoSegFollows
                            *COM*:00000001 bSdoSegAccess
                            *COM*:00000002 nSdoSegIndex
                            *COM*:00000001 nSdoSegSubindex
                            *COM*:00000004 nSdoSegBytesToHandle
                            *COM*:00000001 bSdoSegLastToggle
                            *COM*:00000004 nSdoSegCompleteSize
                            *COM*:00000004 pSdoSegObjEntry
    {standard input}:84     .text.SdoDownloadSegmentInd:00000000 $t
    {standard input}:88     .text.SdoDownloadSegmentInd:00000000 SdoDownloadSegmentInd
    {standard input}:467    .text.SdoDownloadSegmentInd:00000234 $d
    {standard input}:491    .text.SdoUploadSegmentInd:00000000 $t
    {standard input}:495    .text.SdoUploadSegmentInd:00000000 SdoUploadSegmentInd
    {standard input}:715    .text.SdoUploadSegmentInd:0000014c $d
    {standard input}:726    .text.SdoRes:00000000 $t
    {standard input}:731    .text.SdoRes:00000000 SdoRes
    {standard input}:963    .text.SdoRes:00000168 $d
    {standard input}:969    .text.SDOS_SdoInd:00000000 $t
    {standard input}:974    .text.SDOS_SdoInd:00000000 SDOS_SdoInd
    {standard input}:1418   .text.SDOS_SdoInd:000002e8 $d
    {standard input}:1432   .text.SDOS_SdoInd:00000318 $t
    {standard input}:1805   .text.SDOS_SdoInd:00000594 $d
    {standard input}:1824   .text.SDOS_SdoRes:00000000 $t
    {standard input}:1829   .text.SDOS_SdoRes:00000000 SDOS_SdoRes
    {standard input}:2001   .text.SDOS_SdoRes:000000fc $d
    {standard input}:2015   .text.SODS_ClearPendingResponse:00000000 $t
    {standard input}:2020   .text.SODS_ClearPendingResponse:00000000 SODS_ClearPendingResponse
    {standard input}:2128   .text.SODS_ClearPendingResponse:00000094 $d
    {standard input}:2146   .text.SDOS_SdoInfoInd:00000000 $t
    {standard input}:2151   .text.SDOS_SdoInfoInd:00000000 SDOS_SdoInfoInd
    {standard input}:2615   .text.SDOS_SdoInfoInd:00000310 $d
    {standard input}:2622   .text.SDOS_SdoInfoInd:00000324 $t
    {standard input}:2759   .text.SDOS_SdoInfoInd:000003f0 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memcpy
OBJ_Write
free
u16ReceiveMbxSize
u16SendMbxSize
MBX_MailboxSendReq
pCoeSendStored
OBJ_GetObjectHandle
OBJ_GetObjectLength
malloc
OBJ_Read
psRepeatMbx
psStoreMbx
OBJ_GetNoOfObjects
OBJ_GetObjectList
OBJ_GetObjDesc
OBJ_GetDesc
OBJ_GetEntryDesc
aSubindexDesc
