   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "objdef.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm bSyncSetByUser,1,1
  20              	 .comm sCycleDiag,2,4
  21              	 .comm sSyncManOutPar,68,4
  22              	 .comm sSyncManInPar,68,4
  23              	 .global sErrorSettings
  24              	 .section .data.sErrorSettings,"aw",%progbits
  25              	 .align 2
  28              	sErrorSettings:
  29 0000 0200     	 .short 2
  30 0002 0000     	 .space 2
  31 0004 01000000 	 .word 1
  32 0008 0400     	 .short 4
  33 000a 0000     	 .space 2
  34              	 .global aSubindexDesc
  35              	 .section .data.aSubindexDesc,"aw",%progbits
  36              	 .align 2
  39              	aSubindexDesc:
  40 0000 53756249 	 .ascii "SubIndex 000\000"
  40      6E646578 
  40      20303030 
  40      00
  41              	 .global cBitMask
  42 000d 000000   	 .section .rodata.cBitMask,"a",%progbits
  43              	 .align 2
  46              	cBitMask:
  47 0000 0000     	 .short 0
  48 0002 0100     	 .short 1
  49 0004 0300     	 .short 3
  50 0006 0700     	 .short 7
  51 0008 0F00     	 .short 15
  52 000a 1F00     	 .short 31
  53 000c 3F00     	 .short 63
  54 000e 7F00     	 .short 127
  55 0010 FF00     	 .short 255
  56 0012 FF01     	 .short 511
  57 0014 FF03     	 .short 1023
  58 0016 FF07     	 .short 2047
  59 0018 FF0F     	 .short 4095
  60 001a FF1F     	 .short 8191
  61 001c FF3F     	 .short 16383
  62 001e FF7F     	 .short 32767
  63              	 .section .text.OBJ_GetObjectHandle,"ax",%progbits
  64              	 .align 2
  65              	 .global OBJ_GetObjectHandle
  66              	 .thumb
  67              	 .thumb_func
  69              	OBJ_GetObjectHandle:
  70              	.LFB179:
  71              	 .file 1 "../SSC/Src/objdef.c"
   1:../SSC/Src/objdef.c **** /*
   2:../SSC/Src/objdef.c **** * This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & 
   3:../SSC/Src/objdef.c **** * The corresponding license agreement applies. This hint shall not be removed.
   4:../SSC/Src/objdef.c **** */
   5:../SSC/Src/objdef.c **** 
   6:../SSC/Src/objdef.c **** /**
   7:../SSC/Src/objdef.c **** \addtogroup CoE CAN Application Profile over EtherCAT
   8:../SSC/Src/objdef.c **** @{
   9:../SSC/Src/objdef.c **** */
  10:../SSC/Src/objdef.c **** 
  11:../SSC/Src/objdef.c **** /**
  12:../SSC/Src/objdef.c **** \file objdef.c
  13:../SSC/Src/objdef.c **** \author EthercatSSC@beckhoff.com
  14:../SSC/Src/objdef.c **** \brief Implementation
  15:../SSC/Src/objdef.c **** This file contains the object dictionary access functions
  16:../SSC/Src/objdef.c **** 
  17:../SSC/Src/objdef.c **** \version 5.12
  18:../SSC/Src/objdef.c **** 
  19:../SSC/Src/objdef.c **** <br>Changes to version V5.11:<br>
  20:../SSC/Src/objdef.c **** V5.12 COE10: update object entry string handling<br>
  21:../SSC/Src/objdef.c **** V5.12 COE3: update entry access right handling<br>
  22:../SSC/Src/objdef.c **** V5.12 COE6: handle get object length in case of an out of range subindex<br>
  23:../SSC/Src/objdef.c **** V5.12 COE7: in case of a padding entry SDO upload/download return Unsupported access<br>
  24:../SSC/Src/objdef.c **** V5.12 COE9: SDO download 0xF030.0 shall be 0 before writing entries 1..n<br>
  25:../SSC/Src/objdef.c **** V5.12 ECAT1: update SM Parameter measurement (based on the system time), enhancement for input only
  26:../SSC/Src/objdef.c **** V5.12 ECAT5: update Sync error counter/flag handling,check enum memory alignment depending on the p
  27:../SSC/Src/objdef.c **** <br>Changes to version V5.10.1:<br>
  28:../SSC/Src/objdef.c **** V5.11 DIAG4: change parameter handling in DIAG_CreateNewMessage()<br>
  29:../SSC/Src/objdef.c **** V5.11 ECAT: <br>
  30:../SSC/Src/objdef.c **** V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
  31:../SSC/Src/objdef.c **** V5.11 ESM7: "add Sync define for 0x22 (""SYNCTYPE_SM2_SYNCHRON""), support value 0x22 for 0x1C33.1 
  32:../SSC/Src/objdef.c **** V5.11 OBJ1: OBJ_GetEntryOffset: return offset 0 for si0 (always offset 16 was returned before)<br>
  33:../SSC/Src/objdef.c **** V5.11 SDO1: "Obj_Read/Obj_Write: Check if entries > 8bit has even word offset (otherwise ""unsuppor
  34:../SSC/Src/objdef.c **** V5.11 SDO2: Obj_Read/Obj_Write: Handle arrays (string, array of byte, ...) with an odd word length 
  35:../SSC/Src/objdef.c **** V5.11 SDO3: handle not word aligned enums<br>
  36:../SSC/Src/objdef.c **** V5.11 SDO5: add missing swapping on SI0 write access<br>
  37:../SSC/Src/objdef.c **** V5.11 SDO6: OBJ_GetDesc ensure that the default string is used if no string was found<br>
  38:../SSC/Src/objdef.c **** V5.11 SDO7: add missing value swapping if memory values are bitwise modified on object read/write a
  39:../SSC/Src/objdef.c **** V5.11 SDO9: "handle SDO access for entries which are not accessible (in case of SDO complete access
  40:../SSC/Src/objdef.c **** V5.11 TEST2: add test 0x300C object (entry bitlength > 65535)<br>
  41:../SSC/Src/objdef.c **** V5.11 TEST8: create diag message on SDO write access to 0x3002<br>
  42:../SSC/Src/objdef.c **** <br>Changes to version V5.01:<br>
  43:../SSC/Src/objdef.c **** V5.10 COE2: Change return value of Get ObjectSize to UINT32<br>
  44:../SSC/Src/objdef.c ****             Change object size to UINT32<br>
  45:../SSC/Src/objdef.c **** V5.10 ECAT11: Add define "USE_SINGLE_PDO_MAPPING_ENTRY_DESCR" (Only one entry description is requir
  46:../SSC/Src/objdef.c **** V5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
  47:../SSC/Src/objdef.c ****               Compare DC UINT configuration (by ESC Config data) vs. DC activation register setting
  48:../SSC/Src/objdef.c ****               Update 0x1C3x entries<br>
  49:../SSC/Src/objdef.c **** V5.10 ECAT3: Add new datatype handling (BITARRxx)<br>
  50:../SSC/Src/objdef.c ****              Use read/write marco to access STRING entries<br>
  51:../SSC/Src/objdef.c **** V5.10 SDO1: Handle access to enums on odd memory addresses (only for MBX_16BIT_ACCESS)<br>
  52:../SSC/Src/objdef.c **** V5.10 SDO2: Check for termination char in every substring<br>
  53:../SSC/Src/objdef.c **** V5.10 SDO5: Check also for PDO mapping object if the subindex 0 was set to 0 before the entries wil
  54:../SSC/Src/objdef.c **** V5.10 SDO9: SDO complete write access update buffer offset calculation in case of SI0 is readonly<b
  55:../SSC/Src/objdef.c **** V5.10 TEST2: Add 0x3004.14 (Access to this entry will always rejected with the code "cannot be acce
  56:../SSC/Src/objdef.c **** V5.10 TEST4: Add CoE test (0x2020.5) to return always max object data on complete access (not limit
  57:../SSC/Src/objdef.c **** <br>Changes to version V5.0:<br>
  58:../SSC/Src/objdef.c **** V5.01 COE2: Calculate the bit offset also for SI0 in case if an SDO download access.<br>
  59:../SSC/Src/objdef.c **** V5.01 SDO1: Update alignment entry handling.<br>
  60:../SSC/Src/objdef.c **** V5.01 SDO5: Update offset calculation in case of an not accessible entry<br>
  61:../SSC/Src/objdef.c **** V5.01 SDO7: Update object length calculation in case of an BitArray<br>
  62:../SSC/Src/objdef.c **** V5.01 TEST5: Add slave configuration object handling (0x8000, if test application is active)<br>
  63:../SSC/Src/objdef.c **** V5.01 TEST6: Add test to create dummy object dictionary.<br>
  64:../SSC/Src/objdef.c **** <br>Changes to version V4.40:<br>
  65:../SSC/Src/objdef.c **** V5.0 TEST1: Add test application.<br>
  66:../SSC/Src/objdef.c **** V5.0 COE3: Update OCTED_STRING and VISIBLE_STRING read/write.<br>
  67:../SSC/Src/objdef.c **** V5.0 COE5: Add BigEndian support for enum SDO read, handle complete access also for objects with al
  68:../SSC/Src/objdef.c **** V5.0 COE7: Support SDO Info entry name handling for 16Bit access<br>
  69:../SSC/Src/objdef.c **** V5.0 DIAG2: SDO Info request for diagnosis messages 0x10F3 SI5 or greater return always description
  70:../SSC/Src/objdef.c **** V5.0 COE2: Add plausibility check for PDO assign objects.<br>
  71:../SSC/Src/objdef.c **** V5.0 OBJ2: Support DWORD/WORD aligned object structures.<br>
  72:../SSC/Src/objdef.c **** V5.0 SDO7: Update SDO read/write for object(entries) less or equal 8Bit.<br>
  73:../SSC/Src/objdef.c **** <br>Changes to version V4.30:<br>
  74:../SSC/Src/objdef.c **** V4.40 DIAG1: Add diagnosis access functions<br>
  75:../SSC/Src/objdef.c **** V4.40 OBJ2: change counter variable to prevent deadlock caused by overrun (required if subindex0 is
  76:../SSC/Src/objdef.c **** V4.40 COE2: Prevent accessing empty object dictionary entry<br>
  77:../SSC/Src/objdef.c **** V4.40 COE3: Read whole object dictionary<br>
  78:../SSC/Src/objdef.c **** V4.40 COE1: Prototype of OBJ_GetObjectList() changed, set abort code if object dictionary is empty<
  79:../SSC/Src/objdef.c **** V4.30 OBJ 3: Object dictionary list handling<br>
  80:../SSC/Src/objdef.c **** V4.30 OBJ 2: fix SDO complete access bug<br>
  81:../SSC/Src/objdef.c **** V4.11 OBJ 1-3: OBJ_GetDesc() Now, subindex 0 instead of 0xFF is used to return the description of t
  82:../SSC/Src/objdef.c **** Subindex 0xFF could be used like a normal subindex.<br>
  83:../SSC/Src/objdef.c **** <br>Changes to version V4.08:<br>
  84:../SSC/Src/objdef.c **** V4.10 OBJ 1: calculate size of PdoObjectEntry Index 1 and not Index 0<br>
  85:../SSC/Src/objdef.c **** V4.10 OBJ 2: the pointer of the object dictionary will be get by a function (COE_GetObjectDictionar
  86:../SSC/Src/objdef.c **** <br>Changes to version V4.07:<br>
  87:../SSC/Src/objdef.c **** V4.08 OBJ 1: if subindex 0 is writable, the maximum subindex should be checked in an object specifi
  88:../SSC/Src/objdef.c ****              because for the PDO mapping and PDO assign the object shall only be written if subinde
  89:../SSC/Src/objdef.c **** <br>Changes to version V4.04:<br>
  90:../SSC/Src/objdef.c **** V4.04 OBJ 1: The loop in OBJ_GetObjectList was one subindex too low<br>
  91:../SSC/Src/objdef.c **** <br>Changes to version V4.03:<br>
  92:../SSC/Src/objdef.c **** V4.04 SDO 1: The SDO interface was changed in that way that a SDO response<br>
  93:../SSC/Src/objdef.c ****              could be sent by the application to a later time. In that case<br>
  94:../SSC/Src/objdef.c ****                  the functions OBJ_Read and OBJ_Write shall return the value<br>
  95:../SSC/Src/objdef.c ****                  ABORTIDX_WORKING. To send the SDO response the new function SDOS_SdoRes<br>
  96:../SSC/Src/objdef.c ****                  has to be called by the application. While waiting for the call<br>
  97:../SSC/Src/objdef.c ****                  of SDOS_SdoRes the SDO interface will answer to another SDO request<br>
  98:../SSC/Src/objdef.c ****                  with the error MBXERR_SERVICEINWORK in the mailbox protocol<br>
  99:../SSC/Src/objdef.c **** V4.04 OBJ 1: The loop in OBJ_GetNoOfObjects was one subindex too low<br>
 100:../SSC/Src/objdef.c **** <br>Changes to version V4.02:<br>
 101:../SSC/Src/objdef.c **** V4.03 OBJ 1: The object list was not returned correctly for the list types 2-5<br>
 102:../SSC/Src/objdef.c **** <br>Changes to version V3.20:<br>
 103:../SSC/Src/objdef.c **** V4.00 OBJ 1: The OBJ functions are modified for a more flexible definition of<br>
 104:../SSC/Src/objdef.c ****              the object dictionary and to support bit types too<br>
 105:../SSC/Src/objdef.c **** V4.00 SDO 2: The object lists will be generated in the functions OBJ_GetNoOfObjects<br>
 106:../SSC/Src/objdef.c ****              and OBJ_GetObjectList in objdef.c to decouple the SDO services from<br>
 107:../SSC/Src/objdef.c ****              the implementation of the object dictionary<br>
 108:../SSC/Src/objdef.c **** V4.00 COEAPPL 2: The handling of backup parameters was included according to<br>
 109:../SSC/Src/objdef.c ****                  the EtherCAT Guidelines and Protocol Enhancements Specification
 110:../SSC/Src/objdef.c **** 
 111:../SSC/Src/objdef.c **** */
 112:../SSC/Src/objdef.c **** 
 113:../SSC/Src/objdef.c **** 
 114:../SSC/Src/objdef.c **** #define    OBJDEF        0x4000
 115:../SSC/Src/objdef.c **** #define    OBJDEFMAX    0x0A
 116:../SSC/Src/objdef.c **** 
 117:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 118:../SSC/Src/objdef.c **** ------
 119:../SSC/Src/objdef.c **** ------    Includes
 120:../SSC/Src/objdef.c **** ------
 121:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 122:../SSC/Src/objdef.c **** 
 123:../SSC/Src/objdef.c **** #include "ecat_def.h"
 124:../SSC/Src/objdef.c **** 
 125:../SSC/Src/objdef.c **** 
 126:../SSC/Src/objdef.c **** #include "ecatslv.h"
 127:../SSC/Src/objdef.c **** #include "coeappl.h"
 128:../SSC/Src/objdef.c **** 
 129:../SSC/Src/objdef.c **** 
 130:../SSC/Src/objdef.c **** #define  _OBJDEF_    1
 131:../SSC/Src/objdef.c **** #include "objdef.h"
 132:../SSC/Src/objdef.c **** #undef    _OBJDEF_
 133:../SSC/Src/objdef.c **** /*remove definition of _OBJDEF_ (#ifdef is used in objdef.h)*/
 134:../SSC/Src/objdef.c **** 
 135:../SSC/Src/objdef.c **** 
 136:../SSC/Src/objdef.c **** 
 137:../SSC/Src/objdef.c **** 
 138:../SSC/Src/objdef.c **** 
 139:../SSC/Src/objdef.c **** 
 140:../SSC/Src/objdef.c **** extern OBJCONST TOBJECT OBJMEM *pSdoInfoObjEntry;
 141:../SSC/Src/objdef.c **** extern OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UI
 142:../SSC/Src/objdef.c **** 
 143:../SSC/Src/objdef.c **** //---------------------------------------------------------------------------------------
 144:../SSC/Src/objdef.c **** 
 145:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 146:../SSC/Src/objdef.c **** ------
 147:../SSC/Src/objdef.c **** ------    Internal types and defines
 148:../SSC/Src/objdef.c **** ------
 149:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 150:../SSC/Src/objdef.c **** 
 151:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 152:../SSC/Src/objdef.c **** ------
 153:../SSC/Src/objdef.c **** ------    module internal function declarations
 154:../SSC/Src/objdef.c **** ------
 155:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 156:../SSC/Src/objdef.c **** 
 157:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 158:../SSC/Src/objdef.c **** ------
 159:../SSC/Src/objdef.c **** ------    Module internal variable definitions
 160:../SSC/Src/objdef.c **** ------
 161:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 162:../SSC/Src/objdef.c **** const UINT16 cBitMask[16] = {0x0000,0x0001,0x0003,0x0007,0x000F,0x001F,0x003F,0x007F,0x00FF,0x01FF,
 163:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 164:../SSC/Src/objdef.c **** ------
 165:../SSC/Src/objdef.c **** ------    Functions
 166:../SSC/Src/objdef.c **** ------
 167:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 168:../SSC/Src/objdef.c **** 
 169:../SSC/Src/objdef.c **** 
 170:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 171:../SSC/Src/objdef.c **** /**
 172:../SSC/Src/objdef.c ****  \param     index     Indicates the index of the dictionary object.
 173:../SSC/Src/objdef.c **** 
 174:../SSC/Src/objdef.c ****  \return    A handle to an object of the requested index or NULL if not found.
 175:../SSC/Src/objdef.c **** 
 176:../SSC/Src/objdef.c ****  \brief    The function looks in all objects of the dictionary after the indicated index
 177:../SSC/Src/objdef.c ****              and returns a handle if found.
 178:../SSC/Src/objdef.c **** 
 179:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 180:../SSC/Src/objdef.c **** 
 181:../SSC/Src/objdef.c **** OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
 182:../SSC/Src/objdef.c **** {
  72              	 .loc 1 182 0
  73              	 .cfi_startproc
  74              	 
  75              	 
  76 0000 80B5     	 push {r7,lr}
  77              	.LCFI0:
  78              	 .cfi_def_cfa_offset 8
  79              	 .cfi_offset 7,-8
  80              	 .cfi_offset 14,-4
  81 0002 84B0     	 sub sp,sp,#16
  82              	.LCFI1:
  83              	 .cfi_def_cfa_offset 24
  84 0004 00AF     	 add r7,sp,#0
  85              	.LCFI2:
  86              	 .cfi_def_cfa_register 7
  87 0006 0346     	 mov r3,r0
  88 0008 FB80     	 strh r3,[r7,#6]
 183:../SSC/Src/objdef.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
  89              	 .loc 1 183 0
  90 000a FFF7FEFF 	 bl COE_GetObjectDictionary
  91 000e F860     	 str r0,[r7,#12]
 184:../SSC/Src/objdef.c **** 
 185:../SSC/Src/objdef.c ****     while (pObjEntry!= NULL)
  92              	 .loc 1 185 0
  93 0010 09E0     	 b .L2
  94              	.L5:
 186:../SSC/Src/objdef.c ****     {
 187:../SSC/Src/objdef.c ****         
 188:../SSC/Src/objdef.c ****         if (pObjEntry->Index == index)
  95              	 .loc 1 188 0
  96 0012 FB68     	 ldr r3,[r7,#12]
  97 0014 1B89     	 ldrh r3,[r3,#8]
  98 0016 FA88     	 ldrh r2,[r7,#6]
  99 0018 9A42     	 cmp r2,r3
 100 001a 01D1     	 bne .L3
 189:../SSC/Src/objdef.c ****         {
 190:../SSC/Src/objdef.c ****             return pObjEntry;
 101              	 .loc 1 190 0
 102 001c FB68     	 ldr r3,[r7,#12]
 103 001e 06E0     	 b .L4
 104              	.L3:
 191:../SSC/Src/objdef.c ****         }
 192:../SSC/Src/objdef.c ****         pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 105              	 .loc 1 192 0
 106 0020 FB68     	 ldr r3,[r7,#12]
 107 0022 5B68     	 ldr r3,[r3,#4]
 108 0024 FB60     	 str r3,[r7,#12]
 109              	.L2:
 185:../SSC/Src/objdef.c ****     {
 110              	 .loc 1 185 0
 111 0026 FB68     	 ldr r3,[r7,#12]
 112 0028 002B     	 cmp r3,#0
 113 002a F2D1     	 bne .L5
 193:../SSC/Src/objdef.c ****     }
 194:../SSC/Src/objdef.c ****     return 0;
 114              	 .loc 1 194 0
 115 002c 0023     	 movs r3,#0
 116              	.L4:
 195:../SSC/Src/objdef.c **** }
 117              	 .loc 1 195 0
 118 002e 1846     	 mov r0,r3
 119 0030 1037     	 adds r7,r7,#16
 120              	.LCFI3:
 121              	 .cfi_def_cfa_offset 8
 122 0032 BD46     	 mov sp,r7
 123              	.LCFI4:
 124              	 .cfi_def_cfa_register 13
 125              	 
 126 0034 80BD     	 pop {r7,pc}
 127              	 .cfi_endproc
 128              	.LFE179:
 130 0036 00BF     	 .section .text.OBJ_GetObjectLength,"ax",%progbits
 131              	 .align 2
 132              	 .global OBJ_GetObjectLength
 133              	 .thumb
 134              	 .thumb_func
 136              	OBJ_GetObjectLength:
 137              	.LFB180:
 196:../SSC/Src/objdef.c **** 
 197:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 198:../SSC/Src/objdef.c **** /**
 199:../SSC/Src/objdef.c ****  \param     index           Index of the requested object.
 200:../SSC/Src/objdef.c ****  \param     subindex        Subindex of the requested object.
 201:../SSC/Src/objdef.c ****  \param     pObjEntry       Handle to the dictionary object returned by
 202:../SSC/Src/objdef.c ****                             OBJ_GetObjectHandle which was called before
 203:../SSC/Src/objdef.c ****  \param     bCompleteAccess Indicates if a complete read of all subindices of the
 204:../SSC/Src/objdef.c ****                             object shall be done or not
 205:../SSC/Src/objdef.c **** 
 206:../SSC/Src/objdef.c ****  \return    The size of the object entry in bytes (!).
 207:../SSC/Src/objdef.c **** 
 208:../SSC/Src/objdef.c ****  \brief     This function returns the size of the requested entry. If bCompleteaccess is set the si
 209:../SSC/Src/objdef.c **** 
 210:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 211:../SSC/Src/objdef.c **** UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT
 212:../SSC/Src/objdef.c **** {
 138              	 .loc 1 212 0
 139              	 .cfi_startproc
 140              	 
 141              	 
 142              	 
 143 0000 80B4     	 push {r7}
 144              	.LCFI5:
 145              	 .cfi_def_cfa_offset 4
 146              	 .cfi_offset 7,-4
 147 0002 85B0     	 sub sp,sp,#20
 148              	.LCFI6:
 149              	 .cfi_def_cfa_offset 24
 150 0004 00AF     	 add r7,sp,#0
 151              	.LCFI7:
 152              	 .cfi_def_cfa_register 7
 153 0006 3A60     	 str r2,[r7]
 154 0008 1A46     	 mov r2,r3
 155 000a 0346     	 mov r3,r0
 156 000c FB80     	 strh r3,[r7,#6]
 157 000e 0B46     	 mov r3,r1
 158 0010 7B71     	 strb r3,[r7,#5]
 159 0012 1346     	 mov r3,r2
 160 0014 3B71     	 strb r3,[r7,#4]
 213:../SSC/Src/objdef.c ****     /* get the information of ObjCode and MaxSubindex in local variables to support different types
 214:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 161              	 .loc 1 214 0
 162 0016 3B68     	 ldr r3,[r7]
 163 0018 9B89     	 ldrh r3,[r3,#12]
 164 001a 03F47063 	 and r3,r3,#3840
 165 001e 1B12     	 asrs r3,r3,#8
 166 0020 BB72     	 strb r3,[r7,#10]
 215:../SSC/Src/objdef.c ****     
 216:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.12) COE6*/
 217:../SSC/Src/objdef.c ****     UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUB
 167              	 .loc 1 217 0
 168 0022 3B68     	 ldr r3,[r7]
 169 0024 9B89     	 ldrh r3,[r3,#12]
 170 0026 7B72     	 strb r3,[r7,#9]
 218:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.12) COE6*/
 219:../SSC/Src/objdef.c ****     UINT32 size = 0;
 171              	 .loc 1 219 0
 172 0028 0023     	 movs r3,#0
 173 002a FB60     	 str r3,[r7,#12]
 220:../SSC/Src/objdef.c **** 
 221:../SSC/Src/objdef.c ****     if ( bCompleteAccess )
 174              	 .loc 1 221 0
 175 002c 3B79     	 ldrb r3,[r7,#4]
 176 002e 002B     	 cmp r3,#0
 177 0030 43D0     	 beq .L7
 222:../SSC/Src/objdef.c ****     {
 223:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR )
 178              	 .loc 1 223 0
 179 0032 BB7A     	 ldrb r3,[r7,#10]
 180 0034 072B     	 cmp r3,#7
 181 0036 01D1     	 bne .L8
 224:../SSC/Src/objdef.c ****         {
 225:../SSC/Src/objdef.c ****             return 0;
 182              	 .loc 1 225 0
 183 0038 0023     	 movs r3,#0
 184 003a 67E0     	 b .L9
 185              	.L8:
 226:../SSC/Src/objdef.c ****         }
 227:../SSC/Src/objdef.c ****         else if ((objCode == OBJCODE_ARR)
 186              	 .loc 1 227 0
 187 003c BB7A     	 ldrb r3,[r7,#10]
 188 003e 082B     	 cmp r3,#8
 189 0040 18D1     	 bne .L10
 228:../SSC/Src/objdef.c ****             )
 229:../SSC/Src/objdef.c ****         {
 230:../SSC/Src/objdef.c **** 
 231:../SSC/Src/objdef.c ****             /* we have to get the maxSubindex from the actual value of subindex 0,
 232:../SSC/Src/objdef.c ****                 which is stored as UINT16 at the beginning of the object's variable */
 233:../SSC/Src/objdef.c ****             maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
 190              	 .loc 1 233 0
 191 0042 3B68     	 ldr r3,[r7]
 192 0044 9B69     	 ldr r3,[r3,#24]
 193 0046 1B88     	 ldrh r3,[r3]
 194 0048 7B72     	 strb r3,[r7,#9]
 234:../SSC/Src/objdef.c **** 
 235:../SSC/Src/objdef.c **** 
 236:../SSC/Src/objdef.c ****             size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
 195              	 .loc 1 236 0
 196 004a 3B68     	 ldr r3,[r7]
 197 004c 1B69     	 ldr r3,[r3,#16]
 198 004e 0633     	 adds r3,r3,#6
 199 0050 5B88     	 ldrh r3,[r3,#2]
 200 0052 1A46     	 mov r2,r3
 201 0054 7B7A     	 ldrb r3,[r7,#9]
 202 0056 03FB02F3 	 mul r3,r3,r2
 203 005a FB60     	 str r3,[r7,#12]
 237:../SSC/Src/objdef.c **** 
 238:../SSC/Src/objdef.c **** /* no padding required: Bit entries within an array object may overlap byte borders*/
 239:../SSC/Src/objdef.c **** 
 240:../SSC/Src/objdef.c ****             /* we have to convert the size in bytes */
 241:../SSC/Src/objdef.c ****             size = BIT2BYTE(size);
 204              	 .loc 1 241 0
 205 005c FB68     	 ldr r3,[r7,#12]
 206 005e 0733     	 adds r3,r3,#7
 207 0060 DB08     	 lsrs r3,r3,#3
 208 0062 FB60     	 str r3,[r7,#12]
 242:../SSC/Src/objdef.c **** 
 243:../SSC/Src/objdef.c ****             if ( subindex == 0 )
 209              	 .loc 1 243 0
 210 0064 7B79     	 ldrb r3,[r7,#5]
 211 0066 002B     	 cmp r3,#0
 212 0068 02D1     	 bne .L11
 244:../SSC/Src/objdef.c ****             {
 245:../SSC/Src/objdef.c ****                 /* add size for subindex 0 (is transmitted as UINT16) */
 246:../SSC/Src/objdef.c ****                 size += 2;
 213              	 .loc 1 246 0
 214 006a FB68     	 ldr r3,[r7,#12]
 215 006c 0233     	 adds r3,r3,#2
 216 006e FB60     	 str r3,[r7,#12]
 217              	.L11:
 247:../SSC/Src/objdef.c ****             }
 248:../SSC/Src/objdef.c ****             return size;
 218              	 .loc 1 248 0
 219 0070 FB68     	 ldr r3,[r7,#12]
 220 0072 4BE0     	 b .L9
 221              	.L10:
 222              	.LBB2:
 249:../SSC/Src/objdef.c ****         }
 250:../SSC/Src/objdef.c ****         else
 251:../SSC/Src/objdef.c ****         {
 252:../SSC/Src/objdef.c ****             UINT8 i;
 253:../SSC/Src/objdef.c **** 
 254:../SSC/Src/objdef.c ****             /* add the sizes of all entries */
 255:../SSC/Src/objdef.c ****             for (i = 1; i <= maxSubindex; i++)
 223              	 .loc 1 255 0
 224 0074 0123     	 movs r3,#1
 225 0076 FB72     	 strb r3,[r7,#11]
 226 0078 0FE0     	 b .L12
 227              	.L13:
 256:../SSC/Src/objdef.c ****             {
 257:../SSC/Src/objdef.c ****                 size += pObjEntry->pEntryDesc[i].BitLength;
 228              	 .loc 1 257 0 discriminator 3
 229 007a 3B68     	 ldr r3,[r7]
 230 007c 1969     	 ldr r1,[r3,#16]
 231 007e FA7A     	 ldrb r2,[r7,#11]
 232 0080 1346     	 mov r3,r2
 233 0082 5B00     	 lsls r3,r3,#1
 234 0084 1344     	 add r3,r3,r2
 235 0086 5B00     	 lsls r3,r3,#1
 236 0088 0B44     	 add r3,r3,r1
 237 008a 5B88     	 ldrh r3,[r3,#2]
 238 008c 1A46     	 mov r2,r3
 239 008e FB68     	 ldr r3,[r7,#12]
 240 0090 1344     	 add r3,r3,r2
 241 0092 FB60     	 str r3,[r7,#12]
 255:../SSC/Src/objdef.c ****             {
 242              	 .loc 1 255 0 discriminator 3
 243 0094 FB7A     	 ldrb r3,[r7,#11]
 244 0096 0133     	 adds r3,r3,#1
 245 0098 FB72     	 strb r3,[r7,#11]
 246              	.L12:
 255:../SSC/Src/objdef.c ****             {
 247              	 .loc 1 255 0 is_stmt 0 discriminator 1
 248 009a FA7A     	 ldrb r2,[r7,#11]
 249 009c 7B7A     	 ldrb r3,[r7,#9]
 250 009e 9A42     	 cmp r2,r3
 251 00a0 EBD9     	 bls .L13
 258:../SSC/Src/objdef.c ****             }
 259:../SSC/Src/objdef.c ****             /* we have to convert the size in bytes */
 260:../SSC/Src/objdef.c ****             size = BIT2BYTE(size);
 252              	 .loc 1 260 0 is_stmt 1
 253 00a2 FB68     	 ldr r3,[r7,#12]
 254 00a4 0733     	 adds r3,r3,#7
 255 00a6 DB08     	 lsrs r3,r3,#3
 256 00a8 FB60     	 str r3,[r7,#12]
 261:../SSC/Src/objdef.c **** 
 262:../SSC/Src/objdef.c ****             if ( subindex == 0 )
 257              	 .loc 1 262 0
 258 00aa 7B79     	 ldrb r3,[r7,#5]
 259 00ac 002B     	 cmp r3,#0
 260 00ae 02D1     	 bne .L14
 263:../SSC/Src/objdef.c ****             {
 264:../SSC/Src/objdef.c ****                 /* add size for subindex 0 (is transmitted as UINT16) */
 265:../SSC/Src/objdef.c ****                 size += 2;
 261              	 .loc 1 265 0
 262 00b0 FB68     	 ldr r3,[r7,#12]
 263 00b2 0233     	 adds r3,r3,#2
 264 00b4 FB60     	 str r3,[r7,#12]
 265              	.L14:
 266:../SSC/Src/objdef.c ****             }
 267:../SSC/Src/objdef.c ****             return size;
 266              	 .loc 1 267 0
 267 00b6 FB68     	 ldr r3,[r7,#12]
 268 00b8 28E0     	 b .L9
 269              	.L7:
 270              	.LBE2:
 268:../SSC/Src/objdef.c ****         }
 269:../SSC/Src/objdef.c ****     }
 270:../SSC/Src/objdef.c ****     else
 271:../SSC/Src/objdef.c ****     {
 272:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR )
 271              	 .loc 1 272 0
 272 00ba BB7A     	 ldrb r3,[r7,#10]
 273 00bc 072B     	 cmp r3,#7
 274 00be 05D1     	 bne .L15
 273:../SSC/Src/objdef.c ****         {
 274:../SSC/Src/objdef.c **** 
 275:../SSC/Src/objdef.c ****             return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
 275              	 .loc 1 275 0
 276 00c0 3B68     	 ldr r3,[r7]
 277 00c2 1B69     	 ldr r3,[r3,#16]
 278 00c4 5B88     	 ldrh r3,[r3,#2]
 279 00c6 0733     	 adds r3,r3,#7
 280 00c8 DB10     	 asrs r3,r3,#3
 281 00ca 1FE0     	 b .L9
 282              	.L15:
 276:../SSC/Src/objdef.c **** 
 277:../SSC/Src/objdef.c ****         }
 278:../SSC/Src/objdef.c ****         else if ( subindex == 0 )
 283              	 .loc 1 278 0
 284 00cc 7B79     	 ldrb r3,[r7,#5]
 285 00ce 002B     	 cmp r3,#0
 286 00d0 01D1     	 bne .L16
 279:../SSC/Src/objdef.c ****         {
 280:../SSC/Src/objdef.c ****             /* for single access subindex 0 is transmitted as UINT8 */
 281:../SSC/Src/objdef.c ****             return 1;
 287              	 .loc 1 281 0
 288 00d2 0123     	 movs r3,#1
 289 00d4 1AE0     	 b .L9
 290              	.L16:
 282:../SSC/Src/objdef.c ****         }
 283:../SSC/Src/objdef.c ****         else if((objCode == OBJCODE_ARR)
 291              	 .loc 1 283 0
 292 00d6 BB7A     	 ldrb r3,[r7,#10]
 293 00d8 082B     	 cmp r3,#8
 294 00da 06D1     	 bne .L17
 284:../SSC/Src/objdef.c ****             )
 285:../SSC/Src/objdef.c ****         {
 286:../SSC/Src/objdef.c ****             return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
 295              	 .loc 1 286 0
 296 00dc 3B68     	 ldr r3,[r7]
 297 00de 1B69     	 ldr r3,[r3,#16]
 298 00e0 0633     	 adds r3,r3,#6
 299 00e2 5B88     	 ldrh r3,[r3,#2]
 300 00e4 0733     	 adds r3,r3,#7
 301 00e6 DB10     	 asrs r3,r3,#3
 302 00e8 10E0     	 b .L9
 303              	.L17:
 287:../SSC/Src/objdef.c ****         }
 288:../SSC/Src/objdef.c ****         else
 289:../SSC/Src/objdef.c ****         {
 290:../SSC/Src/objdef.c ****             {
 291:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.12) COE6*/
 292:../SSC/Src/objdef.c ****                 if (maxSubindex < subindex)
 304              	 .loc 1 292 0
 305 00ea 7A7A     	 ldrb r2,[r7,#9]
 306 00ec 7B79     	 ldrb r3,[r7,#5]
 307 00ee 9A42     	 cmp r2,r3
 308 00f0 01D2     	 bcs .L18
 293:../SSC/Src/objdef.c ****                 {
 294:../SSC/Src/objdef.c ****                     return 0;
 309              	 .loc 1 294 0
 310 00f2 0023     	 movs r3,#0
 311 00f4 0AE0     	 b .L9
 312              	.L18:
 295:../SSC/Src/objdef.c **** 
 296:../SSC/Src/objdef.c ****                 }
 297:../SSC/Src/objdef.c ****                 else
 298:../SSC/Src/objdef.c ****                 {
 299:../SSC/Src/objdef.c ****                     return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
 313              	 .loc 1 299 0
 314 00f6 3B68     	 ldr r3,[r7]
 315 00f8 1969     	 ldr r1,[r3,#16]
 316 00fa 7A79     	 ldrb r2,[r7,#5]
 317 00fc 1346     	 mov r3,r2
 318 00fe 5B00     	 lsls r3,r3,#1
 319 0100 1344     	 add r3,r3,r2
 320 0102 5B00     	 lsls r3,r3,#1
 321 0104 0B44     	 add r3,r3,r1
 322 0106 5B88     	 ldrh r3,[r3,#2]
 323 0108 0733     	 adds r3,r3,#7
 324 010a DB10     	 asrs r3,r3,#3
 325              	.L9:
 300:../SSC/Src/objdef.c ****                 }
 301:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.12) COE6*/
 302:../SSC/Src/objdef.c ****             }
 303:../SSC/Src/objdef.c ****         }
 304:../SSC/Src/objdef.c ****     }
 305:../SSC/Src/objdef.c **** }
 326              	 .loc 1 305 0
 327 010c 1846     	 mov r0,r3
 328 010e 1437     	 adds r7,r7,#20
 329              	.LCFI8:
 330              	 .cfi_def_cfa_offset 4
 331 0110 BD46     	 mov sp,r7
 332              	.LCFI9:
 333              	 .cfi_def_cfa_register 13
 334              	 
 335 0112 5DF8047B 	 ldr r7,[sp],#4
 336              	.LCFI10:
 337              	 .cfi_restore 7
 338              	 .cfi_def_cfa_offset 0
 339 0116 7047     	 bx lr
 340              	 .cfi_endproc
 341              	.LFE180:
 343              	 .section .text.OBJ_CopyNumberToString,"ax",%progbits
 344              	 .align 2
 345              	 .global OBJ_CopyNumberToString
 346              	 .thumb
 347              	 .thumb_func
 349              	OBJ_CopyNumberToString:
 350              	.LFB181:
 306:../SSC/Src/objdef.c **** 
 307:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 308:../SSC/Src/objdef.c **** /**
 309:../SSC/Src/objdef.c ****  \param     pStr         Pointer to a string
 310:../SSC/Src/objdef.c ****  \param  Number   Number to be included in the string
 311:../SSC/Src/objdef.c **** 
 312:../SSC/Src/objdef.c ****  \brief    The function copies the Number in the string pStr,
 313:../SSC/Src/objdef.c ****          which shall be initialized with 000
 314:../SSC/Src/objdef.c **** 
 315:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 316:../SSC/Src/objdef.c **** 
 317:../SSC/Src/objdef.c **** void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
 318:../SSC/Src/objdef.c **** {
 351              	 .loc 1 318 0
 352              	 .cfi_startproc
 353              	 
 354              	 
 355              	 
 356 0000 90B4     	 push {r4,r7}
 357              	.LCFI11:
 358              	 .cfi_def_cfa_offset 8
 359              	 .cfi_offset 4,-8
 360              	 .cfi_offset 7,-4
 361 0002 84B0     	 sub sp,sp,#16
 362              	.LCFI12:
 363              	 .cfi_def_cfa_offset 24
 364 0004 00AF     	 add r7,sp,#0
 365              	.LCFI13:
 366              	 .cfi_def_cfa_register 7
 367 0006 7860     	 str r0,[r7,#4]
 368 0008 0B46     	 mov r3,r1
 369 000a FB70     	 strb r3,[r7,#3]
 319:../SSC/Src/objdef.c ****     UINT8 Modulo;
 320:../SSC/Src/objdef.c **** 
 321:../SSC/Src/objdef.c ****     pStr[2] = '0';
 370              	 .loc 1 321 0
 371 000c 7B68     	 ldr r3,[r7,#4]
 372 000e 0233     	 adds r3,r3,#2
 373 0010 3022     	 movs r2,#48
 374 0012 1A70     	 strb r2,[r3]
 322:../SSC/Src/objdef.c ****     pStr[0] += (Number / 100);
 375              	 .loc 1 322 0
 376 0014 7B68     	 ldr r3,[r7,#4]
 377 0016 1A78     	 ldrb r2,[r3]
 378 0018 FB78     	 ldrb r3,[r7,#3]
 379 001a 1C49     	 ldr r1,.L20
 380 001c A1FB0313 	 umull r1,r3,r1,r3
 381 0020 5B09     	 lsrs r3,r3,#5
 382 0022 DBB2     	 uxtb r3,r3
 383 0024 1344     	 add r3,r3,r2
 384 0026 DAB2     	 uxtb r2,r3
 385 0028 7B68     	 ldr r3,[r7,#4]
 386 002a 1A70     	 strb r2,[r3]
 323:../SSC/Src/objdef.c ****     Modulo = Number % 100;
 387              	 .loc 1 323 0
 388 002c FB78     	 ldrb r3,[r7,#3]
 389 002e 174A     	 ldr r2,.L20
 390 0030 A2FB0312 	 umull r1,r2,r2,r3
 391 0034 5209     	 lsrs r2,r2,#5
 392 0036 6421     	 movs r1,#100
 393 0038 01FB02F2 	 mul r2,r1,r2
 394 003c 9B1A     	 subs r3,r3,r2
 395 003e FB73     	 strb r3,[r7,#15]
 324:../SSC/Src/objdef.c ****     pStr[1] += (Modulo / 10);
 396              	 .loc 1 324 0
 397 0040 7B68     	 ldr r3,[r7,#4]
 398 0042 0133     	 adds r3,r3,#1
 399 0044 7A68     	 ldr r2,[r7,#4]
 400 0046 0132     	 adds r2,r2,#1
 401 0048 1178     	 ldrb r1,[r2]
 402 004a FA7B     	 ldrb r2,[r7,#15]
 403 004c 1048     	 ldr r0,.L20+4
 404 004e A0FB0202 	 umull r0,r2,r0,r2
 405 0052 D208     	 lsrs r2,r2,#3
 406 0054 D2B2     	 uxtb r2,r2
 407 0056 0A44     	 add r2,r2,r1
 408 0058 D2B2     	 uxtb r2,r2
 409 005a 1A70     	 strb r2,[r3]
 325:../SSC/Src/objdef.c ****     pStr[2] += (Modulo % 10);
 410              	 .loc 1 325 0
 411 005c 7B68     	 ldr r3,[r7,#4]
 412 005e 981C     	 adds r0,r3,#2
 413 0060 7B68     	 ldr r3,[r7,#4]
 414 0062 0233     	 adds r3,r3,#2
 415 0064 1C78     	 ldrb r4,[r3]
 416 0066 FA7B     	 ldrb r2,[r7,#15]
 417 0068 094B     	 ldr r3,.L20+4
 418 006a A3FB0213 	 umull r1,r3,r3,r2
 419 006e D908     	 lsrs r1,r3,#3
 420 0070 0B46     	 mov r3,r1
 421 0072 9B00     	 lsls r3,r3,#2
 422 0074 0B44     	 add r3,r3,r1
 423 0076 5B00     	 lsls r3,r3,#1
 424 0078 D31A     	 subs r3,r2,r3
 425 007a DBB2     	 uxtb r3,r3
 426 007c 2344     	 add r3,r3,r4
 427 007e DBB2     	 uxtb r3,r3
 428 0080 0370     	 strb r3,[r0]
 326:../SSC/Src/objdef.c **** }
 429              	 .loc 1 326 0
 430 0082 1037     	 adds r7,r7,#16
 431              	.LCFI14:
 432              	 .cfi_def_cfa_offset 8
 433 0084 BD46     	 mov sp,r7
 434              	.LCFI15:
 435              	 .cfi_def_cfa_register 13
 436              	 
 437 0086 90BC     	 pop {r4,r7}
 438              	.LCFI16:
 439              	 .cfi_restore 7
 440              	 .cfi_restore 4
 441              	 .cfi_def_cfa_offset 0
 442 0088 7047     	 bx lr
 443              	.L21:
 444 008a 00BF     	 .align 2
 445              	.L20:
 446 008c 1F85EB51 	 .word 1374389535
 447 0090 CDCCCCCC 	 .word -858993459
 448              	 .cfi_endproc
 449              	.LFE181:
 451              	 .section .text.OBJ_GetNoOfObjects,"ax",%progbits
 452              	 .align 2
 453              	 .global OBJ_GetNoOfObjects
 454              	 .thumb
 455              	 .thumb_func
 457              	OBJ_GetNoOfObjects:
 458              	.LFB182:
 327:../SSC/Src/objdef.c **** 
 328:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 329:../SSC/Src/objdef.c **** /**
 330:../SSC/Src/objdef.c ****  \param     listType requested listType (0=all objects, 1=RxPDO mappable objects,
 331:../SSC/Src/objdef.c ****                         2=TxPDO mappable objects, 3=backup objects, 4=setting objects)
 332:../SSC/Src/objdef.c **** 
 333:../SSC/Src/objdef.c ****  \return Number of objects of the requested list type
 334:../SSC/Src/objdef.c **** 
 335:../SSC/Src/objdef.c ****  \brief    The function counts the number of objects of the requested list type
 336:../SSC/Src/objdef.c **** 
 337:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 338:../SSC/Src/objdef.c **** 
 339:../SSC/Src/objdef.c **** UINT16    OBJ_GetNoOfObjects(UINT8 listType)
 340:../SSC/Src/objdef.c **** {
 459              	 .loc 1 340 0
 460              	 .cfi_startproc
 461              	 
 462              	 
 463 0000 80B5     	 push {r7,lr}
 464              	.LCFI17:
 465              	 .cfi_def_cfa_offset 8
 466              	 .cfi_offset 7,-8
 467              	 .cfi_offset 14,-4
 468 0002 86B0     	 sub sp,sp,#24
 469              	.LCFI18:
 470              	 .cfi_def_cfa_offset 32
 471 0004 00AF     	 add r7,sp,#0
 472              	.LCFI19:
 473              	 .cfi_def_cfa_register 7
 474 0006 0346     	 mov r3,r0
 475 0008 FB71     	 strb r3,[r7,#7]
 341:../SSC/Src/objdef.c ****     /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
 342:../SSC/Src/objdef.c ****        see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
 343:../SSC/Src/objdef.c ****        all objects has to be counted */
 344:../SSC/Src/objdef.c ****     
 345:../SSC/Src/objdef.c ****     UINT16 listFlags = 0x0020 << listType;
 476              	 .loc 1 345 0
 477 000a FB79     	 ldrb r3,[r7,#7]
 478 000c 2022     	 movs r2,#32
 479 000e 02FA03F3 	 lsl r3,r2,r3
 480 0012 BB81     	 strh r3,[r7,#12]
 346:../SSC/Src/objdef.c ****     
 347:../SSC/Src/objdef.c ****     /* set pObjEntry to the beginning of the object dictionary */
 348:../SSC/Src/objdef.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
 481              	 .loc 1 348 0
 482 0014 FFF7FEFF 	 bl COE_GetObjectDictionary
 483 0018 7861     	 str r0,[r7,#20]
 349:../SSC/Src/objdef.c ****     UINT16 n = 0;
 484              	 .loc 1 349 0
 485 001a 0023     	 movs r3,#0
 486 001c 7B82     	 strh r3,[r7,#18]
 350:../SSC/Src/objdef.c **** 
 351:../SSC/Src/objdef.c **** 
 352:../SSC/Src/objdef.c ****     while (pObjEntry != NULL)
 487              	 .loc 1 352 0
 488 001e 32E0     	 b .L23
 489              	.L29:
 353:../SSC/Src/objdef.c ****     {
 354:../SSC/Src/objdef.c ****         /* count the objects of the requested list type */
 355:../SSC/Src/objdef.c ****         if ( pObjEntry->Index >= 0x1000 )
 490              	 .loc 1 355 0
 491 0020 7B69     	 ldr r3,[r7,#20]
 492 0022 1B89     	 ldrh r3,[r3,#8]
 493 0024 B3F5805F 	 cmp r3,#4096
 494 0028 2AD3     	 bcc .L24
 495              	.LBB3:
 356:../SSC/Src/objdef.c ****         {
 357:../SSC/Src/objdef.c ****             UINT8 t = listType;
 496              	 .loc 1 357 0
 497 002a FB79     	 ldrb r3,[r7,#7]
 498 002c 7B74     	 strb r3,[r7,#17]
 358:../SSC/Src/objdef.c ****             if ( t )
 499              	 .loc 1 358 0
 500 002e 7B7C     	 ldrb r3,[r7,#17]
 501 0030 002B     	 cmp r3,#0
 502 0032 1FD0     	 beq .L25
 503              	.LBB4:
 359:../SSC/Src/objdef.c ****             {
 360:../SSC/Src/objdef.c ****                 UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJ
 504              	 .loc 1 360 0
 505 0034 7B69     	 ldr r3,[r7,#20]
 506 0036 9B89     	 ldrh r3,[r3,#12]
 507 0038 FB72     	 strb r3,[r7,#11]
 361:../SSC/Src/objdef.c ****                 UINT16 i = 0;
 508              	 .loc 1 361 0
 509 003a 0023     	 movs r3,#0
 510 003c FB81     	 strh r3,[r7,#14]
 362:../SSC/Src/objdef.c **** 
 363:../SSC/Src/objdef.c ****                 while ( t && i <= maxSubindex )
 511              	 .loc 1 363 0
 512 003e 11E0     	 b .L26
 513              	.L28:
 364:../SSC/Src/objdef.c ****                 {
 365:../SSC/Src/objdef.c ****                     if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
 514              	 .loc 1 365 0
 515 0040 FB89     	 ldrh r3,[r7,#14]
 516 0042 DBB2     	 uxtb r3,r3
 517 0044 7869     	 ldr r0,[r7,#20]
 518 0046 1946     	 mov r1,r3
 519 0048 FFF7FEFF 	 bl OBJ_GetEntryDesc
 520 004c 0346     	 mov r3,r0
 521 004e 9A88     	 ldrh r2,[r3,#4]
 522 0050 BB89     	 ldrh r3,[r7,#12]
 523 0052 1340     	 ands r3,r3,r2
 524 0054 9BB2     	 uxth r3,r3
 525 0056 002B     	 cmp r3,#0
 526 0058 01D0     	 beq .L27
 366:../SSC/Src/objdef.c ****                     {
 367:../SSC/Src/objdef.c ****                         t = 0;
 527              	 .loc 1 367 0
 528 005a 0023     	 movs r3,#0
 529 005c 7B74     	 strb r3,[r7,#17]
 530              	.L27:
 368:../SSC/Src/objdef.c ****                     }
 369:../SSC/Src/objdef.c ****                     i++;
 531              	 .loc 1 369 0
 532 005e FB89     	 ldrh r3,[r7,#14]
 533 0060 0133     	 adds r3,r3,#1
 534 0062 FB81     	 strh r3,[r7,#14]
 535              	.L26:
 363:../SSC/Src/objdef.c ****                 {
 536              	 .loc 1 363 0
 537 0064 7B7C     	 ldrb r3,[r7,#17]
 538 0066 002B     	 cmp r3,#0
 539 0068 04D0     	 beq .L25
 363:../SSC/Src/objdef.c ****                 {
 540              	 .loc 1 363 0 is_stmt 0 discriminator 1
 541 006a FB7A     	 ldrb r3,[r7,#11]
 542 006c 9BB2     	 uxth r3,r3
 543 006e FA89     	 ldrh r2,[r7,#14]
 544 0070 9A42     	 cmp r2,r3
 545 0072 E5D9     	 bls .L28
 546              	.L25:
 547              	.LBE4:
 370:../SSC/Src/objdef.c ****                 }
 371:../SSC/Src/objdef.c ****             }
 372:../SSC/Src/objdef.c ****             if ( !t )
 548              	 .loc 1 372 0 is_stmt 1
 549 0074 7B7C     	 ldrb r3,[r7,#17]
 550 0076 002B     	 cmp r3,#0
 551 0078 02D1     	 bne .L24
 373:../SSC/Src/objdef.c ****             {
 374:../SSC/Src/objdef.c ****                 /* object from listType found */
 375:../SSC/Src/objdef.c ****                 n++;
 552              	 .loc 1 375 0
 553 007a 7B8A     	 ldrh r3,[r7,#18]
 554 007c 0133     	 adds r3,r3,#1
 555 007e 7B82     	 strh r3,[r7,#18]
 556              	.L24:
 557              	.LBE3:
 376:../SSC/Src/objdef.c ****             }
 377:../SSC/Src/objdef.c ****         }
 378:../SSC/Src/objdef.c ****         /* next object in object dictionary */
 379:../SSC/Src/objdef.c ****         pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 558              	 .loc 1 379 0
 559 0080 7B69     	 ldr r3,[r7,#20]
 560 0082 5B68     	 ldr r3,[r3,#4]
 561 0084 7B61     	 str r3,[r7,#20]
 562              	.L23:
 352:../SSC/Src/objdef.c ****     {
 563              	 .loc 1 352 0
 564 0086 7B69     	 ldr r3,[r7,#20]
 565 0088 002B     	 cmp r3,#0
 566 008a C9D1     	 bne .L29
 380:../SSC/Src/objdef.c ****     }
 381:../SSC/Src/objdef.c **** 
 382:../SSC/Src/objdef.c ****     return n;
 567              	 .loc 1 382 0
 568 008c 7B8A     	 ldrh r3,[r7,#18]
 383:../SSC/Src/objdef.c **** }
 569              	 .loc 1 383 0
 570 008e 1846     	 mov r0,r3
 571 0090 1837     	 adds r7,r7,#24
 572              	.LCFI20:
 573              	 .cfi_def_cfa_offset 8
 574 0092 BD46     	 mov sp,r7
 575              	.LCFI21:
 576              	 .cfi_def_cfa_register 13
 577              	 
 578 0094 80BD     	 pop {r7,pc}
 579              	 .cfi_endproc
 580              	.LFE182:
 582 0096 00BF     	 .section .text.OBJ_GetObjectList,"ax",%progbits
 583              	 .align 2
 584              	 .global OBJ_GetObjectList
 585              	 .thumb
 586              	 .thumb_func
 588              	OBJ_GetObjectList:
 589              	.LFB183:
 384:../SSC/Src/objdef.c **** 
 385:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 386:../SSC/Src/objdef.c **** /**
 387:../SSC/Src/objdef.c ****  \param     listType 	Requested listType (0=all objects, 1=RxPDO mappable objects,
 388:../SSC/Src/objdef.c ****                         2=TxPDO mappable objects, 3=backup objects, 4=setting objects)
 389:../SSC/Src/objdef.c ****  \param     pIndex     	Pointer to the next Index of the object list to copied in the mailbox buffe
 390:../SSC/Src/objdef.c ****                          has to adapted    at the end of the function
 391:../SSC/Src/objdef.c ****  \param     size        Size of the available mailbox buffer
 392:../SSC/Src/objdef.c ****  \param     pData     	Pointer to the mailbox buffer where (the part of) the object list requested 
 393:../SSC/Src/objdef.c ****  \param     pAbort    	Pointer to abortCode
 394:../SSC/Src/objdef.c **** 
 395:../SSC/Src/objdef.c ****  \return 	Size of the available mailbox buffer which was not copied to
 396:../SSC/Src/objdef.c **** 
 397:../SSC/Src/objdef.c ****  \brief    The function copies (the part of) the object list in the mailbox buffer
 398:../SSC/Src/objdef.c **** 
 399:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 400:../SSC/Src/objdef.c **** UINT16    OBJ_GetObjectList(UINT16 listType, UINT16 *pIndex, UINT16 size, UINT16 MBXMEM *pData,UINT
 401:../SSC/Src/objdef.c **** {
 590              	 .loc 1 401 0
 591              	 .cfi_startproc
 592              	 
 593              	 
 594 0000 80B5     	 push {r7,lr}
 595              	.LCFI22:
 596              	 .cfi_def_cfa_offset 8
 597              	 .cfi_offset 7,-8
 598              	 .cfi_offset 14,-4
 599 0002 88B0     	 sub sp,sp,#32
 600              	.LCFI23:
 601              	 .cfi_def_cfa_offset 40
 602 0004 00AF     	 add r7,sp,#0
 603              	.LCFI24:
 604              	 .cfi_def_cfa_register 7
 605 0006 B960     	 str r1,[r7,#8]
 606 0008 7B60     	 str r3,[r7,#4]
 607 000a 0346     	 mov r3,r0
 608 000c FB81     	 strh r3,[r7,#14]
 609 000e 1346     	 mov r3,r2
 610 0010 BB81     	 strh r3,[r7,#12]
 402:../SSC/Src/objdef.c ****     /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
 403:../SSC/Src/objdef.c ****        see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
 404:../SSC/Src/objdef.c ****        all objects has to be counted */
 405:../SSC/Src/objdef.c ****     UINT16 listFlags = 0x0020 << listType;
 611              	 .loc 1 405 0
 612 0012 FB89     	 ldrh r3,[r7,#14]
 613 0014 2022     	 movs r2,#32
 614 0016 02FA03F3 	 lsl r3,r2,r3
 615 001a FB82     	 strh r3,[r7,#22]
 406:../SSC/Src/objdef.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry;
 407:../SSC/Src/objdef.c **** 
 408:../SSC/Src/objdef.c **** 
 409:../SSC/Src/objdef.c ****     if ( pIndex[0] == 0x1000 )
 616              	 .loc 1 409 0
 617 001c BB68     	 ldr r3,[r7,#8]
 618 001e 1B88     	 ldrh r3,[r3]
 619 0020 B3F5805F 	 cmp r3,#4096
 620 0024 0CD1     	 bne .L32
 410:../SSC/Src/objdef.c ****     {
 411:../SSC/Src/objdef.c ****         /* beginning of object list, set pObjEntry to the beginning of the object dictionary */
 412:../SSC/Src/objdef.c ****        pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
 621              	 .loc 1 412 0
 622 0026 FFF7FEFF 	 bl COE_GetObjectDictionary
 623 002a F861     	 str r0,[r7,#28]
 413:../SSC/Src/objdef.c ****         // set abort code if no object dictionary is available
 414:../SSC/Src/objdef.c ****         if((pObjEntry == NULL) && (pAbort != NULL))
 624              	 .loc 1 414 0
 625 002c FB69     	 ldr r3,[r7,#28]
 626 002e 002B     	 cmp r3,#0
 627 0030 09D1     	 bne .L34
 628              	 .loc 1 414 0 is_stmt 0 discriminator 1
 629 0032 BB6A     	 ldr r3,[r7,#40]
 630 0034 002B     	 cmp r3,#0
 631 0036 06D0     	 beq .L34
 415:../SSC/Src/objdef.c ****         {
 416:../SSC/Src/objdef.c ****             *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
 632              	 .loc 1 416 0 is_stmt 1
 633 0038 BB6A     	 ldr r3,[r7,#40]
 634 003a 1B22     	 movs r2,#27
 635 003c 1A70     	 strb r2,[r3]
 636 003e 02E0     	 b .L34
 637              	.L32:
 417:../SSC/Src/objdef.c ****         }
 418:../SSC/Src/objdef.c ****     }
 419:../SSC/Src/objdef.c ****     else
 420:../SSC/Src/objdef.c ****     {
 421:../SSC/Src/objdef.c ****         /* next fragment, the next object to be handled was stored in pSdoInfoObjEntry */
 422:../SSC/Src/objdef.c ****         pObjEntry = pSdoInfoObjEntry;
 638              	 .loc 1 422 0
 639 0040 2C4B     	 ldr r3,.L46
 640 0042 1B68     	 ldr r3,[r3]
 641 0044 FB61     	 str r3,[r7,#28]
 642              	.L34:
 423:../SSC/Src/objdef.c ****     }
 424:../SSC/Src/objdef.c **** 
 425:../SSC/Src/objdef.c ****     if ( pObjEntry != NULL )
 643              	 .loc 1 425 0
 644 0046 FB69     	 ldr r3,[r7,#28]
 645 0048 002B     	 cmp r3,#0
 646 004a 3ED0     	 beq .L35
 426:../SSC/Src/objdef.c ****     {
 427:../SSC/Src/objdef.c ****         while (pObjEntry != NULL && size > 1 )
 647              	 .loc 1 427 0
 648 004c 37E0     	 b .L36
 649              	.L42:
 428:../SSC/Src/objdef.c ****         {
 429:../SSC/Src/objdef.c ****             /* get the next index of the requested object list if there is enough space in the mail
 430:../SSC/Src/objdef.c ****             if ( pObjEntry->Index >= 0x1000 )
 650              	 .loc 1 430 0
 651 004e FB69     	 ldr r3,[r7,#28]
 652 0050 1B89     	 ldrh r3,[r3,#8]
 653 0052 B3F5805F 	 cmp r3,#4096
 654 0056 2FD3     	 bcc .L37
 655              	.LBB5:
 431:../SSC/Src/objdef.c ****             {
 432:../SSC/Src/objdef.c ****                 /* UINT8 was changed to UINT16 */
 433:../SSC/Src/objdef.c ****                 UINT16 t = listType;
 656              	 .loc 1 433 0
 657 0058 FB89     	 ldrh r3,[r7,#14]
 658 005a 7B83     	 strh r3,[r7,#26]
 434:../SSC/Src/objdef.c ****                 if ( t )
 659              	 .loc 1 434 0
 660 005c 7B8B     	 ldrh r3,[r7,#26]
 661 005e 002B     	 cmp r3,#0
 662 0060 1DD0     	 beq .L38
 663              	.LBB6:
 435:../SSC/Src/objdef.c ****                 {
 436:../SSC/Src/objdef.c ****                     UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >>
 664              	 .loc 1 436 0
 665 0062 FB69     	 ldr r3,[r7,#28]
 666 0064 9B89     	 ldrh r3,[r3,#12]
 667 0066 7B75     	 strb r3,[r7,#21]
 437:../SSC/Src/objdef.c ****                     UINT8 i = 0;
 668              	 .loc 1 437 0
 669 0068 0023     	 movs r3,#0
 670 006a 7B76     	 strb r3,[r7,#25]
 438:../SSC/Src/objdef.c **** 
 439:../SSC/Src/objdef.c ****                     while ( t && i <= maxSubindex )
 671              	 .loc 1 439 0
 672 006c 10E0     	 b .L39
 673              	.L41:
 440:../SSC/Src/objdef.c ****                     {
 441:../SSC/Src/objdef.c ****                         if ( OBJ_GetEntryDesc(pObjEntry, i)->ObjAccess & listFlags )
 674              	 .loc 1 441 0
 675 006e 7B7E     	 ldrb r3,[r7,#25]
 676 0070 F869     	 ldr r0,[r7,#28]
 677 0072 1946     	 mov r1,r3
 678 0074 FFF7FEFF 	 bl OBJ_GetEntryDesc
 679 0078 0346     	 mov r3,r0
 680 007a 9A88     	 ldrh r2,[r3,#4]
 681 007c FB8A     	 ldrh r3,[r7,#22]
 682 007e 1340     	 ands r3,r3,r2
 683 0080 9BB2     	 uxth r3,r3
 684 0082 002B     	 cmp r3,#0
 685 0084 01D0     	 beq .L40
 442:../SSC/Src/objdef.c ****                         {
 443:../SSC/Src/objdef.c ****                             t = 0;
 686              	 .loc 1 443 0
 687 0086 0023     	 movs r3,#0
 688 0088 7B83     	 strh r3,[r7,#26]
 689              	.L40:
 444:../SSC/Src/objdef.c ****                         }
 445:../SSC/Src/objdef.c ****                         i++;
 690              	 .loc 1 445 0
 691 008a 7B7E     	 ldrb r3,[r7,#25]
 692 008c 0133     	 adds r3,r3,#1
 693 008e 7B76     	 strb r3,[r7,#25]
 694              	.L39:
 439:../SSC/Src/objdef.c ****                     {
 695              	 .loc 1 439 0
 696 0090 7B8B     	 ldrh r3,[r7,#26]
 697 0092 002B     	 cmp r3,#0
 698 0094 03D0     	 beq .L38
 439:../SSC/Src/objdef.c ****                     {
 699              	 .loc 1 439 0 is_stmt 0 discriminator 1
 700 0096 7A7E     	 ldrb r2,[r7,#25]
 701 0098 7B7D     	 ldrb r3,[r7,#21]
 702 009a 9A42     	 cmp r2,r3
 703 009c E7D9     	 bls .L41
 704              	.L38:
 705              	.LBE6:
 446:../SSC/Src/objdef.c ****                     }
 447:../SSC/Src/objdef.c ****                 }
 448:../SSC/Src/objdef.c ****                 if ( !t )
 706              	 .loc 1 448 0 is_stmt 1
 707 009e 7B8B     	 ldrh r3,[r7,#26]
 708 00a0 002B     	 cmp r3,#0
 709 00a2 09D1     	 bne .L37
 449:../SSC/Src/objdef.c ****                 {
 450:../SSC/Src/objdef.c ****                     /* store the index in the mailbox buffer */
 451:../SSC/Src/objdef.c ****                     *pData = SWAPWORD(pObjEntry->Index);
 710              	 .loc 1 451 0
 711 00a4 FB69     	 ldr r3,[r7,#28]
 712 00a6 1A89     	 ldrh r2,[r3,#8]
 713 00a8 7B68     	 ldr r3,[r7,#4]
 714 00aa 1A80     	 strh r2,[r3]
 452:../SSC/Src/objdef.c ****                     pData++;
 715              	 .loc 1 452 0
 716 00ac 7B68     	 ldr r3,[r7,#4]
 717 00ae 0233     	 adds r3,r3,#2
 718 00b0 7B60     	 str r3,[r7,#4]
 453:../SSC/Src/objdef.c ****                     size -= 2;
 719              	 .loc 1 453 0
 720 00b2 BB89     	 ldrh r3,[r7,#12]
 721 00b4 023B     	 subs r3,r3,#2
 722 00b6 BB81     	 strh r3,[r7,#12]
 723              	.L37:
 724              	.LBE5:
 454:../SSC/Src/objdef.c ****                 }
 455:../SSC/Src/objdef.c ****             }
 456:../SSC/Src/objdef.c ****         pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 725              	 .loc 1 456 0
 726 00b8 FB69     	 ldr r3,[r7,#28]
 727 00ba 5B68     	 ldr r3,[r3,#4]
 728 00bc FB61     	 str r3,[r7,#28]
 729              	.L36:
 427:../SSC/Src/objdef.c ****         {
 730              	 .loc 1 427 0
 731 00be FB69     	 ldr r3,[r7,#28]
 732 00c0 002B     	 cmp r3,#0
 733 00c2 02D0     	 beq .L35
 427:../SSC/Src/objdef.c ****         {
 734              	 .loc 1 427 0 is_stmt 0 discriminator 1
 735 00c4 BB89     	 ldrh r3,[r7,#12]
 736 00c6 012B     	 cmp r3,#1
 737 00c8 C1D8     	 bhi .L42
 738              	.L35:
 457:../SSC/Src/objdef.c ****         }
 458:../SSC/Src/objdef.c ****     }
 459:../SSC/Src/objdef.c **** 
 460:../SSC/Src/objdef.c ****         /* return the next Index to be handled */
 461:../SSC/Src/objdef.c ****         if(pObjEntry != NULL)
 739              	 .loc 1 461 0 is_stmt 1
 740 00ca FB69     	 ldr r3,[r7,#28]
 741 00cc 002B     	 cmp r3,#0
 742 00ce 04D0     	 beq .L43
 462:../SSC/Src/objdef.c ****         {
 463:../SSC/Src/objdef.c ****             pIndex[0] = pObjEntry->Index;
 743              	 .loc 1 463 0
 744 00d0 FB69     	 ldr r3,[r7,#28]
 745 00d2 1A89     	 ldrh r2,[r3,#8]
 746 00d4 BB68     	 ldr r3,[r7,#8]
 747 00d6 1A80     	 strh r2,[r3]
 748 00d8 03E0     	 b .L44
 749              	.L43:
 464:../SSC/Src/objdef.c ****         }
 465:../SSC/Src/objdef.c ****         else
 466:../SSC/Src/objdef.c ****         {
 467:../SSC/Src/objdef.c ****             /*last entry reached*/
 468:../SSC/Src/objdef.c ****             pIndex[0] = 0xFFFF;
 750              	 .loc 1 468 0
 751 00da BB68     	 ldr r3,[r7,#8]
 752 00dc 4FF6FF72 	 movw r2,#65535
 753 00e0 1A80     	 strh r2,[r3]
 754              	.L44:
 469:../SSC/Src/objdef.c ****         }
 470:../SSC/Src/objdef.c **** 
 471:../SSC/Src/objdef.c ****     /* store object description pointer and index for next fragment */
 472:../SSC/Src/objdef.c ****     pSdoInfoObjEntry = pObjEntry;
 755              	 .loc 1 472 0
 756 00e2 044A     	 ldr r2,.L46
 757 00e4 FB69     	 ldr r3,[r7,#28]
 758 00e6 1360     	 str r3,[r2]
 473:../SSC/Src/objdef.c **** 
 474:../SSC/Src/objdef.c ****     /* return the size of the available mailbox buffer which was not copied to */
 475:../SSC/Src/objdef.c ****     return size;
 759              	 .loc 1 475 0
 760 00e8 BB89     	 ldrh r3,[r7,#12]
 476:../SSC/Src/objdef.c **** }
 761              	 .loc 1 476 0
 762 00ea 1846     	 mov r0,r3
 763 00ec 2037     	 adds r7,r7,#32
 764              	.LCFI25:
 765              	 .cfi_def_cfa_offset 8
 766 00ee BD46     	 mov sp,r7
 767              	.LCFI26:
 768              	 .cfi_def_cfa_register 13
 769              	 
 770 00f0 80BD     	 pop {r7,pc}
 771              	.L47:
 772 00f2 00BF     	 .align 2
 773              	.L46:
 774 00f4 00000000 	 .word pSdoInfoObjEntry
 775              	 .cfi_endproc
 776              	.LFE183:
 778              	 .section .text.OBJ_GetDesc,"ax",%progbits
 779              	 .align 2
 780              	 .global OBJ_GetDesc
 781              	 .thumb
 782              	 .thumb_func
 784              	OBJ_GetDesc:
 785              	.LFB184:
 477:../SSC/Src/objdef.c **** 
 478:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 479:../SSC/Src/objdef.c **** /**
 480:../SSC/Src/objdef.c ****  \param     index     Indicates the index of the dictionary object.
 481:../SSC/Src/objdef.c ****  \param  	subindex  Indicates the subindex of the dictionary object.
 482:../SSC/Src/objdef.c ****                         Subindex 0xff returns the description of the whole object ( the name of
 483:../SSC/Src/objdef.c ****                         the object ).
 484:../SSC/Src/objdef.c ****                         Subindex 0x00 returns the description of the subindex 0 and so on.
 485:../SSC/Src/objdef.c ****  \param     pObjEntry Is a handle to the dictionary object ( for faster access ) or NULL.						
 486:../SSC/Src/objdef.c ****  \param    pData        Is the memory field for the description string or NULL ( if the size of
 487:../SSC/Src/objdef.c ****                         string is unknown ):
 488:../SSC/Src/objdef.c **** 
 489:../SSC/Src/objdef.c ****  \return    The size in bytes of the description string (without null termination byte ).
 490:../SSC/Src/objdef.c ****             0 will be returned if a description for the indicated entry was not found.
 491:../SSC/Src/objdef.c **** 
 492:../SSC/Src/objdef.c ****  \brief    The function returns size and description string of the requested entry.
 493:../SSC/Src/objdef.c **** 
 494:../SSC/Src/objdef.c ****             Its possible to define all description strings of one entry ( including the name
 495:../SSC/Src/objdef.c ****             of the object ) in one structure:        <br>
 496:../SSC/Src/objdef.c ****             {                                                    <br>
 497:../SSC/Src/objdef.c ****                 name_of_object with index,              <br>
 498:../SSC/Src/objdef.c ****                 description_of_subindex0,                <br>
 499:../SSC/Src/objdef.c ****                 .                                                <br>
 500:../SSC/Src/objdef.c ****                 description_of_subindexN,                <br>
 501:../SSC/Src/objdef.c ****                 0xFF                                            <br>
 502:../SSC/Src/objdef.c ****             }
 503:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 504:../SSC/Src/objdef.c **** 
 505:../SSC/Src/objdef.c **** UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXME
 506:../SSC/Src/objdef.c **** {
 786              	 .loc 1 506 0
 787              	 .cfi_startproc
 788              	 
 789              	 
 790 0000 90B5     	 push {r4,r7,lr}
 791              	.LCFI27:
 792              	 .cfi_def_cfa_offset 12
 793              	 .cfi_offset 4,-12
 794              	 .cfi_offset 7,-8
 795              	 .cfi_offset 14,-4
 796 0002 8DB0     	 sub sp,sp,#52
 797              	.LCFI28:
 798              	 .cfi_def_cfa_offset 64
 799 0004 00AF     	 add r7,sp,#0
 800              	.LCFI29:
 801              	 .cfi_def_cfa_register 7
 802 0006 BA60     	 str r2,[r7,#8]
 803 0008 7B60     	 str r3,[r7,#4]
 804 000a 0346     	 mov r3,r0
 805 000c FB81     	 strh r3,[r7,#14]
 806 000e 0B46     	 mov r3,r1
 807 0010 7B73     	 strb r3,[r7,#13]
 507:../SSC/Src/objdef.c ****     UINT16 strSize = 0;
 808              	 .loc 1 507 0
 809 0012 0023     	 movs r3,#0
 810 0014 FB85     	 strh r3,[r7,#46]
 508:../SSC/Src/objdef.c ****     OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
 811              	 .loc 1 508 0
 812 0016 BB68     	 ldr r3,[r7,#8]
 813 0018 5B69     	 ldr r3,[r3,#20]
 814 001a 7B62     	 str r3,[r7,#36]
 509:../SSC/Src/objdef.c **** /* get the information of ObjCode and MaxSubindex in local variables to support different types of 
 510:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 815              	 .loc 1 510 0
 816 001c BB68     	 ldr r3,[r7,#8]
 817 001e 9B89     	 ldrh r3,[r3,#12]
 818 0020 03F47063 	 and r3,r3,#3840
 819 0024 1B12     	 asrs r3,r3,#8
 820 0026 87F82330 	 strb r3,[r7,#35]
 511:../SSC/Src/objdef.c **** 
 512:../SSC/Src/objdef.c **** 
 513:../SSC/Src/objdef.c **** 
 514:../SSC/Src/objdef.c ****     if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
 821              	 .loc 1 514 0
 822 002a 7B7B     	 ldrb r3,[r7,#13]
 823 002c 002B     	 cmp r3,#0
 824 002e 03D0     	 beq .L49
 825              	 .loc 1 514 0 is_stmt 0 discriminator 1
 826 0030 97F82330 	 ldrb r3,[r7,#35]
 827 0034 072B     	 cmp r3,#7
 828 0036 0FD1     	 bne .L50
 829              	.L49:
 515:../SSC/Src/objdef.c ****     {
 516:../SSC/Src/objdef.c ****         // Get object description length
 517:../SSC/Src/objdef.c ****        strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pDesc);
 830              	 .loc 1 517 0 is_stmt 1
 831 0038 786A     	 ldr r0,[r7,#36]
 832 003a FFF7FEFF 	 bl strlen
 833 003e 0346     	 mov r3,r0
 834 0040 FB85     	 strh r3,[r7,#46]
 518:../SSC/Src/objdef.c **** 
 519:../SSC/Src/objdef.c ****         // If there is a pointer given, copy data:
 520:../SSC/Src/objdef.c ****         if ( pData )
 835              	 .loc 1 520 0
 836 0042 7B68     	 ldr r3,[r7,#4]
 837 0044 002B     	 cmp r3,#0
 838 0046 06D0     	 beq .L51
 521:../SSC/Src/objdef.c ****         {
 522:../SSC/Src/objdef.c ****             OBJTOMBXSTRCPY( pData, pDesc, strSize );
 839              	 .loc 1 522 0
 840 0048 FB8D     	 ldrh r3,[r7,#46]
 841 004a 7868     	 ldr r0,[r7,#4]
 842 004c 796A     	 ldr r1,[r7,#36]
 843 004e 1A46     	 mov r2,r3
 844 0050 FFF7FEFF 	 bl memcpy
 520:../SSC/Src/objdef.c ****         {
 845              	 .loc 1 520 0
 846 0054 5DE0     	 b .L52
 847              	.L51:
 848 0056 5CE0     	 b .L52
 849              	.L50:
 523:../SSC/Src/objdef.c ****         }
 524:../SSC/Src/objdef.c ****     }
 525:../SSC/Src/objdef.c ****     else
 526:../SSC/Src/objdef.c ****     {
 527:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_REC )
 850              	 .loc 1 527 0
 851 0058 97F82330 	 ldrb r3,[r7,#35]
 852 005c 092B     	 cmp r3,#9
 853 005e 3AD1     	 bne .L53
 854              	.LBB7:
 528:../SSC/Src/objdef.c ****         {
 529:../SSC/Src/objdef.c ****             {
 530:../SSC/Src/objdef.c ****             // get pointer to description of subindex 1 :
 531:../SSC/Src/objdef.c ****             // 16bit variable to avoid overflow if subindex 0xFF is read
 532:../SSC/Src/objdef.c ****             UINT16 i = 1;
 855              	 .loc 1 532 0
 856 0060 0123     	 movs r3,#1
 857 0062 BB85     	 strh r3,[r7,#44]
 533:../SSC/Src/objdef.c ****             UINT16 tmpSubindex = subindex;
 858              	 .loc 1 533 0
 859 0064 7B7B     	 ldrb r3,[r7,#13]
 860 0066 3B84     	 strh r3,[r7,#32]
 861              	.LBB8:
 534:../SSC/Src/objdef.c **** 
 535:../SSC/Src/objdef.c ****             {
 536:../SSC/Src/objdef.c **** 
 537:../SSC/Src/objdef.c ****             OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
 862              	 .loc 1 537 0
 863 0068 786A     	 ldr r0,[r7,#36]
 864 006a FFF7FEFF 	 bl strlen
 865 006e 0346     	 mov r3,r0
 866 0070 0133     	 adds r3,r3,#1
 867 0072 7A6A     	 ldr r2,[r7,#36]
 868 0074 1344     	 add r3,r3,r2
 869 0076 BB62     	 str r3,[r7,#40]
 538:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.12) COE10*/
 539:../SSC/Src/objdef.c ****             while (( i <= tmpSubindex )
 870              	 .loc 1 539 0
 871 0078 21E0     	 b .L54
 872              	.L57:
 540:../SSC/Src/objdef.c ****                 &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE && pSubDesc[0] != 0xFFFF))
 541:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.12) COE10*/
 542:../SSC/Src/objdef.c ****             {
 543:../SSC/Src/objdef.c ****                 if ( i == tmpSubindex )
 873              	 .loc 1 543 0
 874 007a BA8D     	 ldrh r2,[r7,#44]
 875 007c 3B8C     	 ldrh r3,[r7,#32]
 876 007e 9A42     	 cmp r2,r3
 877 0080 12D1     	 bne .L55
 544:../SSC/Src/objdef.c ****                 {
 545:../SSC/Src/objdef.c ****                    strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
 878              	 .loc 1 545 0
 879 0082 B86A     	 ldr r0,[r7,#40]
 880 0084 FFF7FEFF 	 bl strlen
 881 0088 0346     	 mov r3,r0
 882 008a FB85     	 strh r3,[r7,#46]
 546:../SSC/Src/objdef.c ****                     if ( pData && strSize )
 883              	 .loc 1 546 0
 884 008c 7B68     	 ldr r3,[r7,#4]
 885 008e 002B     	 cmp r3,#0
 886 0090 09D0     	 beq .L56
 887              	 .loc 1 546 0 is_stmt 0 discriminator 1
 888 0092 FB8D     	 ldrh r3,[r7,#46]
 889 0094 002B     	 cmp r3,#0
 890 0096 06D0     	 beq .L56
 547:../SSC/Src/objdef.c ****                     {
 548:../SSC/Src/objdef.c ****                         OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
 891              	 .loc 1 548 0 is_stmt 1
 892 0098 FB8D     	 ldrh r3,[r7,#46]
 893 009a 7868     	 ldr r0,[r7,#4]
 894 009c B96A     	 ldr r1,[r7,#40]
 895 009e 1A46     	 mov r2,r3
 896 00a0 FFF7FEFF 	 bl memcpy
 549:../SSC/Src/objdef.c ****                     }
 550:../SSC/Src/objdef.c ****                     break;
 897              	 .loc 1 550 0
 898 00a4 17E0     	 b .L53
 899              	.L56:
 900 00a6 16E0     	 b .L53
 901              	.L55:
 551:../SSC/Src/objdef.c ****                 }
 552:../SSC/Src/objdef.c ****                 else
 553:../SSC/Src/objdef.c ****                 {
 554:../SSC/Src/objdef.c ****                     i++;
 902              	 .loc 1 554 0
 903 00a8 BB8D     	 ldrh r3,[r7,#44]
 904 00aa 0133     	 adds r3,r3,#1
 905 00ac BB85     	 strh r3,[r7,#44]
 555:../SSC/Src/objdef.c ****                     pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
 906              	 .loc 1 555 0
 907 00ae B86A     	 ldr r0,[r7,#40]
 908 00b0 FFF7FEFF 	 bl strlen
 909 00b4 0346     	 mov r3,r0
 910 00b6 0133     	 adds r3,r3,#1
 911 00b8 BA6A     	 ldr r2,[r7,#40]
 912 00ba 1344     	 add r3,r3,r2
 913 00bc BB62     	 str r3,[r7,#40]
 914              	.L54:
 539:../SSC/Src/objdef.c ****                 &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE && pSubDesc[0] != 0xFFFF))
 915              	 .loc 1 539 0
 916 00be BA8D     	 ldrh r2,[r7,#44]
 917 00c0 3B8C     	 ldrh r3,[r7,#32]
 918 00c2 9A42     	 cmp r2,r3
 919 00c4 07D8     	 bhi .L53
 540:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.12) COE10*/
 920              	 .loc 1 540 0
 921 00c6 BB6A     	 ldr r3,[r7,#40]
 922 00c8 1B78     	 ldrb r3,[r3]
 923 00ca FF2B     	 cmp r3,#255
 924 00cc 03D0     	 beq .L53
 540:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.12) COE10*/
 925              	 .loc 1 540 0 is_stmt 0 discriminator 1
 926 00ce BB6A     	 ldr r3,[r7,#40]
 927 00d0 1B78     	 ldrb r3,[r3]
 928 00d2 FE2B     	 cmp r3,#254
 929 00d4 D1D1     	 bne .L57
 930              	.L53:
 931              	.LBE8:
 932              	.LBE7:
 556:../SSC/Src/objdef.c ****                 }
 557:../SSC/Src/objdef.c ****             }
 558:../SSC/Src/objdef.c ****             }
 559:../SSC/Src/objdef.c ****             }
 560:../SSC/Src/objdef.c ****         }
 561:../SSC/Src/objdef.c **** 
 562:../SSC/Src/objdef.c ****         if ( strSize == 0 )
 933              	 .loc 1 562 0 is_stmt 1
 934 00d6 FB8D     	 ldrh r3,[r7,#46]
 935 00d8 002B     	 cmp r3,#0
 936 00da 1AD1     	 bne .L52
 563:../SSC/Src/objdef.c ****         {
 564:../SSC/Src/objdef.c ****             // no string found for subindex x -> name is Subindex x
 565:../SSC/Src/objdef.c ****             strSize =    12;
 937              	 .loc 1 565 0
 938 00dc 0C23     	 movs r3,#12
 939 00de FB85     	 strh r3,[r7,#46]
 566:../SSC/Src/objdef.c **** 
 567:../SSC/Src/objdef.c ****             if ( pData )
 940              	 .loc 1 567 0
 941 00e0 7B68     	 ldr r3,[r7,#4]
 942 00e2 002B     	 cmp r3,#0
 943 00e4 15D0     	 beq .L52
 944              	.LBB9:
 568:../SSC/Src/objdef.c ****             {
 569:../SSC/Src/objdef.c ****                 UCHAR OBJMEM         TmpDescr[13];
 570:../SSC/Src/objdef.c ****                 OBJSTRCPY(TmpDescr,aSubindexDesc,SIZEOF(TmpDescr));
 945              	 .loc 1 570 0
 946 00e6 0D4B     	 ldr r3,.L59
 947 00e8 07F11004 	 add r4,r7,#16
 948 00ec 0FCB     	 ldmia r3,{r0,r1,r2,r3}
 949 00ee 07C4     	 stmia r4!,{r0,r1,r2}
 950 00f0 2370     	 strb r3,[r4]
 571:../SSC/Src/objdef.c ****                 
 572:../SSC/Src/objdef.c ****                 OBJ_CopyNumberToString( &TmpDescr[9], subindex );
 951              	 .loc 1 572 0
 952 00f2 07F11003 	 add r3,r7,#16
 953 00f6 03F10902 	 add r2,r3,#9
 954 00fa 7B7B     	 ldrb r3,[r7,#13]
 955 00fc 1046     	 mov r0,r2
 956 00fe 1946     	 mov r1,r3
 957 0100 FFF7FEFF 	 bl OBJ_CopyNumberToString
 573:../SSC/Src/objdef.c ****                 MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
 958              	 .loc 1 573 0
 959 0104 07F11003 	 add r3,r7,#16
 960 0108 7868     	 ldr r0,[r7,#4]
 961 010a 1946     	 mov r1,r3
 962 010c 0D22     	 movs r2,#13
 963 010e FFF7FEFF 	 bl memcpy
 964              	.L52:
 965              	.LBE9:
 574:../SSC/Src/objdef.c ****             }
 575:../SSC/Src/objdef.c ****         }
 576:../SSC/Src/objdef.c ****     }
 577:../SSC/Src/objdef.c **** 
 578:../SSC/Src/objdef.c ****     return strSize;
 966              	 .loc 1 578 0
 967 0112 FB8D     	 ldrh r3,[r7,#46]
 579:../SSC/Src/objdef.c **** }
 968              	 .loc 1 579 0
 969 0114 1846     	 mov r0,r3
 970 0116 3437     	 adds r7,r7,#52
 971              	.LCFI30:
 972              	 .cfi_def_cfa_offset 12
 973 0118 BD46     	 mov sp,r7
 974              	.LCFI31:
 975              	 .cfi_def_cfa_register 13
 976              	 
 977 011a 90BD     	 pop {r4,r7,pc}
 978              	.L60:
 979              	 .align 2
 980              	.L59:
 981 011c 00000000 	 .word aSubindexDesc
 982              	 .cfi_endproc
 983              	.LFE184:
 985              	 .section .text.OBJ_GetEntryDesc,"ax",%progbits
 986              	 .align 2
 987              	 .global OBJ_GetEntryDesc
 988              	 .thumb
 989              	 .thumb_func
 991              	OBJ_GetEntryDesc:
 992              	.LFB185:
 580:../SSC/Src/objdef.c **** 
 581:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 582:../SSC/Src/objdef.c **** /**
 583:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 584:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 585:../SSC/Src/objdef.c ****  \param     Subindex                subindex of the requested object.
 586:../SSC/Src/objdef.c **** 
 587:../SSC/Src/objdef.c ****  \return    Pointer to the EntryDesc of the Subindex
 588:../SSC/Src/objdef.c **** 
 589:../SSC/Src/objdef.c ****  \brief    The function returns the Entry-Desc of a subindex to allow the application
 590:../SSC/Src/objdef.c ****          to define the object dictionary independent of the sdoserv-files
 591:../SSC/Src/objdef.c **** 
 592:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 593:../SSC/Src/objdef.c **** 
 594:../SSC/Src/objdef.c **** OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Sub
 595:../SSC/Src/objdef.c **** {
 993              	 .loc 1 595 0
 994              	 .cfi_startproc
 995              	 
 996              	 
 997              	 
 998 0000 80B4     	 push {r7}
 999              	.LCFI32:
 1000              	 .cfi_def_cfa_offset 4
 1001              	 .cfi_offset 7,-4
 1002 0002 85B0     	 sub sp,sp,#20
 1003              	.LCFI33:
 1004              	 .cfi_def_cfa_offset 24
 1005 0004 00AF     	 add r7,sp,#0
 1006              	.LCFI34:
 1007              	 .cfi_def_cfa_register 7
 1008 0006 7860     	 str r0,[r7,#4]
 1009 0008 0B46     	 mov r3,r1
 1010 000a FB70     	 strb r3,[r7,#3]
 596:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
 597:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 1011              	 .loc 1 597 0
 1012 000c 7B68     	 ldr r3,[r7,#4]
 1013 000e 9B89     	 ldrh r3,[r3,#12]
 1014 0010 03F47063 	 and r3,r3,#3840
 1015 0014 1B12     	 asrs r3,r3,#8
 1016 0016 FB72     	 strb r3,[r7,#11]
 598:../SSC/Src/objdef.c **** 
 599:../SSC/Src/objdef.c ****     if ((objCode == OBJCODE_ARR)
 1017              	 .loc 1 599 0
 1018 0018 FB7A     	 ldrb r3,[r7,#11]
 1019 001a 082B     	 cmp r3,#8
 1020 001c 0BD1     	 bne .L62
 600:../SSC/Src/objdef.c ****         )
 601:../SSC/Src/objdef.c ****     {
 602:../SSC/Src/objdef.c ****         /* object is an array */
 603:../SSC/Src/objdef.c ****         if ( Subindex == 0 )
 1021              	 .loc 1 603 0
 1022 001e FB78     	 ldrb r3,[r7,#3]
 1023 0020 002B     	 cmp r3,#0
 1024 0022 03D1     	 bne .L63
 604:../SSC/Src/objdef.c ****         {
 605:../SSC/Src/objdef.c ****             /* subindex 0 has a description */
 606:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[0];
 1025              	 .loc 1 606 0
 1026 0024 7B68     	 ldr r3,[r7,#4]
 1027 0026 1B69     	 ldr r3,[r3,#16]
 1028 0028 FB60     	 str r3,[r7,#12]
 1029 002a 0DE0     	 b .L65
 1030              	.L63:
 607:../SSC/Src/objdef.c ****         }
 608:../SSC/Src/objdef.c ****         else
 609:../SSC/Src/objdef.c ****         {
 610:../SSC/Src/objdef.c ****             /* and all other elements have the same description */
 611:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[1];
 1031              	 .loc 1 611 0
 1032 002c 7B68     	 ldr r3,[r7,#4]
 1033 002e 1B69     	 ldr r3,[r3,#16]
 1034 0030 0633     	 adds r3,r3,#6
 1035 0032 FB60     	 str r3,[r7,#12]
 1036 0034 08E0     	 b .L65
 1037              	.L62:
 612:../SSC/Src/objdef.c ****         }
 613:../SSC/Src/objdef.c ****     }
 614:../SSC/Src/objdef.c ****     else
 615:../SSC/Src/objdef.c ****     {
 616:../SSC/Src/objdef.c ****         {
 617:../SSC/Src/objdef.c ****             /* object is a variable or a record return the corresponding entry */
 618:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[Subindex];
 1038              	 .loc 1 618 0
 1039 0036 7B68     	 ldr r3,[r7,#4]
 1040 0038 1969     	 ldr r1,[r3,#16]
 1041 003a FA78     	 ldrb r2,[r7,#3]
 1042 003c 1346     	 mov r3,r2
 1043 003e 5B00     	 lsls r3,r3,#1
 1044 0040 1344     	 add r3,r3,r2
 1045 0042 5B00     	 lsls r3,r3,#1
 1046 0044 0B44     	 add r3,r3,r1
 1047 0046 FB60     	 str r3,[r7,#12]
 1048              	.L65:
 619:../SSC/Src/objdef.c ****         }
 620:../SSC/Src/objdef.c ****     }
 621:../SSC/Src/objdef.c **** 
 622:../SSC/Src/objdef.c ****     return pEntry;
 1049              	 .loc 1 622 0
 1050 0048 FB68     	 ldr r3,[r7,#12]
 623:../SSC/Src/objdef.c **** }
 1051              	 .loc 1 623 0
 1052 004a 1846     	 mov r0,r3
 1053 004c 1437     	 adds r7,r7,#20
 1054              	.LCFI35:
 1055              	 .cfi_def_cfa_offset 4
 1056 004e BD46     	 mov sp,r7
 1057              	.LCFI36:
 1058              	 .cfi_def_cfa_register 13
 1059              	 
 1060 0050 5DF8047B 	 ldr r7,[sp],#4
 1061              	.LCFI37:
 1062              	 .cfi_restore 7
 1063              	 .cfi_def_cfa_offset 0
 1064 0054 7047     	 bx lr
 1065              	 .cfi_endproc
 1066              	.LFE185:
 1068 0056 00BF     	 .section .text.OBJ_GetObjDesc,"ax",%progbits
 1069              	 .align 2
 1070              	 .global OBJ_GetObjDesc
 1071              	 .thumb
 1072              	 .thumb_func
 1074              	OBJ_GetObjDesc:
 1075              	.LFB186:
 624:../SSC/Src/objdef.c **** 
 625:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 626:../SSC/Src/objdef.c **** /**
 627:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 628:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 629:../SSC/Src/objdef.c **** 
 630:../SSC/Src/objdef.c ****  \return    Pointer to the ObjDesc of the Object
 631:../SSC/Src/objdef.c **** 
 632:../SSC/Src/objdef.c ****  \brief    The function returns the Obj-Desc of an object to allow the application
 633:../SSC/Src/objdef.c ****          to define the object dictionary independent of the sdoserv-files
 634:../SSC/Src/objdef.c **** 
 635:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 636:../SSC/Src/objdef.c **** 
 637:../SSC/Src/objdef.c **** OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
 638:../SSC/Src/objdef.c **** {
 1076              	 .loc 1 638 0
 1077              	 .cfi_startproc
 1078              	 
 1079              	 
 1080              	 
 1081 0000 80B4     	 push {r7}
 1082              	.LCFI38:
 1083              	 .cfi_def_cfa_offset 4
 1084              	 .cfi_offset 7,-4
 1085 0002 83B0     	 sub sp,sp,#12
 1086              	.LCFI39:
 1087              	 .cfi_def_cfa_offset 16
 1088 0004 00AF     	 add r7,sp,#0
 1089              	.LCFI40:
 1090              	 .cfi_def_cfa_register 7
 1091 0006 7860     	 str r0,[r7,#4]
 639:../SSC/Src/objdef.c ****     return &pObjEntry->ObjDesc;
 1092              	 .loc 1 639 0
 1093 0008 7B68     	 ldr r3,[r7,#4]
 1094 000a 0A33     	 adds r3,r3,#10
 640:../SSC/Src/objdef.c **** }
 1095              	 .loc 1 640 0
 1096 000c 1846     	 mov r0,r3
 1097 000e 0C37     	 adds r7,r7,#12
 1098              	.LCFI41:
 1099              	 .cfi_def_cfa_offset 4
 1100 0010 BD46     	 mov sp,r7
 1101              	.LCFI42:
 1102              	 .cfi_def_cfa_register 13
 1103              	 
 1104 0012 5DF8047B 	 ldr r7,[sp],#4
 1105              	.LCFI43:
 1106              	 .cfi_restore 7
 1107              	 .cfi_def_cfa_offset 0
 1108 0016 7047     	 bx lr
 1109              	 .cfi_endproc
 1110              	.LFE186:
 1112              	 .section .text.OBJ_GetEntryOffset,"ax",%progbits
 1113              	 .align 2
 1114              	 .global OBJ_GetEntryOffset
 1115              	 .thumb
 1116              	 .thumb_func
 1118              	OBJ_GetEntryOffset:
 1119              	.LFB187:
 641:../SSC/Src/objdef.c **** 
 642:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 643:../SSC/Src/objdef.c **** /**
 644:../SSC/Src/objdef.c ****  \param     subindex                subindex of the entry
 645:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 646:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 647:../SSC/Src/objdef.c **** 
 648:../SSC/Src/objdef.c ****  \return    bit offset of the entry in the variable
 649:../SSC/Src/objdef.c **** 
 650:../SSC/Src/objdef.c ****  \brief    This function calculates the bit offset of the entry in the object's variable
 651:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 652:../SSC/Src/objdef.c **** 
 653:../SSC/Src/objdef.c **** UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
 654:../SSC/Src/objdef.c **** {
 1120              	 .loc 1 654 0
 1121              	 .cfi_startproc
 1122              	 
 1123              	 
 1124              	 
 1125 0000 80B4     	 push {r7}
 1126              	.LCFI44:
 1127              	 .cfi_def_cfa_offset 4
 1128              	 .cfi_offset 7,-4
 1129 0002 87B0     	 sub sp,sp,#28
 1130              	.LCFI45:
 1131              	 .cfi_def_cfa_offset 32
 1132 0004 00AF     	 add r7,sp,#0
 1133              	.LCFI46:
 1134              	 .cfi_def_cfa_register 7
 1135 0006 0346     	 mov r3,r0
 1136 0008 3960     	 str r1,[r7]
 1137 000a FB71     	 strb r3,[r7,#7]
 655:../SSC/Src/objdef.c ****     UINT16 i;
 656:../SSC/Src/objdef.c ****     /* bitOffset will be initialized with the bit offset of subindex 1 */
 657:../SSC/Src/objdef.c ****     UINT16 bitOffset = 0;
 1138              	 .loc 1 657 0
 1139 000c 0023     	 movs r3,#0
 1140 000e BB82     	 strh r3,[r7,#20]
 658:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 1141              	 .loc 1 658 0
 1142 0010 3B68     	 ldr r3,[r7]
 1143 0012 9B89     	 ldrh r3,[r3,#12]
 1144 0014 03F47063 	 and r3,r3,#3840
 1145 0018 1B12     	 asrs r3,r3,#8
 1146 001a FB73     	 strb r3,[r7,#15]
 659:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
 660:../SSC/Src/objdef.c **** 
 661:../SSC/Src/objdef.c ****     
 662:../SSC/Src/objdef.c ****     if(subindex > 0)
 1147              	 .loc 1 662 0
 1148 001c FB79     	 ldrb r3,[r7,#7]
 1149 001e 002B     	 cmp r3,#0
 1150 0020 02D0     	 beq .L70
 663:../SSC/Src/objdef.c ****     {
 664:../SSC/Src/objdef.c ****         /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
 665:../SSC/Src/objdef.c ****         bitOffset +=16;
 1151              	 .loc 1 665 0
 1152 0022 BB8A     	 ldrh r3,[r7,#20]
 1153 0024 1033     	 adds r3,r3,#16
 1154 0026 BB82     	 strh r3,[r7,#20]
 1155              	.L70:
 666:../SSC/Src/objdef.c ****     }
 667:../SSC/Src/objdef.c **** 
 668:../SSC/Src/objdef.c ****     if (objCode == OBJCODE_VAR)
 1156              	 .loc 1 668 0
 1157 0028 FB7B     	 ldrb r3,[r7,#15]
 1158 002a 072B     	 cmp r3,#7
 1159 002c 01D1     	 bne .L71
 669:../SSC/Src/objdef.c ****     {
 670:../SSC/Src/objdef.c ****         return 0;
 1160              	 .loc 1 670 0
 1161 002e 0023     	 movs r3,#0
 1162 0030 91E0     	 b .L72
 1163              	.L71:
 671:../SSC/Src/objdef.c ****     }
 672:../SSC/Src/objdef.c **** 
 673:../SSC/Src/objdef.c ****     for (i = 1; i <= subindex; i++)
 1164              	 .loc 1 673 0
 1165 0032 0123     	 movs r3,#1
 1166 0034 FB82     	 strh r3,[r7,#22]
 1167 0036 87E0     	 b .L73
 1168              	.L90:
 674:../SSC/Src/objdef.c ****     {
 675:../SSC/Src/objdef.c ****         /* get the entry description */
 676:../SSC/Src/objdef.c ****         if ((objCode == OBJCODE_ARR)
 1169              	 .loc 1 676 0
 1170 0038 FB7B     	 ldrb r3,[r7,#15]
 1171 003a 082B     	 cmp r3,#8
 1172 003c 04D1     	 bne .L74
 677:../SSC/Src/objdef.c ****            )
 678:../SSC/Src/objdef.c ****            {
 679:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[1];
 1173              	 .loc 1 679 0
 1174 003e 3B68     	 ldr r3,[r7]
 1175 0040 1B69     	 ldr r3,[r3,#16]
 1176 0042 0633     	 adds r3,r3,#6
 1177 0044 3B61     	 str r3,[r7,#16]
 1178 0046 08E0     	 b .L75
 1179              	.L74:
 680:../SSC/Src/objdef.c ****            }
 681:../SSC/Src/objdef.c ****         else
 682:../SSC/Src/objdef.c ****         {
 683:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[i];
 1180              	 .loc 1 683 0
 1181 0048 3B68     	 ldr r3,[r7]
 1182 004a 1969     	 ldr r1,[r3,#16]
 1183 004c FA8A     	 ldrh r2,[r7,#22]
 1184 004e 1346     	 mov r3,r2
 1185 0050 5B00     	 lsls r3,r3,#1
 1186 0052 1344     	 add r3,r3,r2
 1187 0054 5B00     	 lsls r3,r3,#1
 1188 0056 0B44     	 add r3,r3,r1
 1189 0058 3B61     	 str r3,[r7,#16]
 1190              	.L75:
 684:../SSC/Src/objdef.c ****         }
 685:../SSC/Src/objdef.c **** 
 686:../SSC/Src/objdef.c ****         switch (pEntry->DataType)
 1191              	 .loc 1 686 0
 1192 005a 3B69     	 ldr r3,[r7,#16]
 1193 005c 1B88     	 ldrh r3,[r3]
 1194 005e 1F2B     	 cmp r3,#31
 1195 0060 23D0     	 beq .L77
 1196 0062 1F2B     	 cmp r3,#31
 1197 0064 0DDC     	 bgt .L78
 1198 0066 062B     	 cmp r3,#6
 1199 0068 1FD0     	 beq .L77
 1200 006a 062B     	 cmp r3,#6
 1201 006c 04DC     	 bgt .L79
 1202 006e 032B     	 cmp r3,#3
 1203 0070 1BD0     	 beq .L77
 1204 0072 042B     	 cmp r3,#4
 1205 0074 37D0     	 beq .L80
 1206 0076 58E0     	 b .L76
 1207              	.L79:
 1208 0078 082B     	 cmp r3,#8
 1209 007a 34DD     	 ble .L80
 1210 007c 0B2B     	 cmp r3,#11
 1211 007e 14D0     	 beq .L77
 1212 0080 53E0     	 b .L76
 1213              	.L78:
 1214 0082 2F2B     	 cmp r3,#47
 1215 0084 2FD0     	 beq .L80
 1216 0086 2F2B     	 cmp r3,#47
 1217 0088 04DC     	 bgt .L81
 1218 008a 202B     	 cmp r3,#32
 1219 008c 2BD0     	 beq .L80
 1220 008e 2E2B     	 cmp r3,#46
 1221 0090 0BD0     	 beq .L77
 1222 0092 4AE0     	 b .L76
 1223              	.L81:
 1224 0094 B3F5187F 	 cmp r3,#608
 1225 0098 07D0     	 beq .L77
 1226 009a B3F5187F 	 cmp r3,#608
 1227 009e 44DB     	 blt .L76
 1228 00a0 A3F26223 	 subw r3,r3,#610
 1229 00a4 012B     	 cmp r3,#1
 1230 00a6 40D8     	 bhi .L76
 1231 00a8 1DE0     	 b .L80
 1232              	.L77:
 687:../SSC/Src/objdef.c ****         {
 688:../SSC/Src/objdef.c ****         case    DEFTYPE_INTEGER16:
 689:../SSC/Src/objdef.c ****         case    DEFTYPE_UNSIGNED16:
 690:../SSC/Src/objdef.c ****         case    DEFTYPE_BITARR16:
 691:../SSC/Src/objdef.c ****         case    DEFTYPE_WORD:
 692:../SSC/Src/objdef.c ****         case    DEFTYPE_UNICODE_STRING:
 693:../SSC/Src/objdef.c ****         case    DEFTYPE_ARRAY_OF_INT :
 694:../SSC/Src/objdef.c **** 
 695:../SSC/Src/objdef.c **** #if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
 696:../SSC/Src/objdef.c ****             /* the 16-bit variables in the structure are word-aligned,
 697:../SSC/Src/objdef.c ****                align the actual bitOffset to a word */
 698:../SSC/Src/objdef.c ****             bitOffset = (bitOffset+15) & 0xFFF0;
 1233              	 .loc 1 698 0
 1234 00aa BB8A     	 ldrh r3,[r7,#20]
 1235 00ac 0F33     	 adds r3,r3,#15
 1236 00ae 9BB2     	 uxth r3,r3
 1237 00b0 23F00F03 	 bic r3,r3,#15
 1238 00b4 BB82     	 strh r3,[r7,#20]
 699:../SSC/Src/objdef.c **** #endif
 700:../SSC/Src/objdef.c **** 
 701:../SSC/Src/objdef.c **** 
 702:../SSC/Src/objdef.c ****             if (i < subindex)
 1239              	 .loc 1 702 0
 1240 00b6 FB79     	 ldrb r3,[r7,#7]
 1241 00b8 9BB2     	 uxth r3,r3
 1242 00ba FA8A     	 ldrh r2,[r7,#22]
 1243 00bc 9A42     	 cmp r2,r3
 1244 00be 11D2     	 bcs .L82
 703:../SSC/Src/objdef.c ****             {
 704:../SSC/Src/objdef.c ****                 if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
 1245              	 .loc 1 704 0
 1246 00c0 3B69     	 ldr r3,[r7,#16]
 1247 00c2 1B88     	 ldrh r3,[r3]
 1248 00c4 0B2B     	 cmp r3,#11
 1249 00c6 04D0     	 beq .L83
 705:../SSC/Src/objdef.c ****                     ||(pEntry->DataType == DEFTYPE_ARRAY_OF_INT))
 1250              	 .loc 1 705 0
 1251 00c8 3B69     	 ldr r3,[r7,#16]
 1252 00ca 1B88     	 ldrh r3,[r3]
 1253 00cc B3F5187F 	 cmp r3,#608
 1254 00d0 04D1     	 bne .L84
 1255              	.L83:
 706:../SSC/Src/objdef.c ****                 {
 707:../SSC/Src/objdef.c ****                     bitOffset += pEntry->BitLength;
 1256              	 .loc 1 707 0
 1257 00d2 3B69     	 ldr r3,[r7,#16]
 1258 00d4 5A88     	 ldrh r2,[r3,#2]
 1259 00d6 BB8A     	 ldrh r3,[r7,#20]
 1260 00d8 1344     	 add r3,r3,r2
 1261 00da BB82     	 strh r3,[r7,#20]
 1262              	.L84:
 708:../SSC/Src/objdef.c ****                 }
 709:../SSC/Src/objdef.c **** 
 710:../SSC/Src/objdef.c ****                 bitOffset += 16;
 1263              	 .loc 1 710 0
 1264 00dc BB8A     	 ldrh r3,[r7,#20]
 1265 00de 1033     	 adds r3,r3,#16
 1266 00e0 BB82     	 strh r3,[r7,#20]
 711:../SSC/Src/objdef.c ****             }
 712:../SSC/Src/objdef.c ****             break;
 1267              	 .loc 1 712 0
 1268 00e2 2EE0     	 b .L85
 1269              	.L82:
 1270 00e4 2DE0     	 b .L85
 1271              	.L80:
 713:../SSC/Src/objdef.c ****         case    DEFTYPE_UNSIGNED32:
 714:../SSC/Src/objdef.c ****         case    DEFTYPE_INTEGER32:
 715:../SSC/Src/objdef.c ****         case    DEFTYPE_REAL32:
 716:../SSC/Src/objdef.c ****         case    DEFTYPE_BITARR32:
 717:../SSC/Src/objdef.c ****         case    DEFTYPE_DWORD:
 718:../SSC/Src/objdef.c ****         case    DEFTYPE_ARRAY_OF_DINT :
 719:../SSC/Src/objdef.c ****         case    DEFTYPE_ARRAY_OF_UDINT:
 720:../SSC/Src/objdef.c **** #if OBJ_DWORD_ALIGN
 721:../SSC/Src/objdef.c ****             /* the 32-bit variables in the structure are dword-aligned,
 722:../SSC/Src/objdef.c ****                align the actual bitOffset to a dword */
 723:../SSC/Src/objdef.c ****             bitOffset = (bitOffset+31) & 0xFFE0;
 1272              	 .loc 1 723 0
 1273 00e6 BB8A     	 ldrh r3,[r7,#20]
 1274 00e8 1F33     	 adds r3,r3,#31
 1275 00ea 9BB2     	 uxth r3,r3
 1276 00ec 23F01F03 	 bic r3,r3,#31
 1277 00f0 BB82     	 strh r3,[r7,#20]
 724:../SSC/Src/objdef.c **** #elif OBJ_WORD_ALIGN
 725:../SSC/Src/objdef.c ****             /* the 32-bit variables in the structure are word-aligned,
 726:../SSC/Src/objdef.c ****                align the actual bitOffset to a word */
 727:../SSC/Src/objdef.c ****             bitOffset = (bitOffset+15) & 0xFFF0;
 728:../SSC/Src/objdef.c **** #endif
 729:../SSC/Src/objdef.c **** 
 730:../SSC/Src/objdef.c ****             if (i < subindex)
 1278              	 .loc 1 730 0
 1279 00f2 FB79     	 ldrb r3,[r7,#7]
 1280 00f4 9BB2     	 uxth r3,r3
 1281 00f6 FA8A     	 ldrh r2,[r7,#22]
 1282 00f8 9A42     	 cmp r2,r3
 1283 00fa 15D2     	 bcs .L86
 731:../SSC/Src/objdef.c ****             {
 732:../SSC/Src/objdef.c ****                 if((pEntry->DataType == DEFTYPE_ARRAY_OF_DINT)
 1284              	 .loc 1 732 0
 1285 00fc 3B69     	 ldr r3,[r7,#16]
 1286 00fe 1B88     	 ldrh r3,[r3]
 1287 0100 40F26222 	 movw r2,#610
 1288 0104 9342     	 cmp r3,r2
 1289 0106 05D0     	 beq .L87
 733:../SSC/Src/objdef.c ****                     ||(pEntry->DataType == DEFTYPE_ARRAY_OF_UDINT))
 1290              	 .loc 1 733 0
 1291 0108 3B69     	 ldr r3,[r7,#16]
 1292 010a 1B88     	 ldrh r3,[r3]
 1293 010c 40F26322 	 movw r2,#611
 1294 0110 9342     	 cmp r3,r2
 1295 0112 05D1     	 bne .L88
 1296              	.L87:
 734:../SSC/Src/objdef.c ****                 {
 735:../SSC/Src/objdef.c ****                     bitOffset += pEntry->BitLength;
 1297              	 .loc 1 735 0
 1298 0114 3B69     	 ldr r3,[r7,#16]
 1299 0116 5A88     	 ldrh r2,[r3,#2]
 1300 0118 BB8A     	 ldrh r3,[r7,#20]
 1301 011a 1344     	 add r3,r3,r2
 1302 011c BB82     	 strh r3,[r7,#20]
 1303 011e 03E0     	 b .L86
 1304              	.L88:
 736:../SSC/Src/objdef.c ****                 }
 737:../SSC/Src/objdef.c ****                 else
 738:../SSC/Src/objdef.c ****                 {
 739:../SSC/Src/objdef.c ****                    bitOffset += 32;
 1305              	 .loc 1 739 0
 1306 0120 BB8A     	 ldrh r3,[r7,#20]
 1307 0122 2033     	 adds r3,r3,#32
 1308 0124 BB82     	 strh r3,[r7,#20]
 740:../SSC/Src/objdef.c ****                 }
 741:../SSC/Src/objdef.c ****             }
 742:../SSC/Src/objdef.c ****             break;
 1309              	 .loc 1 742 0
 1310 0126 0CE0     	 b .L85
 1311              	.L86:
 1312 0128 0BE0     	 b .L85
 1313              	.L76:
 743:../SSC/Src/objdef.c ****         default:
 744:../SSC/Src/objdef.c ****             /* align the actual bitOffset to a byte */
 745:../SSC/Src/objdef.c ****             if (i < subindex)
 1314              	 .loc 1 745 0
 1315 012a FB79     	 ldrb r3,[r7,#7]
 1316 012c 9BB2     	 uxth r3,r3
 1317 012e FA8A     	 ldrh r2,[r7,#22]
 1318 0130 9A42     	 cmp r2,r3
 1319 0132 05D2     	 bcs .L89
 746:../SSC/Src/objdef.c ****             {
 747:../SSC/Src/objdef.c ****                 bitOffset += pEntry->BitLength;
 1320              	 .loc 1 747 0
 1321 0134 3B69     	 ldr r3,[r7,#16]
 1322 0136 5A88     	 ldrh r2,[r3,#2]
 1323 0138 BB8A     	 ldrh r3,[r7,#20]
 1324 013a 1344     	 add r3,r3,r2
 1325 013c BB82     	 strh r3,[r7,#20]
 748:../SSC/Src/objdef.c ****             }
 749:../SSC/Src/objdef.c ****             break;
 1326              	 .loc 1 749 0
 1327 013e FFE7     	 b .L91
 1328              	.L89:
 1329              	.L91:
 1330 0140 00BF     	 nop
 1331              	.L85:
 673:../SSC/Src/objdef.c ****     {
 1332              	 .loc 1 673 0 discriminator 2
 1333 0142 FB8A     	 ldrh r3,[r7,#22]
 1334 0144 0133     	 adds r3,r3,#1
 1335 0146 FB82     	 strh r3,[r7,#22]
 1336              	.L73:
 673:../SSC/Src/objdef.c ****     {
 1337              	 .loc 1 673 0 is_stmt 0 discriminator 1
 1338 0148 FB79     	 ldrb r3,[r7,#7]
 1339 014a 9BB2     	 uxth r3,r3
 1340 014c FA8A     	 ldrh r2,[r7,#22]
 1341 014e 9A42     	 cmp r2,r3
 1342 0150 7FF672AF 	 bls .L90
 750:../SSC/Src/objdef.c ****         }
 751:../SSC/Src/objdef.c ****     }
 752:../SSC/Src/objdef.c **** 
 753:../SSC/Src/objdef.c ****     return bitOffset;
 1343              	 .loc 1 753 0 is_stmt 1
 1344 0154 BB8A     	 ldrh r3,[r7,#20]
 1345              	.L72:
 754:../SSC/Src/objdef.c **** }
 1346              	 .loc 1 754 0
 1347 0156 1846     	 mov r0,r3
 1348 0158 1C37     	 adds r7,r7,#28
 1349              	.LCFI47:
 1350              	 .cfi_def_cfa_offset 4
 1351 015a BD46     	 mov sp,r7
 1352              	.LCFI48:
 1353              	 .cfi_def_cfa_register 13
 1354              	 
 1355 015c 5DF8047B 	 ldr r7,[sp],#4
 1356              	.LCFI49:
 1357              	 .cfi_restore 7
 1358              	 .cfi_def_cfa_offset 0
 1359 0160 7047     	 bx lr
 1360              	 .cfi_endproc
 1361              	.LFE187:
 1363 0162 00BF     	 .section .text.CheckSyncTypeValue,"ax",%progbits
 1364              	 .align 2
 1365              	 .global CheckSyncTypeValue
 1366              	 .thumb
 1367              	 .thumb_func
 1369              	CheckSyncTypeValue:
 1370              	.LFB188:
 755:../SSC/Src/objdef.c **** 
 756:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 757:../SSC/Src/objdef.c **** /**
 758:../SSC/Src/objdef.c ****  \param     index                 index of the SyncManager Parameter object 
 759:../SSC/Src/objdef.c ****  \param     NewSyncType           New value for the Sync Type (SubIndex 1)
 760:../SSC/Src/objdef.c **** 
 761:../SSC/Src/objdef.c ****  \return    result                Result of the value validation
 762:../SSC/Src/objdef.c **** 
 763:../SSC/Src/objdef.c ****  \brief    Checks if the new Sync type value is valid
 764:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 765:../SSC/Src/objdef.c **** UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
 766:../SSC/Src/objdef.c **** {
 1371              	 .loc 1 766 0
 1372              	 .cfi_startproc
 1373              	 
 1374              	 
 1375              	 
 1376 0000 80B4     	 push {r7}
 1377              	.LCFI50:
 1378              	 .cfi_def_cfa_offset 4
 1379              	 .cfi_offset 7,-4
 1380 0002 83B0     	 sub sp,sp,#12
 1381              	.LCFI51:
 1382              	 .cfi_def_cfa_offset 16
 1383 0004 00AF     	 add r7,sp,#0
 1384              	.LCFI52:
 1385              	 .cfi_def_cfa_register 7
 1386 0006 0346     	 mov r3,r0
 1387 0008 0A46     	 mov r2,r1
 1388 000a FB80     	 strh r3,[r7,#6]
 1389 000c 1346     	 mov r3,r2
 1390 000e BB80     	 strh r3,[r7,#4]
 767:../SSC/Src/objdef.c ****     switch (NewSyncType)
 1391              	 .loc 1 767 0
 1392 0010 BB88     	 ldrh r3,[r7,#4]
 1393 0012 222B     	 cmp r3,#34
 1394 0014 00F2BB80 	 bhi .L93
 1395 0018 01A2     	 adr r2,.L95
 1396 001a 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 1397 001e 00BF     	 .p2align 2
 1398              	.L95:
 1399 0020 AD000000 	 .word .L94+1
 1400 0024 B1000000 	 .word .L96+1
 1401 0028 23010000 	 .word .L97+1
 1402 002c 59010000 	 .word .L98+1
 1403 0030 8F010000 	 .word .L93+1
 1404 0034 8F010000 	 .word .L93+1
 1405 0038 8F010000 	 .word .L93+1
 1406 003c 8F010000 	 .word .L93+1
 1407 0040 8F010000 	 .word .L93+1
 1408 0044 8F010000 	 .word .L93+1
 1409 0048 8F010000 	 .word .L93+1
 1410 004c 8F010000 	 .word .L93+1
 1411 0050 8F010000 	 .word .L93+1
 1412 0054 8F010000 	 .word .L93+1
 1413 0058 8F010000 	 .word .L93+1
 1414 005c 8F010000 	 .word .L93+1
 1415 0060 8F010000 	 .word .L93+1
 1416 0064 8F010000 	 .word .L93+1
 1417 0068 8F010000 	 .word .L93+1
 1418 006c 8F010000 	 .word .L93+1
 1419 0070 8F010000 	 .word .L93+1
 1420 0074 8F010000 	 .word .L93+1
 1421 0078 8F010000 	 .word .L93+1
 1422 007c 8F010000 	 .word .L93+1
 1423 0080 8F010000 	 .word .L93+1
 1424 0084 8F010000 	 .word .L93+1
 1425 0088 8F010000 	 .word .L93+1
 1426 008c 8F010000 	 .word .L93+1
 1427 0090 8F010000 	 .word .L93+1
 1428 0094 8F010000 	 .word .L93+1
 1429 0098 8F010000 	 .word .L93+1
 1430 009c 8F010000 	 .word .L93+1
 1431 00a0 8F010000 	 .word .L93+1
 1432 00a4 8F010000 	 .word .L93+1
 1433 00a8 FF000000 	 .word .L99+1
 1434              	 .p2align 1
 1435              	.L94:
 768:../SSC/Src/objdef.c ****     {
 769:../SSC/Src/objdef.c ****     case SYNCTYPE_FREERUN:
 770:../SSC/Src/objdef.c ****         return 0; //free run sync mode is always accepted
 1436              	 .loc 1 770 0
 1437 00ac 0023     	 movs r3,#0
 1438 00ae 6FE0     	 b .L100
 1439              	.L96:
 771:../SSC/Src/objdef.c **** 
 772:../SSC/Src/objdef.c ****     case SYNCTYPE_SM_SYNCHRON:
 773:../SSC/Src/objdef.c ****         if ((index == 0x1C32) 
 1440              	 .loc 1 773 0
 1441 00b0 FB88     	 ldrh r3,[r7,#6]
 1442 00b2 41F63242 	 movw r2,#7218
 1443 00b6 9342     	 cmp r3,r2
 1444 00b8 0BD1     	 bne .L101
 774:../SSC/Src/objdef.c ****             && (nPdOutputSize > 0) 
 1445              	 .loc 1 774 0
 1446 00ba 384B     	 ldr r3,.L108
 1447 00bc 1B88     	 ldrh r3,[r3]
 1448 00be 002B     	 cmp r3,#0
 1449 00c0 07D0     	 beq .L101
 775:../SSC/Src/objdef.c ****             && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
 1450              	 .loc 1 775 0
 1451 00c2 374B     	 ldr r3,.L108+4
 1452 00c4 9B89     	 ldrh r3,[r3,#12]
 1453 00c6 03F00203 	 and r3,r3,#2
 1454 00ca 002B     	 cmp r3,#0
 1455 00cc 01DD     	 ble .L101
 776:../SSC/Src/objdef.c ****         {
 777:../SSC/Src/objdef.c ****             /*SyncManager sync mode is supported and output process data is configured*/
 778:../SSC/Src/objdef.c ****             return 0;
 1456              	 .loc 1 778 0
 1457 00ce 0023     	 movs r3,#0
 1458 00d0 5EE0     	 b .L100
 1459              	.L101:
 779:../SSC/Src/objdef.c ****         }
 780:../SSC/Src/objdef.c ****         else
 781:../SSC/Src/objdef.c ****         if ((index == 0x1C33) 
 1460              	 .loc 1 781 0
 1461 00d2 FB88     	 ldrh r3,[r7,#6]
 1462 00d4 41F63342 	 movw r2,#7219
 1463 00d8 9342     	 cmp r3,r2
 1464 00da 0FD1     	 bne .L102
 782:../SSC/Src/objdef.c ****             && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
 1465              	 .loc 1 782 0
 1466 00dc 314B     	 ldr r3,.L108+8
 1467 00de 9B89     	 ldrh r3,[r3,#12]
 1468 00e0 03F00203 	 and r3,r3,#2
 1469 00e4 002B     	 cmp r3,#0
 1470 00e6 09DD     	 ble .L102
 783:../SSC/Src/objdef.c ****             && (nPdOutputSize == 0) 
 1471              	 .loc 1 783 0
 1472 00e8 2C4B     	 ldr r3,.L108
 1473 00ea 1B88     	 ldrh r3,[r3]
 1474 00ec 002B     	 cmp r3,#0
 1475 00ee 05D1     	 bne .L102
 784:../SSC/Src/objdef.c ****             && (nPdInputSize > 0))
 1476              	 .loc 1 784 0
 1477 00f0 2D4B     	 ldr r3,.L108+12
 1478 00f2 1B88     	 ldrh r3,[r3]
 1479 00f4 002B     	 cmp r3,#0
 1480 00f6 01D0     	 beq .L102
 785:../SSC/Src/objdef.c ****             {
 786:../SSC/Src/objdef.c ****                 /*SyncManager sync mode is supported and input only shall be configured*/
 787:../SSC/Src/objdef.c ****                 return 0;
 1481              	 .loc 1 787 0
 1482 00f8 0023     	 movs r3,#0
 1483 00fa 49E0     	 b .L100
 1484              	.L102:
 788:../SSC/Src/objdef.c ****             }
 789:../SSC/Src/objdef.c ****         break;
 1485              	 .loc 1 789 0
 1486 00fc 47E0     	 b .L93
 1487              	.L99:
 790:../SSC/Src/objdef.c **** 
 791:../SSC/Src/objdef.c ****     case SYNCTYPE_SM2_SYNCHRON:
 792:../SSC/Src/objdef.c ****         if ((index == 0x1C33) 
 1488              	 .loc 1 792 0
 1489 00fe FB88     	 ldrh r3,[r7,#6]
 1490 0100 41F63342 	 movw r2,#7219
 1491 0104 9342     	 cmp r3,r2
 1492 0106 0BD1     	 bne .L103
 793:../SSC/Src/objdef.c ****             && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
 1493              	 .loc 1 793 0
 1494 0108 264B     	 ldr r3,.L108+8
 1495 010a 9B89     	 ldrh r3,[r3,#12]
 1496 010c 03F00203 	 and r3,r3,#2
 1497 0110 002B     	 cmp r3,#0
 1498 0112 05DD     	 ble .L103
 794:../SSC/Src/objdef.c ****             && (nPdOutputSize > 0))
 1499              	 .loc 1 794 0
 1500 0114 214B     	 ldr r3,.L108
 1501 0116 1B88     	 ldrh r3,[r3]
 1502 0118 002B     	 cmp r3,#0
 1503 011a 01D0     	 beq .L103
 795:../SSC/Src/objdef.c ****             {
 796:../SSC/Src/objdef.c ****                 /*SyncManager sync mode is supported and outputs are defined*/
 797:../SSC/Src/objdef.c ****                 return 0;
 1504              	 .loc 1 797 0
 1505 011c 0023     	 movs r3,#0
 1506 011e 37E0     	 b .L100
 1507              	.L103:
 798:../SSC/Src/objdef.c ****             }
 799:../SSC/Src/objdef.c ****         break;
 1508              	 .loc 1 799 0
 1509 0120 35E0     	 b .L93
 1510              	.L97:
 800:../SSC/Src/objdef.c **** 
 801:../SSC/Src/objdef.c ****     case SYNCTYPE_DCSYNC0:
 802:../SSC/Src/objdef.c ****         if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0
 1511              	 .loc 1 802 0
 1512 0122 FB88     	 ldrh r3,[r7,#6]
 1513 0124 41F63242 	 movw r2,#7218
 1514 0128 9342     	 cmp r3,r2
 1515 012a 07D1     	 bne .L104
 1516              	 .loc 1 802 0 is_stmt 0 discriminator 1
 1517 012c 1C4B     	 ldr r3,.L108+4
 1518 012e 9B89     	 ldrh r3,[r3,#12]
 1519 0130 03F00403 	 and r3,r3,#4
 1520 0134 002B     	 cmp r3,#0
 1521 0136 01DD     	 ble .L104
 803:../SSC/Src/objdef.c ****         {
 804:../SSC/Src/objdef.c ****             return 0;
 1522              	 .loc 1 804 0 is_stmt 1
 1523 0138 0023     	 movs r3,#0
 1524 013a 29E0     	 b .L100
 1525              	.L104:
 805:../SSC/Src/objdef.c ****         }
 806:../SSC/Src/objdef.c ****         else
 807:../SSC/Src/objdef.c ****         if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0)
 1526              	 .loc 1 807 0
 1527 013c FB88     	 ldrh r3,[r7,#6]
 1528 013e 41F63342 	 movw r2,#7219
 1529 0142 9342     	 cmp r3,r2
 1530 0144 07D1     	 bne .L105
 1531              	 .loc 1 807 0 is_stmt 0 discriminator 1
 1532 0146 174B     	 ldr r3,.L108+8
 1533 0148 9B89     	 ldrh r3,[r3,#12]
 1534 014a 03F00403 	 and r3,r3,#4
 1535 014e 002B     	 cmp r3,#0
 1536 0150 01DD     	 ble .L105
 808:../SSC/Src/objdef.c ****         {
 809:../SSC/Src/objdef.c ****             return 0;
 1537              	 .loc 1 809 0 is_stmt 1
 1538 0152 0023     	 movs r3,#0
 1539 0154 1CE0     	 b .L100
 1540              	.L105:
 810:../SSC/Src/objdef.c ****         }
 811:../SSC/Src/objdef.c ****         break;
 1541              	 .loc 1 811 0
 1542 0156 1AE0     	 b .L93
 1543              	.L98:
 812:../SSC/Src/objdef.c **** 
 813:../SSC/Src/objdef.c ****     case SYNCTYPE_DCSYNC1:
 814:../SSC/Src/objdef.c ****         if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0
 1544              	 .loc 1 814 0
 1545 0158 FB88     	 ldrh r3,[r7,#6]
 1546 015a 41F63242 	 movw r2,#7218
 1547 015e 9342     	 cmp r3,r2
 1548 0160 07D1     	 bne .L106
 1549              	 .loc 1 814 0 is_stmt 0 discriminator 1
 1550 0162 0F4B     	 ldr r3,.L108+4
 1551 0164 9B89     	 ldrh r3,[r3,#12]
 1552 0166 03F00803 	 and r3,r3,#8
 1553 016a 002B     	 cmp r3,#0
 1554 016c 01DD     	 ble .L106
 815:../SSC/Src/objdef.c ****         {
 816:../SSC/Src/objdef.c ****             return 0;
 1555              	 .loc 1 816 0 is_stmt 1
 1556 016e 0023     	 movs r3,#0
 1557 0170 0EE0     	 b .L100
 1558              	.L106:
 817:../SSC/Src/objdef.c ****         }
 818:../SSC/Src/objdef.c ****         else
 819:../SSC/Src/objdef.c ****         if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0)
 1559              	 .loc 1 819 0
 1560 0172 FB88     	 ldrh r3,[r7,#6]
 1561 0174 41F63342 	 movw r2,#7219
 1562 0178 9342     	 cmp r3,r2
 1563 017a 07D1     	 bne .L107
 1564              	 .loc 1 819 0 is_stmt 0 discriminator 1
 1565 017c 094B     	 ldr r3,.L108+8
 1566 017e 9B89     	 ldrh r3,[r3,#12]
 1567 0180 03F00803 	 and r3,r3,#8
 1568 0184 002B     	 cmp r3,#0
 1569 0186 01DD     	 ble .L107
 820:../SSC/Src/objdef.c ****         {
 821:../SSC/Src/objdef.c ****             return 0;
 1570              	 .loc 1 821 0 is_stmt 1
 1571 0188 0023     	 movs r3,#0
 1572 018a 01E0     	 b .L100
 1573              	.L107:
 822:../SSC/Src/objdef.c ****         }
 823:../SSC/Src/objdef.c ****         break;
 1574              	 .loc 1 823 0
 1575 018c 00BF     	 nop
 1576              	.L93:
 824:../SSC/Src/objdef.c ****     } //switch 
 825:../SSC/Src/objdef.c ****     return ABORTIDX_VALUE_EXCEEDED;
 1577              	 .loc 1 825 0
 1578 018e 1223     	 movs r3,#18
 1579              	.L100:
 826:../SSC/Src/objdef.c **** 
 827:../SSC/Src/objdef.c **** }
 1580              	 .loc 1 827 0
 1581 0190 1846     	 mov r0,r3
 1582 0192 0C37     	 adds r7,r7,#12
 1583              	.LCFI53:
 1584              	 .cfi_def_cfa_offset 4
 1585 0194 BD46     	 mov sp,r7
 1586              	.LCFI54:
 1587              	 .cfi_def_cfa_register 13
 1588              	 
 1589 0196 5DF8047B 	 ldr r7,[sp],#4
 1590              	.LCFI55:
 1591              	 .cfi_restore 7
 1592              	 .cfi_def_cfa_offset 0
 1593 019a 7047     	 bx lr
 1594              	.L109:
 1595              	 .align 2
 1596              	.L108:
 1597 019c 00000000 	 .word nPdOutputSize
 1598 01a0 00000000 	 .word sSyncManOutPar
 1599 01a4 00000000 	 .word sSyncManInPar
 1600 01a8 00000000 	 .word nPdInputSize
 1601              	 .cfi_endproc
 1602              	.LFE188:
 1604              	 .section .text.OBJ_Read,"ax",%progbits
 1605              	 .align 2
 1606              	 .global OBJ_Read
 1607              	 .thumb
 1608              	 .thumb_func
 1610              	OBJ_Read:
 1611              	.LFB189:
 828:../SSC/Src/objdef.c **** 
 829:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 830:../SSC/Src/objdef.c **** /**
 831:../SSC/Src/objdef.c ****  \param     index                 index of the requested object.
 832:../SSC/Src/objdef.c ****  \param     subindex                subindex of the requested object.
 833:../SSC/Src/objdef.c ****  \param    objSize                Size of the object, returned by the function OBJ_GetObjectLength
 834:../SSC/Src/objdef.c ****                                      which was called before
 835:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 836:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 837:../SSC/Src/objdef.c ****  \param    pData                    Pointer to the buffer where the read data shall be copied to
 838:../SSC/Src/objdef.c ****  \param    bCompleteAccess    Indicates if a complete read of all subindices of the
 839:../SSC/Src/objdef.c ****                                      object shall be done or not
 840:../SSC/Src/objdef.c **** 
 841:../SSC/Src/objdef.c ****  \return    result of the read operation (0 (success) or an abort code (ABORTIDX_.... defined in
 842:../SSC/Src/objdef.c ****             sdosrv.h))
 843:../SSC/Src/objdef.c **** 
 844:../SSC/Src/objdef.c ****  \brief    This function reads the requested object
 845:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 846:../SSC/Src/objdef.c **** 
 847:../SSC/Src/objdef.c **** UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, 
 848:../SSC/Src/objdef.c **** {
 1612              	 .loc 1 848 0
 1613              	 .cfi_startproc
 1614              	 
 1615              	 
 1616 0000 90B5     	 push {r4,r7,lr}
 1617              	.LCFI56:
 1618              	 .cfi_def_cfa_offset 12
 1619              	 .cfi_offset 4,-12
 1620              	 .cfi_offset 7,-8
 1621              	 .cfi_offset 14,-4
 1622 0002 91B0     	 sub sp,sp,#68
 1623              	.LCFI57:
 1624              	 .cfi_def_cfa_offset 80
 1625 0004 02AF     	 add r7,sp,#8
 1626              	.LCFI58:
 1627              	 .cfi_def_cfa 7,72
 1628 0006 BA60     	 str r2,[r7,#8]
 1629 0008 7B60     	 str r3,[r7,#4]
 1630 000a 0346     	 mov r3,r0
 1631 000c FB81     	 strh r3,[r7,#14]
 1632 000e 0B46     	 mov r3,r1
 1633 0010 7B73     	 strb r3,[r7,#13]
 849:../SSC/Src/objdef.c ****     UINT16 i = subindex;
 1634              	 .loc 1 849 0
 1635 0012 7B7B     	 ldrb r3,[r7,#13]
 1636 0014 FB86     	 strh r3,[r7,#54]
 850:../SSC/Src/objdef.c ****     /* get the information of ObjCode and MaxSubindex in local variables to support different types
 851:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 1637              	 .loc 1 851 0
 1638 0016 7B68     	 ldr r3,[r7,#4]
 1639 0018 9B89     	 ldrh r3,[r3,#12]
 1640 001a 03F47063 	 and r3,r3,#3840
 1641 001e 1B12     	 asrs r3,r3,#8
 1642 0020 87F82A30 	 strb r3,[r7,#42]
 852:../SSC/Src/objdef.c ****     UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSU
 1643              	 .loc 1 852 0
 1644 0024 7B68     	 ldr r3,[r7,#4]
 1645 0026 9B89     	 ldrh r3,[r3,#12]
 1646 0028 DBB2     	 uxtb r3,r3
 1647 002a BB86     	 strh r3,[r7,#52]
 853:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
 854:../SSC/Src/objdef.c ****     /* lastSubindex is used for complete access to make loop over the requested entries
 855:../SSC/Src/objdef.c ****     to be read, we initialize this variable with the requested subindex that only
 856:../SSC/Src/objdef.c ****     one loop will be done for a single access */
 857:../SSC/Src/objdef.c ****     UINT16 lastSubindex = subindex;
 1648              	 .loc 1 857 0
 1649 002c 7B7B     	 ldrb r3,[r7,#13]
 1650 002e 7B86     	 strh r3,[r7,#50]
 858:../SSC/Src/objdef.c **** 
 859:../SSC/Src/objdef.c ****     if ( objCode != OBJCODE_VAR && index >= 0x1000 )
 1651              	 .loc 1 859 0
 1652 0030 97F82A30 	 ldrb r3,[r7,#42]
 1653 0034 072B     	 cmp r3,#7
 1654 0036 08D0     	 beq .L111
 1655              	 .loc 1 859 0 is_stmt 0 discriminator 1
 1656 0038 FB89     	 ldrh r3,[r7,#14]
 1657 003a B3F5805F 	 cmp r3,#4096
 1658 003e 04D3     	 bcc .L111
 860:../SSC/Src/objdef.c ****     {
 861:../SSC/Src/objdef.c ****         /* if the object is an array or record we have to get the maxSubindex from the
 862:../SSC/Src/objdef.c ****         actual value of subindex 0, which is stored as UINT16 at the beginning of the
 863:../SSC/Src/objdef.c ****         object's variable */
 864:../SSC/Src/objdef.c ****         maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
 1659              	 .loc 1 864 0 is_stmt 1
 1660 0040 7B68     	 ldr r3,[r7,#4]
 1661 0042 9B69     	 ldr r3,[r3,#24]
 1662 0044 1B88     	 ldrh r3,[r3]
 1663 0046 DBB2     	 uxtb r3,r3
 1664 0048 BB86     	 strh r3,[r7,#52]
 1665              	.L111:
 865:../SSC/Src/objdef.c **** 
 866:../SSC/Src/objdef.c ****     }
 867:../SSC/Src/objdef.c **** 
 868:../SSC/Src/objdef.c ****     if ( bCompleteAccess )
 1666              	 .loc 1 868 0
 1667 004a 97F84C30 	 ldrb r3,[r7,#76]
 1668 004e 002B     	 cmp r3,#0
 1669 0050 0CD0     	 beq .L112
 869:../SSC/Src/objdef.c ****     {
 870:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR || index < 0x1000 )
 1670              	 .loc 1 870 0
 1671 0052 97F82A30 	 ldrb r3,[r7,#42]
 1672 0056 072B     	 cmp r3,#7
 1673 0058 03D0     	 beq .L113
 1674              	 .loc 1 870 0 is_stmt 0 discriminator 1
 1675 005a FB89     	 ldrh r3,[r7,#14]
 1676 005c B3F5805F 	 cmp r3,#4096
 1677 0060 01D2     	 bcs .L114
 1678              	.L113:
 871:../SSC/Src/objdef.c ****         {
 872:../SSC/Src/objdef.c ****             /* complete access is not supported with simple objects or ENUM descriptions */
 873:../SSC/Src/objdef.c ****             return ABORTIDX_UNSUPPORTED_ACCESS;
 1679              	 .loc 1 873 0 is_stmt 1
 1680 0062 0523     	 movs r3,#5
 1681 0064 9EE2     	 b .L115
 1682              	.L114:
 874:../SSC/Src/objdef.c ****         }
 875:../SSC/Src/objdef.c **** 
 876:../SSC/Src/objdef.c **** 
 877:../SSC/Src/objdef.c ****         /* we read until the maximum subindex */
 878:../SSC/Src/objdef.c ****         lastSubindex = maxSubindex;
 1683              	 .loc 1 878 0
 1684 0066 BB8E     	 ldrh r3,[r7,#52]
 1685 0068 7B86     	 strh r3,[r7,#50]
 1686 006a 2DE0     	 b .L116
 1687              	.L112:
 879:../SSC/Src/objdef.c ****     }
 880:../SSC/Src/objdef.c ****     else
 881:../SSC/Src/objdef.c ****         if ( subindex > maxSubindex )
 1688              	 .loc 1 881 0
 1689 006c 7B7B     	 ldrb r3,[r7,#13]
 1690 006e 9BB2     	 uxth r3,r3
 1691 0070 BA8E     	 ldrh r2,[r7,#52]
 1692 0072 9A42     	 cmp r2,r3
 1693 0074 01D2     	 bcs .L117
 882:../SSC/Src/objdef.c ****         {
 883:../SSC/Src/objdef.c ****             /* the maximum subindex is reached */
 884:../SSC/Src/objdef.c ****             return ABORTIDX_SUBINDEX_NOT_EXISTING;
 1694              	 .loc 1 884 0
 1695 0076 1123     	 movs r3,#17
 1696 0078 94E2     	 b .L115
 1697              	.L117:
 885:../SSC/Src/objdef.c ****         }
 886:../SSC/Src/objdef.c ****         else
 887:../SSC/Src/objdef.c ****         {
 888:../SSC/Src/objdef.c ****             /* get the corresponding entry description */
 889:../SSC/Src/objdef.c ****             pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
 1698              	 .loc 1 889 0
 1699 007a FB8E     	 ldrh r3,[r7,#54]
 1700 007c DBB2     	 uxtb r3,r3
 1701 007e 7868     	 ldr r0,[r7,#4]
 1702 0080 1946     	 mov r1,r3
 1703 0082 FFF7FEFF 	 bl OBJ_GetEntryDesc
 1704 0086 7862     	 str r0,[r7,#36]
 890:../SSC/Src/objdef.c **** 
 891:../SSC/Src/objdef.c ****             /*Check access only for non-align entries*/
 892:../SSC/Src/objdef.c ****             if(pEntry->ObjAccess != 0x0)
 1705              	 .loc 1 892 0
 1706 0088 7B6A     	 ldr r3,[r7,#36]
 1707 008a 9B88     	 ldrh r3,[r3,#4]
 1708 008c 002B     	 cmp r3,#0
 1709 008e 19D0     	 beq .L118
 893:../SSC/Src/objdef.c ****             {
 894:../SSC/Src/objdef.c ****                 /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
 895:../SSC/Src/objdef.c ****                 by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
 896:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.12) COE3*/
 897:../SSC/Src/objdef.c ****                 if (0 == (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MAS
 1710              	 .loc 1 897 0
 1711 0090 7B6A     	 ldr r3,[r7,#36]
 1712 0092 9B88     	 ldrh r3,[r3,#4]
 1713 0094 DBB2     	 uxtb r3,r3
 1714 0096 03F00703 	 and r3,r3,#7
 1715 009a DBB2     	 uxtb r3,r3
 1716 009c 5B00     	 lsls r3,r3,#1
 1717 009e DBB2     	 uxtb r3,r3
 1718 00a0 1A46     	 mov r2,r3
 1719 00a2 A04B     	 ldr r3,.L169
 1720 00a4 1B78     	 ldrb r3,[r3]
 1721 00a6 03F00F03 	 and r3,r3,#15
 1722 00aa 1340     	 ands r3,r3,r2
 1723 00ac 002B     	 cmp r3,#0
 1724 00ae 0BD1     	 bne .L116
 898:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.12) COE3*/
 899:../SSC/Src/objdef.c ****                 {
 900:../SSC/Src/objdef.c ****                     /* we don't have read access */
 901:../SSC/Src/objdef.c ****                     if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
 1725              	 .loc 1 901 0
 1726 00b0 7B6A     	 ldr r3,[r7,#36]
 1727 00b2 9B88     	 ldrh r3,[r3,#4]
 1728 00b4 03F00703 	 and r3,r3,#7
 1729 00b8 002B     	 cmp r3,#0
 1730 00ba 01D1     	 bne .L119
 902:../SSC/Src/objdef.c ****                     {
 903:../SSC/Src/objdef.c ****                         /* it is a write only entry */
 904:../SSC/Src/objdef.c ****                         return ABORTIDX_WRITE_ONLY_ENTRY;
 1731              	 .loc 1 904 0
 1732 00bc 0623     	 movs r3,#6
 1733 00be 71E2     	 b .L115
 1734              	.L119:
 905:../SSC/Src/objdef.c ****                     }
 906:../SSC/Src/objdef.c ****                     else
 907:../SSC/Src/objdef.c ****                     {
 908:../SSC/Src/objdef.c ****                         /* we don't have read access in this state */
 909:../SSC/Src/objdef.c ****                         return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 1735              	 .loc 1 909 0
 1736 00c0 1A23     	 movs r3,#26
 1737 00c2 6FE2     	 b .L115
 1738              	.L118:
 910:../SSC/Src/objdef.c ****                     }
 911:../SSC/Src/objdef.c ****                 }
 912:../SSC/Src/objdef.c ****             }
 913:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.12) COE7*/
 914:../SSC/Src/objdef.c ****             else
 915:../SSC/Src/objdef.c ****             {
 916:../SSC/Src/objdef.c ****                 return ABORTIDX_UNSUPPORTED_ACCESS;
 1739              	 .loc 1 916 0
 1740 00c4 0523     	 movs r3,#5
 1741 00c6 6DE2     	 b .L115
 1742              	.L116:
 917:../SSC/Src/objdef.c ****             }
 918:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.12) COE7*/
 919:../SSC/Src/objdef.c ****         }
 920:../SSC/Src/objdef.c ****         if ( pObjEntry->Read != NULL )
 1743              	 .loc 1 920 0
 1744 00c8 7B68     	 ldr r3,[r7,#4]
 1745 00ca DB69     	 ldr r3,[r3,#28]
 1746 00cc 002B     	 cmp r3,#0
 1747 00ce 0DD0     	 beq .L120
 921:../SSC/Src/objdef.c ****         {
 922:../SSC/Src/objdef.c ****             /* Read function is defined, we call the object specific read function */
 923:../SSC/Src/objdef.c ****             return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
 1748              	 .loc 1 923 0
 1749 00d0 7B68     	 ldr r3,[r7,#4]
 1750 00d2 DC69     	 ldr r4,[r3,#28]
 1751 00d4 F989     	 ldrh r1,[r7,#14]
 1752 00d6 7A7B     	 ldrb r2,[r7,#13]
 1753 00d8 97F84C30 	 ldrb r3,[r7,#76]
 1754 00dc 0093     	 str r3,[sp]
 1755 00de 0846     	 mov r0,r1
 1756 00e0 1146     	 mov r1,r2
 1757 00e2 BA68     	 ldr r2,[r7,#8]
 1758 00e4 BB6C     	 ldr r3,[r7,#72]
 1759 00e6 A047     	 blx r4
 1760 00e8 0346     	 mov r3,r0
 1761 00ea 5BE2     	 b .L115
 1762              	.L120:
 924:../SSC/Src/objdef.c ****         }
 925:../SSC/Src/objdef.c ****         else if ( index < 0x1000 && subindex != 0 )
 1763              	 .loc 1 925 0
 1764 00ec FB89     	 ldrh r3,[r7,#14]
 1765 00ee B3F5805F 	 cmp r3,#4096
 1766 00f2 32D2     	 bcs .L121
 1767              	 .loc 1 925 0 is_stmt 0 discriminator 1
 1768 00f4 7B7B     	 ldrb r3,[r7,#13]
 1769 00f6 002B     	 cmp r3,#0
 1770 00f8 2FD0     	 beq .L121
 1771              	.LBB10:
 926:../SSC/Src/objdef.c ****         {
 927:../SSC/Src/objdef.c ****             /* an ENUM description is read */
 928:../SSC/Src/objdef.c ****             UINT16 size;
 929:../SSC/Src/objdef.c ****             UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 1772              	 .loc 1 929 0 is_stmt 1
 1773 00fa 7B68     	 ldr r3,[r7,#4]
 1774 00fc 9B69     	 ldr r3,[r3,#24]
 1775 00fe 3B62     	 str r3,[r7,#32]
 930:../SSC/Src/objdef.c ****             CHAR **p;
 931:../SSC/Src/objdef.c **** 
 932:../SSC/Src/objdef.c ****             /* we get the corresponding entry description */
 933:../SSC/Src/objdef.c ****             pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
 1776              	 .loc 1 933 0
 1777 0100 7B7B     	 ldrb r3,[r7,#13]
 1778 0102 7868     	 ldr r0,[r7,#4]
 1779 0104 1946     	 mov r1,r3
 1780 0106 FFF7FEFF 	 bl OBJ_GetEntryDesc
 1781 010a 7862     	 str r0,[r7,#36]
 934:../SSC/Src/objdef.c ****             size = BIT2BYTE(pEntry->BitLength);
 1782              	 .loc 1 934 0
 1783 010c 7B6A     	 ldr r3,[r7,#36]
 1784 010e 5B88     	 ldrh r3,[r3,#2]
 1785 0110 0733     	 adds r3,r3,#7
 1786 0112 DB10     	 asrs r3,r3,#3
 1787 0114 FB83     	 strh r3,[r7,#30]
 935:../SSC/Src/objdef.c **** 
 936:../SSC/Src/objdef.c ****             p = (CHAR **) pVarPtr;
 1788              	 .loc 1 936 0
 1789 0116 3B6A     	 ldr r3,[r7,#32]
 1790 0118 BB61     	 str r3,[r7,#24]
 937:../SSC/Src/objdef.c ****             pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
 1791              	 .loc 1 937 0
 1792 011a 7B7B     	 ldrb r3,[r7,#13]
 1793 011c 03F18043 	 add r3,r3,#1073741824
 1794 0120 013B     	 subs r3,r3,#1
 1795 0122 9B00     	 lsls r3,r3,#2
 1796 0124 BA69     	 ldr r2,[r7,#24]
 1797 0126 1344     	 add r3,r3,r2
 1798 0128 1B68     	 ldr r3,[r3]
 1799 012a 3B62     	 str r3,[r7,#32]
 938:../SSC/Src/objdef.c **** 
 939:../SSC/Src/objdef.c ****             {
 940:../SSC/Src/objdef.c ****             // Get enum value (first 32Bit)
 941:../SSC/Src/objdef.c ****             pData[0] = pVarPtr[0];
 1800              	 .loc 1 941 0
 1801 012c 3B6A     	 ldr r3,[r7,#32]
 1802 012e 1A88     	 ldrh r2,[r3]
 1803 0130 BB6C     	 ldr r3,[r7,#72]
 1804 0132 1A80     	 strh r2,[r3]
 942:../SSC/Src/objdef.c ****             pData[1] = pVarPtr[1];
 1805              	 .loc 1 942 0
 1806 0134 BB6C     	 ldr r3,[r7,#72]
 1807 0136 0233     	 adds r3,r3,#2
 1808 0138 3A6A     	 ldr r2,[r7,#32]
 1809 013a 5288     	 ldrh r2,[r2,#2]
 1810 013c 1A80     	 strh r2,[r3]
 943:../SSC/Src/objdef.c ****             pData += 2;
 1811              	 .loc 1 943 0
 1812 013e BB6C     	 ldr r3,[r7,#72]
 1813 0140 0433     	 adds r3,r3,#4
 1814 0142 BB64     	 str r3,[r7,#72]
 944:../SSC/Src/objdef.c ****             pVarPtr += 2;
 1815              	 .loc 1 944 0
 1816 0144 3B6A     	 ldr r3,[r7,#32]
 1817 0146 0433     	 adds r3,r3,#4
 1818 0148 3B62     	 str r3,[r7,#32]
 945:../SSC/Src/objdef.c **** 
 946:../SSC/Src/objdef.c ****             // Get enum description
 947:../SSC/Src/objdef.c ****             OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
 1819              	 .loc 1 947 0
 1820 014a FB8B     	 ldrh r3,[r7,#30]
 1821 014c 043B     	 subs r3,r3,#4
 1822 014e B86C     	 ldr r0,[r7,#72]
 1823 0150 396A     	 ldr r1,[r7,#32]
 1824 0152 1A46     	 mov r2,r3
 1825 0154 FFF7FEFF 	 bl memcpy
 1826              	.LBE10:
 926:../SSC/Src/objdef.c ****             /* an ENUM description is read */
 1827              	 .loc 1 926 0
 1828 0158 23E2     	 b .L122
 1829              	.L121:
 1830              	.LBB11:
 948:../SSC/Src/objdef.c ****             }
 949:../SSC/Src/objdef.c ****         }
 950:../SSC/Src/objdef.c ****         else
 951:../SSC/Src/objdef.c ****         {
 952:../SSC/Src/objdef.c ****             UINT8 bRead = 0x0;
 1831              	 .loc 1 952 0
 1832 015a 0023     	 movs r3,#0
 1833 015c 87F83130 	 strb r3,[r7,#49]
 953:../SSC/Src/objdef.c ****             UINT8 result = 0;
 1834              	 .loc 1 953 0
 1835 0160 0023     	 movs r3,#0
 1836 0162 87F83030 	 strb r3,[r7,#48]
 954:../SSC/Src/objdef.c **** 
 955:../SSC/Src/objdef.c **** 
 956:../SSC/Src/objdef.c ****             /* a variable object is read */
 957:../SSC/Src/objdef.c ****             for (i = subindex; i <= lastSubindex; i++)
 1837              	 .loc 1 957 0
 1838 0166 7B7B     	 ldrb r3,[r7,#13]
 1839 0168 FB86     	 strh r3,[r7,#54]
 1840 016a 0EE2     	 b .L123
 1841              	.L168:
 1842              	.LBB12:
 958:../SSC/Src/objdef.c ****             {
 959:../SSC/Src/objdef.c ****                 /* if only a single entry is requested, this loop will only be done once */
 960:../SSC/Src/objdef.c ****                 UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 1843              	 .loc 1 960 0
 1844 016c 7B68     	 ldr r3,[r7,#4]
 1845 016e 9B69     	 ldr r3,[r3,#24]
 1846 0170 7B61     	 str r3,[r7,#20]
 961:../SSC/Src/objdef.c ****                 UINT16 bitOffset = 0;
 1847              	 .loc 1 961 0
 1848 0172 0023     	 movs r3,#0
 1849 0174 FB85     	 strh r3,[r7,#46]
 962:../SSC/Src/objdef.c **** 
 963:../SSC/Src/objdef.c ****                 
 964:../SSC/Src/objdef.c ****                 if (i == 0)
 1850              	 .loc 1 964 0
 1851 0176 FB8E     	 ldrh r3,[r7,#54]
 1852 0178 002B     	 cmp r3,#0
 1853 017a 0BD0     	 beq .L124
 965:../SSC/Src/objdef.c ****                 {
 966:../SSC/Src/objdef.c ****                     /* subindex 0 is requested, the entry's data is at the beginning of the object'
 967:../SSC/Src/objdef.c ****                 }
 968:../SSC/Src/objdef.c ****                 else if ( index >= 0x1000 )
 1854              	 .loc 1 968 0
 1855 017c FB89     	 ldrh r3,[r7,#14]
 1856 017e B3F5805F 	 cmp r3,#4096
 1857 0182 07D3     	 bcc .L124
 969:../SSC/Src/objdef.c ****                 {
 970:../SSC/Src/objdef.c ****                     /* subindex 1-n of an variable object is requested, we get the offset of the va
 971:../SSC/Src/objdef.c ****                     bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
 1858              	 .loc 1 971 0
 1859 0184 FB8E     	 ldrh r3,[r7,#54]
 1860 0186 DBB2     	 uxtb r3,r3
 1861 0188 1846     	 mov r0,r3
 1862 018a 7968     	 ldr r1,[r7,#4]
 1863 018c FFF7FEFF 	 bl OBJ_GetEntryOffset
 1864 0190 0346     	 mov r3,r0
 1865 0192 FB85     	 strh r3,[r7,#46]
 1866              	.L124:
 972:../SSC/Src/objdef.c ****                 }
 973:../SSC/Src/objdef.c **** 
 974:../SSC/Src/objdef.c ****                 /* we increment the variable pointer to the corresponding word address */
 975:../SSC/Src/objdef.c ****                 pVarPtr += (bitOffset >> 4);
 1867              	 .loc 1 975 0
 1868 0194 FB8D     	 ldrh r3,[r7,#46]
 1869 0196 1B09     	 lsrs r3,r3,#4
 1870 0198 9BB2     	 uxth r3,r3
 1871 019a 5B00     	 lsls r3,r3,#1
 1872 019c 7A69     	 ldr r2,[r7,#20]
 1873 019e 1344     	 add r3,r3,r2
 1874 01a0 7B61     	 str r3,[r7,#20]
 976:../SSC/Src/objdef.c **** 
 977:../SSC/Src/objdef.c ****                 /* get the corresponding entry description */
 978:../SSC/Src/objdef.c ****                 pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
 1875              	 .loc 1 978 0
 1876 01a2 FB8E     	 ldrh r3,[r7,#54]
 1877 01a4 DBB2     	 uxtb r3,r3
 1878 01a6 7868     	 ldr r0,[r7,#4]
 1879 01a8 1946     	 mov r1,r3
 1880 01aa FFF7FEFF 	 bl OBJ_GetEntryDesc
 1881 01ae 7862     	 str r0,[r7,#36]
 979:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.12) COE3*/
 980:../SSC/Src/objdef.c ****                 if (0 != (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MAS
 1882              	 .loc 1 980 0
 1883 01b0 7B6A     	 ldr r3,[r7,#36]
 1884 01b2 9B88     	 ldrh r3,[r3,#4]
 1885 01b4 DBB2     	 uxtb r3,r3
 1886 01b6 03F00703 	 and r3,r3,#7
 1887 01ba DBB2     	 uxtb r3,r3
 1888 01bc 5B00     	 lsls r3,r3,#1
 1889 01be DBB2     	 uxtb r3,r3
 1890 01c0 1A46     	 mov r2,r3
 1891 01c2 584B     	 ldr r3,.L169
 1892 01c4 1B78     	 ldrb r3,[r3]
 1893 01c6 03F00F03 	 and r3,r3,#15
 1894 01ca 1340     	 ands r3,r3,r2
 1895 01cc 002B     	 cmp r3,#0
 1896 01ce 00F09581 	 beq .L125
 981:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.12) COE3*/
 982:../SSC/Src/objdef.c ****                 {
 983:../SSC/Src/objdef.c ****                     if ( i == subindex                                     /* requested entry */
 1897              	 .loc 1 983 0
 1898 01d2 7B7B     	 ldrb r3,[r7,#13]
 1899 01d4 9BB2     	 uxth r3,r3
 1900 01d6 FA8E     	 ldrh r2,[r7,#54]
 1901 01d8 9A42     	 cmp r2,r3
 1902 01da 0AD0     	 beq .L126
 984:../SSC/Src/objdef.c ****                         || (bCompleteAccess && i >= subindex) )       /* complete access and entry 
 1903              	 .loc 1 984 0
 1904 01dc 97F84C30 	 ldrb r3,[r7,#76]
 1905 01e0 002B     	 cmp r3,#0
 1906 01e2 00F08A81 	 beq .L127
 1907              	 .loc 1 984 0 is_stmt 0 discriminator 1
 1908 01e6 7B7B     	 ldrb r3,[r7,#13]
 1909 01e8 9BB2     	 uxth r3,r3
 1910 01ea FA8E     	 ldrh r2,[r7,#54]
 1911 01ec 9A42     	 cmp r2,r3
 1912 01ee C0F08481 	 bcc .L127
 1913              	.L126:
 1914              	.LBB13:
 985:../SSC/Src/objdef.c ****                     {
 986:../SSC/Src/objdef.c ****                         UINT16 bitMask;
 987:../SSC/Src/objdef.c **** 
 988:../SSC/Src/objdef.c ****                         /* we have to copy the entry */
 989:../SSC/Src/objdef.c ****                         if ( i == 0 && objCode != OBJCODE_VAR )
 1915              	 .loc 1 989 0 is_stmt 1
 1916 01f2 FB8E     	 ldrh r3,[r7,#54]
 1917 01f4 002B     	 cmp r3,#0
 1918 01f6 0AD1     	 bne .L128
 1919              	 .loc 1 989 0 is_stmt 0 discriminator 1
 1920 01f8 97F82A30 	 ldrb r3,[r7,#42]
 1921 01fc 072B     	 cmp r3,#7
 1922 01fe 06D0     	 beq .L128
 990:../SSC/Src/objdef.c ****                         {
 991:../SSC/Src/objdef.c ****                             /* we read subindex 0 of an array or record */
 992:../SSC/Src/objdef.c ****                             {
 993:../SSC/Src/objdef.c ****                                 pData[0] = SWAPWORD((UINT16)maxSubindex);
 1923              	 .loc 1 993 0 is_stmt 1
 1924 0200 BB6C     	 ldr r3,[r7,#72]
 1925 0202 BA8E     	 ldrh r2,[r7,#52]
 1926 0204 1A80     	 strh r2,[r3]
 994:../SSC/Src/objdef.c ****                             }
 995:../SSC/Src/objdef.c **** 
 996:../SSC/Src/objdef.c ****                             /* we increment the destination pointer by 2 because the subindex 0 wil
 997:../SSC/Src/objdef.c ****                             transmitted as UINT16 for a complete access */
 998:../SSC/Src/objdef.c ****                             pData++;
 1927              	 .loc 1 998 0
 1928 0206 BB6C     	 ldr r3,[r7,#72]
 1929 0208 0233     	 adds r3,r3,#2
 1930 020a BB64     	 str r3,[r7,#72]
 1931 020c 75E1     	 b .L127
 1932              	.L128:
 1933              	.LBB14:
 999:../SSC/Src/objdef.c ****                         }
1000:../SSC/Src/objdef.c ****                         else
1001:../SSC/Src/objdef.c ****                         {
1002:../SSC/Src/objdef.c ****                             UINT16 dataType = pEntry->DataType;
 1934              	 .loc 1 1002 0
 1935 020e 7B6A     	 ldr r3,[r7,#36]
 1936 0210 1B88     	 ldrh r3,[r3]
 1937 0212 BB85     	 strh r3,[r7,#44]
1003:../SSC/Src/objdef.c ****                             
1004:../SSC/Src/objdef.c ****                             if (pEntry->DataType >= 0x700)
 1938              	 .loc 1 1004 0
 1939 0214 7B6A     	 ldr r3,[r7,#36]
 1940 0216 1B88     	 ldrh r3,[r3]
 1941 0218 B3F5E06F 	 cmp r3,#1792
 1942 021c 15D3     	 bcc .L129
1005:../SSC/Src/objdef.c ****                             {
1006:../SSC/Src/objdef.c ****                                 /* the ENUM data types are defined from index 0x700 in this example
1007:../SSC/Src/objdef.c ****                                 convert in standard data type for the read access */
1008:../SSC/Src/objdef.c ****                                 if ( pEntry->BitLength <= 8 )
 1943              	 .loc 1 1008 0
 1944 021e 7B6A     	 ldr r3,[r7,#36]
 1945 0220 5B88     	 ldrh r3,[r3,#2]
 1946 0222 082B     	 cmp r3,#8
 1947 0224 04D8     	 bhi .L130
1009:../SSC/Src/objdef.c ****                                 {
1010:../SSC/Src/objdef.c ****                                     dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
 1948              	 .loc 1 1010 0
 1949 0226 7B6A     	 ldr r3,[r7,#36]
 1950 0228 5B88     	 ldrh r3,[r3,#2]
 1951 022a 2F33     	 adds r3,r3,#47
 1952 022c BB85     	 strh r3,[r7,#44]
 1953 022e 0CE0     	 b .L129
 1954              	.L130:
1011:../SSC/Src/objdef.c ****                                 }
1012:../SSC/Src/objdef.c ****                                 else if ( pEntry->BitLength == 16 )
 1955              	 .loc 1 1012 0
 1956 0230 7B6A     	 ldr r3,[r7,#36]
 1957 0232 5B88     	 ldrh r3,[r3,#2]
 1958 0234 102B     	 cmp r3,#16
 1959 0236 02D1     	 bne .L131
1013:../SSC/Src/objdef.c ****                                 {
1014:../SSC/Src/objdef.c ****                                     dataType = DEFTYPE_UNSIGNED16;
 1960              	 .loc 1 1014 0
 1961 0238 0623     	 movs r3,#6
 1962 023a BB85     	 strh r3,[r7,#44]
 1963 023c 05E0     	 b .L129
 1964              	.L131:
1015:../SSC/Src/objdef.c ****                                 }
1016:../SSC/Src/objdef.c ****                                 else if ( pEntry->BitLength == 32 )
 1965              	 .loc 1 1016 0
 1966 023e 7B6A     	 ldr r3,[r7,#36]
 1967 0240 5B88     	 ldrh r3,[r3,#2]
 1968 0242 202B     	 cmp r3,#32
 1969 0244 01D1     	 bne .L129
1017:../SSC/Src/objdef.c ****                                 {
1018:../SSC/Src/objdef.c ****                                     dataType = DEFTYPE_UNSIGNED32;
 1970              	 .loc 1 1018 0
 1971 0246 0723     	 movs r3,#7
 1972 0248 BB85     	 strh r3,[r7,#44]
 1973              	.L129:
1019:../SSC/Src/objdef.c ****                                 }
1020:../SSC/Src/objdef.c ****                             }
1021:../SSC/Src/objdef.c **** 
1022:../SSC/Src/objdef.c ****                             switch (dataType)
 1974              	 .loc 1 1022 0
 1975 024a BB8D     	 ldrh r3,[r7,#44]
 1976 024c 112B     	 cmp r3,#17
 1977 024e 00F0E080 	 beq .L133
 1978 0252 112B     	 cmp r3,#17
 1979 0254 1EDC     	 bgt .L134
 1980 0256 052B     	 cmp r3,#5
 1981 0258 66D0     	 beq .L135
 1982 025a 052B     	 cmp r3,#5
 1983 025c 0DDC     	 bgt .L136
 1984 025e 022B     	 cmp r3,#2
 1985 0260 04DC     	 bgt .L137
 1986 0262 012B     	 cmp r3,#1
 1987 0264 60DA     	 bge .L135
 1988 0266 002B     	 cmp r3,#0
 1989 0268 3AD0     	 beq .L138
 1990 026a 40E1     	 b .L132
 1991              	.L137:
 1992 026c 032B     	 cmp r3,#3
 1993 026e 00F0AD80 	 beq .L139
 1994 0272 042B     	 cmp r3,#4
 1995 0274 00F0B980 	 beq .L140
 1996 0278 39E1     	 b .L132
 1997              	.L136:
 1998 027a 082B     	 cmp r3,#8
 1999 027c 03DC     	 bgt .L141
 2000 027e 072B     	 cmp r3,#7
 2001 0280 80F2B380 	 bge .L140
 2002 0284 A2E0     	 b .L139
 2003              	.L141:
 2004 0286 092B     	 cmp r3,#9
 2005 0288 00F00981 	 beq .L142
 2006 028c 0B2B     	 cmp r3,#11
 2007 028e 00F32E81 	 bgt .L132
 2008 0292 DCE0     	 b .L143
 2009              	.L134:
 2010 0294 2D2B     	 cmp r3,#45
 2011 0296 47D0     	 beq .L135
 2012 0298 2D2B     	 cmp r3,#45
 2013 029a 11DC     	 bgt .L144
 2014 029c 1E2B     	 cmp r3,#30
 2015 029e 43D0     	 beq .L135
 2016 02a0 1E2B     	 cmp r3,#30
 2017 02a2 06DC     	 bgt .L145
 2018 02a4 152B     	 cmp r3,#21
 2019 02a6 00F0B480 	 beq .L133
 2020 02aa 1B2B     	 cmp r3,#27
 2021 02ac 00F0B180 	 beq .L133
 2022 02b0 1DE1     	 b .L132
 2023              	.L145:
 2024 02b2 1F2B     	 cmp r3,#31
 2025 02b4 00F08A80 	 beq .L139
 2026 02b8 202B     	 cmp r3,#32
 2027 02ba 00F09680 	 beq .L140
 2028 02be 16E1     	 b .L132
 2029              	.L144:
 2030 02c0 372B     	 cmp r3,#55
 2031 02c2 07DC     	 bgt .L146
 2032 02c4 302B     	 cmp r3,#48
 2033 02c6 2FDA     	 bge .L135
 2034 02c8 2E2B     	 cmp r3,#46
 2035 02ca 7FD0     	 beq .L139
 2036 02cc 2F2B     	 cmp r3,#47
 2037 02ce 00F08C80 	 beq .L140
 2038 02d2 0CE1     	 b .L132
 2039              	.L146:
 2040 02d4 A3F51873 	 sub r3,r3,#608
 2041 02d8 032B     	 cmp r3,#3
 2042 02da 00F20881 	 bhi .L132
 2043 02de B6E0     	 b .L143
 2044              	.L138:
1023:../SSC/Src/objdef.c ****                             {
1024:../SSC/Src/objdef.c ****                             case DEFTYPE_NULL:
1025:../SSC/Src/objdef.c ****                                 if(bCompleteAccess)
 2045              	 .loc 1 1025 0
 2046 02e0 97F84C30 	 ldrb r3,[r7,#76]
 2047 02e4 002B     	 cmp r3,#0
 2048 02e6 1AD0     	 beq .L147
1026:../SSC/Src/objdef.c ****                                 {
1027:../SSC/Src/objdef.c ****                                     /*Handle alignment entry*/
1028:../SSC/Src/objdef.c ****                                     if (((pEntry->BitLength & 0xF) > 0)
 2049              	 .loc 1 1028 0
 2050 02e8 7B6A     	 ldr r3,[r7,#36]
 2051 02ea 5B88     	 ldrh r3,[r3,#2]
 2052 02ec 03F00F03 	 and r3,r3,#15
 2053 02f0 002B     	 cmp r3,#0
 2054 02f2 0ADD     	 ble .L148
1029:../SSC/Src/objdef.c ****                                         && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 2055              	 .loc 1 1029 0
 2056 02f4 FB8D     	 ldrh r3,[r7,#46]
 2057 02f6 7A6A     	 ldr r2,[r7,#36]
 2058 02f8 5288     	 ldrh r2,[r2,#2]
 2059 02fa 1344     	 add r3,r3,r2
 2060 02fc 03F00F03 	 and r3,r3,#15
 2061 0300 002B     	 cmp r3,#0
 2062 0302 02D1     	 bne .L148
1030:../SSC/Src/objdef.c ****                                     {
1031:../SSC/Src/objdef.c ****                                         /* we have reached the UINT16 border */
1032:../SSC/Src/objdef.c ****                                         pData++;
 2063              	 .loc 1 1032 0
 2064 0304 BB6C     	 ldr r3,[r7,#72]
 2065 0306 0233     	 adds r3,r3,#2
 2066 0308 BB64     	 str r3,[r7,#72]
 2067              	.L148:
1033:../SSC/Src/objdef.c ****                                     }
1034:../SSC/Src/objdef.c **** 
1035:../SSC/Src/objdef.c ****                                     /*increment WORD offset*/
1036:../SSC/Src/objdef.c ****                                     pData += ((pEntry->BitLength & 0xF0) >> 4);
 2068              	 .loc 1 1036 0
 2069 030a 7B6A     	 ldr r3,[r7,#36]
 2070 030c 5B88     	 ldrh r3,[r3,#2]
 2071 030e 03F0F003 	 and r3,r3,#240
 2072 0312 1B11     	 asrs r3,r3,#4
 2073 0314 5B00     	 lsls r3,r3,#1
 2074 0316 BA6C     	 ldr r2,[r7,#72]
 2075 0318 1344     	 add r3,r3,r2
 2076 031a BB64     	 str r3,[r7,#72]
1037:../SSC/Src/objdef.c ****                                 }
1038:../SSC/Src/objdef.c ****                                 else
1039:../SSC/Src/objdef.c ****                                 {
1040:../SSC/Src/objdef.c ****                                     return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
1041:../SSC/Src/objdef.c ****                                 }
1042:../SSC/Src/objdef.c ****                                 break;
 2077              	 .loc 1 1042 0
 2078 031c E9E0     	 b .L150
 2079              	.L147:
1040:../SSC/Src/objdef.c ****                                 }
 2080              	 .loc 1 1040 0
 2081 031e 1823     	 movs r3,#24
 2082 0320 40E1     	 b .L115
 2083              	.L170:
 2084 0322 00BF     	 .align 2
 2085              	.L169:
 2086 0324 00000000 	 .word nAlStatus
 2087              	.L135:
 2088              	.LBB15:
1043:../SSC/Src/objdef.c ****                             case     DEFTYPE_BOOLEAN:
1044:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT1:
1045:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT2:
1046:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT3:
1047:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT4:
1048:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT5:
1049:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT6:
1050:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT7:
1051:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT8:
1052:../SSC/Src/objdef.c ****                             case     DEFTYPE_BITARR8:
1053:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1054:../SSC/Src/objdef.c ****                                 that the bit types are always inside a 16-bit field,
1055:../SSC/Src/objdef.c ****                                 and they shall not overlap a byte border*/
1056:../SSC/Src/objdef.c ****                             case    DEFTYPE_INTEGER8:
1057:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED8:
1058:../SSC/Src/objdef.c ****                             case    DEFTYPE_BYTE :
1059:../SSC/Src/objdef.c ****                                 {
1060:../SSC/Src/objdef.c ****                                     /* depending on the bitOffset we have to copy the Hi or the Lo-
1061:../SSC/Src/objdef.c ****                                     UINT16 TmpValue = 0x0000;
 2089              	 .loc 1 1061 0
 2090 0328 0023     	 movs r3,#0
 2091 032a 7B82     	 strh r3,[r7,#18]
1062:../SSC/Src/objdef.c **** 
1063:../SSC/Src/objdef.c ****                                     
1064:../SSC/Src/objdef.c ****                                     bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
 2092              	 .loc 1 1064 0
 2093 032c 7B6A     	 ldr r3,[r7,#36]
 2094 032e 5B88     	 ldrh r3,[r3,#2]
 2095 0330 1A46     	 mov r2,r3
 2096 0332 9E4B     	 ldr r3,.L171
 2097 0334 33F81230 	 ldrh r3,[r3,r2,lsl#1]
 2098 0338 1A46     	 mov r2,r3
 2099 033a FB8D     	 ldrh r3,[r7,#46]
 2100 033c 03F00F03 	 and r3,r3,#15
 2101 0340 02FA03F3 	 lsl r3,r2,r3
 2102 0344 3B82     	 strh r3,[r7,#16]
1065:../SSC/Src/objdef.c **** 
1066:../SSC/Src/objdef.c ****                                     /*Swap object data (if required); all masks and offsets are def
1067:../SSC/Src/objdef.c ****                                     TmpValue = SWAPWORD(pVarPtr[0]);
 2103              	 .loc 1 1067 0
 2104 0346 7B69     	 ldr r3,[r7,#20]
 2105 0348 1B88     	 ldrh r3,[r3]
 2106 034a 7B82     	 strh r3,[r7,#18]
1068:../SSC/Src/objdef.c **** 
1069:../SSC/Src/objdef.c ****                                     /*Clear pData if the first bits within the WORD memory will be 
1070:../SSC/Src/objdef.c ****                                     if ((bitOffset & 0x0F) == 0) 
 2107              	 .loc 1 1070 0
 2108 034c FB8D     	 ldrh r3,[r7,#46]
 2109 034e 03F00F03 	 and r3,r3,#15
 2110 0352 002B     	 cmp r3,#0
 2111 0354 02D1     	 bne .L151
1071:../SSC/Src/objdef.c ****                                     {
1072:../SSC/Src/objdef.c ****                                         pData[0] = 0;
 2112              	 .loc 1 1072 0
 2113 0356 BB6C     	 ldr r3,[r7,#72]
 2114 0358 0022     	 movs r2,#0
 2115 035a 1A80     	 strh r2,[r3]
 2116              	.L151:
1073:../SSC/Src/objdef.c ****                                     }
1074:../SSC/Src/objdef.c **** 
1075:../SSC/Src/objdef.c ****                                     pData[0] = SWAPWORD(pData[0]);
 2117              	 .loc 1 1075 0
 2118 035c BB6C     	 ldr r3,[r7,#72]
 2119 035e 1A88     	 ldrh r2,[r3]
 2120 0360 BB6C     	 ldr r3,[r7,#72]
 2121 0362 1A80     	 strh r2,[r3]
1076:../SSC/Src/objdef.c **** 
1077:../SSC/Src/objdef.c ****                                     if (bCompleteAccess) 
 2122              	 .loc 1 1077 0
 2123 0364 97F84C30 	 ldrb r3,[r7,#76]
 2124 0368 002B     	 cmp r3,#0
 2125 036a 0AD0     	 beq .L152
1078:../SSC/Src/objdef.c ****                                     {
1079:../SSC/Src/objdef.c ****                                         /*shifting is not required for Complete access because the 
1080:../SSC/Src/objdef.c ****                                         pData[0] |= TmpValue & bitMask;
 2126              	 .loc 1 1080 0
 2127 036c BB6C     	 ldr r3,[r7,#72]
 2128 036e 1A88     	 ldrh r2,[r3]
 2129 0370 798A     	 ldrh r1,[r7,#18]
 2130 0372 3B8A     	 ldrh r3,[r7,#16]
 2131 0374 0B40     	 ands r3,r3,r1
 2132 0376 9BB2     	 uxth r3,r3
 2133 0378 1343     	 orrs r3,r3,r2
 2134 037a 9AB2     	 uxth r2,r3
 2135 037c BB6C     	 ldr r3,[r7,#72]
 2136 037e 1A80     	 strh r2,[r3]
 2137 0380 13E0     	 b .L153
 2138              	.L152:
1081:../SSC/Src/objdef.c ****                                     }
1082:../SSC/Src/objdef.c ****                                     else
1083:../SSC/Src/objdef.c ****                                     {
1084:../SSC/Src/objdef.c ****                                         /*Shift Bits to the beginning of the mailbox memory*/
1085:../SSC/Src/objdef.c ****                                         pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
 2139              	 .loc 1 1085 0
 2140 0382 BB6C     	 ldr r3,[r7,#72]
 2141 0384 1B88     	 ldrh r3,[r3]
 2142 0386 99B2     	 uxth r1,r3
 2143 0388 7A8A     	 ldrh r2,[r7,#18]
 2144 038a 3B8A     	 ldrh r3,[r7,#16]
 2145 038c 1340     	 ands r3,r3,r2
 2146 038e 9BB2     	 uxth r3,r3
 2147 0390 1A46     	 mov r2,r3
 2148 0392 FB8D     	 ldrh r3,[r7,#46]
 2149 0394 03F00F03 	 and r3,r3,#15
 2150 0398 42FA03F3 	 asr r3,r2,r3
 2151 039c 9BB2     	 uxth r3,r3
 2152 039e 0A46     	 mov r2,r1
 2153 03a0 1343     	 orrs r3,r3,r2
 2154 03a2 9BB2     	 uxth r3,r3
 2155 03a4 9AB2     	 uxth r2,r3
 2156 03a6 BB6C     	 ldr r3,[r7,#72]
 2157 03a8 1A80     	 strh r2,[r3]
 2158              	.L153:
1086:../SSC/Src/objdef.c ****                                     }
1087:../SSC/Src/objdef.c **** 
1088:../SSC/Src/objdef.c ****                                     pData[0] = SWAPWORD(pData[0]);
 2159              	 .loc 1 1088 0
 2160 03aa BB6C     	 ldr r3,[r7,#72]
 2161 03ac 1A88     	 ldrh r2,[r3]
 2162 03ae BB6C     	 ldr r3,[r7,#72]
 2163 03b0 1A80     	 strh r2,[r3]
1089:../SSC/Src/objdef.c ****                                     if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
 2164              	 .loc 1 1089 0
 2165 03b2 FB8D     	 ldrh r3,[r7,#46]
 2166 03b4 7A6A     	 ldr r2,[r7,#36]
 2167 03b6 5288     	 ldrh r2,[r2,#2]
 2168 03b8 1344     	 add r3,r3,r2
 2169 03ba 03F00F03 	 and r3,r3,#15
 2170 03be 002B     	 cmp r3,#0
 2171 03c0 03D1     	 bne .L154
1090:../SSC/Src/objdef.c ****                                     {
1091:../SSC/Src/objdef.c ****                                         /* we have reached the UINT16 border */
1092:../SSC/Src/objdef.c ****                                         pData++;
 2172              	 .loc 1 1092 0
 2173 03c2 BB6C     	 ldr r3,[r7,#72]
 2174 03c4 0233     	 adds r3,r3,#2
 2175 03c6 BB64     	 str r3,[r7,#72]
 2176              	.LBE15:
1093:../SSC/Src/objdef.c ****                                     }
1094:../SSC/Src/objdef.c **** 
1095:../SSC/Src/objdef.c ****                                 }
1096:../SSC/Src/objdef.c ****                                 break;
 2177              	 .loc 1 1096 0
 2178 03c8 93E0     	 b .L150
 2179              	.L154:
 2180 03ca 92E0     	 b .L150
 2181              	.L139:
1097:../SSC/Src/objdef.c ****                             case    DEFTYPE_INTEGER16:
1098:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED16:
1099:../SSC/Src/objdef.c ****                             case    DEFTYPE_BITARR16:
1100:../SSC/Src/objdef.c ****                             case    DEFTYPE_WORD:
1101:../SSC/Src/objdef.c **** 
1102:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2182              	 .loc 1 1102 0
 2183 03cc FB8D     	 ldrh r3,[r7,#46]
 2184 03ce 03F00F03 	 and r3,r3,#15
 2185 03d2 002B     	 cmp r3,#0
 2186 03d4 01D0     	 beq .L155
1103:../SSC/Src/objdef.c ****                                 {
1104:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1105:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2187              	 .loc 1 1105 0
 2188 03d6 0523     	 movs r3,#5
 2189 03d8 E4E0     	 b .L115
 2190              	.L155:
1106:../SSC/Src/objdef.c ****                                 }
1107:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1108:../SSC/Src/objdef.c ****                                 that the 16 bit type are always starting at an exact WORD offset */
1109:../SSC/Src/objdef.c ****                                 pData[0] = SWAPWORD(pVarPtr[0]);
 2191              	 .loc 1 1109 0
 2192 03da 7B69     	 ldr r3,[r7,#20]
 2193 03dc 1A88     	 ldrh r2,[r3]
 2194 03de BB6C     	 ldr r3,[r7,#72]
 2195 03e0 1A80     	 strh r2,[r3]
1110:../SSC/Src/objdef.c ****                                 pData++;
 2196              	 .loc 1 1110 0
 2197 03e2 BB6C     	 ldr r3,[r7,#72]
 2198 03e4 0233     	 adds r3,r3,#2
 2199 03e6 BB64     	 str r3,[r7,#72]
1111:../SSC/Src/objdef.c ****                                 break;
 2200              	 .loc 1 1111 0
 2201 03e8 83E0     	 b .L150
 2202              	.L140:
1112:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED32:
1113:../SSC/Src/objdef.c ****                             case    DEFTYPE_INTEGER32:
1114:../SSC/Src/objdef.c ****                             case    DEFTYPE_REAL32:
1115:../SSC/Src/objdef.c ****                             case    DEFTYPE_BITARR32:
1116:../SSC/Src/objdef.c ****                             case    DEFTYPE_DWORD:
1117:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2203              	 .loc 1 1117 0
 2204 03ea FB8D     	 ldrh r3,[r7,#46]
 2205 03ec 03F00F03 	 and r3,r3,#15
 2206 03f0 002B     	 cmp r3,#0
 2207 03f2 01D0     	 beq .L156
1118:../SSC/Src/objdef.c ****                                 {
1119:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1120:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2208              	 .loc 1 1120 0
 2209 03f4 0523     	 movs r3,#5
 2210 03f6 D5E0     	 b .L115
 2211              	.L156:
1121:../SSC/Src/objdef.c ****                                 }
1122:../SSC/Src/objdef.c **** 
1123:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1124:../SSC/Src/objdef.c ****                                 that the 32 bit type are always starting at an exact WORD offset */
1125:../SSC/Src/objdef.c ****                                 pData[0] = pVarPtr[0];
 2212              	 .loc 1 1125 0
 2213 03f8 7B69     	 ldr r3,[r7,#20]
 2214 03fa 1A88     	 ldrh r2,[r3]
 2215 03fc BB6C     	 ldr r3,[r7,#72]
 2216 03fe 1A80     	 strh r2,[r3]
1126:../SSC/Src/objdef.c ****                                 pData[1] = pVarPtr[1];
 2217              	 .loc 1 1126 0
 2218 0400 BB6C     	 ldr r3,[r7,#72]
 2219 0402 0233     	 adds r3,r3,#2
 2220 0404 7A69     	 ldr r2,[r7,#20]
 2221 0406 5288     	 ldrh r2,[r2,#2]
 2222 0408 1A80     	 strh r2,[r3]
1127:../SSC/Src/objdef.c ****                                 pData += 2;
 2223              	 .loc 1 1127 0
 2224 040a BB6C     	 ldr r3,[r7,#72]
 2225 040c 0433     	 adds r3,r3,#4
 2226 040e BB64     	 str r3,[r7,#72]
1128:../SSC/Src/objdef.c ****                                 break;
 2227              	 .loc 1 1128 0
 2228 0410 6FE0     	 b .L150
 2229              	.L133:
1129:../SSC/Src/objdef.c ****                             case    DEFTYPE_REAL64:
1130:../SSC/Src/objdef.c ****                             case 	DEFTYPE_INTEGER64:
1131:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED64:
1132:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2230              	 .loc 1 1132 0
 2231 0412 FB8D     	 ldrh r3,[r7,#46]
 2232 0414 03F00F03 	 and r3,r3,#15
 2233 0418 002B     	 cmp r3,#0
 2234 041a 01D0     	 beq .L157
1133:../SSC/Src/objdef.c ****                                 {
1134:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1135:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2235              	 .loc 1 1135 0
 2236 041c 0523     	 movs r3,#5
 2237 041e C1E0     	 b .L115
 2238              	.L157:
1136:../SSC/Src/objdef.c ****                                 }
1137:../SSC/Src/objdef.c **** 
1138:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1139:../SSC/Src/objdef.c ****                                 that the 64 bit type are always starting at an exact WORD offset */
1140:../SSC/Src/objdef.c ****                                 pData[0] = pVarPtr[0];
 2239              	 .loc 1 1140 0
 2240 0420 7B69     	 ldr r3,[r7,#20]
 2241 0422 1A88     	 ldrh r2,[r3]
 2242 0424 BB6C     	 ldr r3,[r7,#72]
 2243 0426 1A80     	 strh r2,[r3]
1141:../SSC/Src/objdef.c ****                                 pData[1] = pVarPtr[1];
 2244              	 .loc 1 1141 0
 2245 0428 BB6C     	 ldr r3,[r7,#72]
 2246 042a 0233     	 adds r3,r3,#2
 2247 042c 7A69     	 ldr r2,[r7,#20]
 2248 042e 5288     	 ldrh r2,[r2,#2]
 2249 0430 1A80     	 strh r2,[r3]
1142:../SSC/Src/objdef.c ****                                 pData[2] = pVarPtr[2];
 2250              	 .loc 1 1142 0
 2251 0432 BB6C     	 ldr r3,[r7,#72]
 2252 0434 0433     	 adds r3,r3,#4
 2253 0436 7A69     	 ldr r2,[r7,#20]
 2254 0438 9288     	 ldrh r2,[r2,#4]
 2255 043a 1A80     	 strh r2,[r3]
1143:../SSC/Src/objdef.c ****                                 pData[3] = pVarPtr[3];
 2256              	 .loc 1 1143 0
 2257 043c BB6C     	 ldr r3,[r7,#72]
 2258 043e 0633     	 adds r3,r3,#6
 2259 0440 7A69     	 ldr r2,[r7,#20]
 2260 0442 D288     	 ldrh r2,[r2,#6]
 2261 0444 1A80     	 strh r2,[r3]
1144:../SSC/Src/objdef.c ****                                 pData += 4;
 2262              	 .loc 1 1144 0
 2263 0446 BB6C     	 ldr r3,[r7,#72]
 2264 0448 0833     	 adds r3,r3,#8
 2265 044a BB64     	 str r3,[r7,#72]
1145:../SSC/Src/objdef.c ****                                 break;
 2266              	 .loc 1 1145 0
 2267 044c 51E0     	 b .L150
 2268              	.L143:
1146:../SSC/Src/objdef.c ****                             case    DEFTYPE_OCTETSTRING:
1147:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNICODE_STRING:
1148:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_INT :
1149:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_SINT :
1150:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_DINT :
1151:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_UDINT:
1152:../SSC/Src/objdef.c **** 
1153:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2269              	 .loc 1 1153 0
 2270 044e FB8D     	 ldrh r3,[r7,#46]
 2271 0450 03F00F03 	 and r3,r3,#15
 2272 0454 002B     	 cmp r3,#0
 2273 0456 01D0     	 beq .L158
1154:../SSC/Src/objdef.c ****                                 {
1155:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1156:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2274              	 .loc 1 1156 0
 2275 0458 0523     	 movs r3,#5
 2276 045a A3E0     	 b .L115
 2277              	.L158:
1157:../SSC/Src/objdef.c ****                                 }
1158:../SSC/Src/objdef.c **** 
1159:../SSC/Src/objdef.c ****                                 OBJTOMBXMEMCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
 2278              	 .loc 1 1159 0
 2279 045c 7B6A     	 ldr r3,[r7,#36]
 2280 045e 5B88     	 ldrh r3,[r3,#2]
 2281 0460 0733     	 adds r3,r3,#7
 2282 0462 DB10     	 asrs r3,r3,#3
 2283 0464 B86C     	 ldr r0,[r7,#72]
 2284 0466 7969     	 ldr r1,[r7,#20]
 2285 0468 1A46     	 mov r2,r3
 2286 046a FFF7FEFF 	 bl memcpy
1160:../SSC/Src/objdef.c **** 
1161:../SSC/Src/objdef.c ****                                 pData += BIT2WORD((pEntry->BitLength & ~0xF));
 2287              	 .loc 1 1161 0
 2288 046e 7B6A     	 ldr r3,[r7,#36]
 2289 0470 5B88     	 ldrh r3,[r3,#2]
 2290 0472 23F00F03 	 bic r3,r3,#15
 2291 0476 0F33     	 adds r3,r3,#15
 2292 0478 1B11     	 asrs r3,r3,#4
 2293 047a 5B00     	 lsls r3,r3,#1
 2294 047c BA6C     	 ldr r2,[r7,#72]
 2295 047e 1344     	 add r3,r3,r2
 2296 0480 BB64     	 str r3,[r7,#72]
1162:../SSC/Src/objdef.c ****                                 
1163:../SSC/Src/objdef.c ****                                 if((pEntry->BitLength & 0xF) != 0)
 2297              	 .loc 1 1163 0
 2298 0482 7B6A     	 ldr r3,[r7,#36]
 2299 0484 5B88     	 ldrh r3,[r3,#2]
 2300 0486 03F00F03 	 and r3,r3,#15
 2301 048a 002B     	 cmp r3,#0
 2302 048c 06D0     	 beq .L159
1164:../SSC/Src/objdef.c ****                                 {
1165:../SSC/Src/objdef.c ****                                     /*current entry has an odd word length => clear last byte of ne
1166:../SSC/Src/objdef.c ****                                     *pData &= 0xFF;
 2303              	 .loc 1 1166 0
 2304 048e BB6C     	 ldr r3,[r7,#72]
 2305 0490 1B88     	 ldrh r3,[r3]
 2306 0492 DBB2     	 uxtb r3,r3
 2307 0494 9AB2     	 uxth r2,r3
 2308 0496 BB6C     	 ldr r3,[r7,#72]
 2309 0498 1A80     	 strh r2,[r3]
1167:../SSC/Src/objdef.c ****                                 }
1168:../SSC/Src/objdef.c **** 
1169:../SSC/Src/objdef.c ****                                 break;
 2310              	 .loc 1 1169 0
 2311 049a 2AE0     	 b .L150
 2312              	.L159:
 2313 049c 29E0     	 b .L150
 2314              	.L142:
1170:../SSC/Src/objdef.c ****                             case    DEFTYPE_VISIBLESTRING:
1171:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2315              	 .loc 1 1171 0
 2316 049e FB8D     	 ldrh r3,[r7,#46]
 2317 04a0 03F00F03 	 and r3,r3,#15
 2318 04a4 002B     	 cmp r3,#0
 2319 04a6 01D0     	 beq .L160
1172:../SSC/Src/objdef.c ****                                 {
1173:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1174:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2320              	 .loc 1 1174 0
 2321 04a8 0523     	 movs r3,#5
 2322 04aa 7BE0     	 b .L115
 2323              	.L160:
1175:../SSC/Src/objdef.c ****                                 }
1176:../SSC/Src/objdef.c **** 
1177:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1178:../SSC/Src/objdef.c ****                                 that these types are always starting at an even WORD offset */
1179:../SSC/Src/objdef.c ****                                 OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
 2324              	 .loc 1 1179 0
 2325 04ac 7B6A     	 ldr r3,[r7,#36]
 2326 04ae 5B88     	 ldrh r3,[r3,#2]
 2327 04b0 0733     	 adds r3,r3,#7
 2328 04b2 DB10     	 asrs r3,r3,#3
 2329 04b4 B86C     	 ldr r0,[r7,#72]
 2330 04b6 7969     	 ldr r1,[r7,#20]
 2331 04b8 1A46     	 mov r2,r3
 2332 04ba FFF7FEFF 	 bl memcpy
1180:../SSC/Src/objdef.c ****                                 pData += BIT2WORD((pEntry->BitLength & ~0xF));
 2333              	 .loc 1 1180 0
 2334 04be 7B6A     	 ldr r3,[r7,#36]
 2335 04c0 5B88     	 ldrh r3,[r3,#2]
 2336 04c2 23F00F03 	 bic r3,r3,#15
 2337 04c6 0F33     	 adds r3,r3,#15
 2338 04c8 1B11     	 asrs r3,r3,#4
 2339 04ca 5B00     	 lsls r3,r3,#1
 2340 04cc BA6C     	 ldr r2,[r7,#72]
 2341 04ce 1344     	 add r3,r3,r2
 2342 04d0 BB64     	 str r3,[r7,#72]
1181:../SSC/Src/objdef.c **** 
1182:../SSC/Src/objdef.c ****                                 if((pEntry->BitLength & 0xF) != 0)
 2343              	 .loc 1 1182 0
 2344 04d2 7B6A     	 ldr r3,[r7,#36]
 2345 04d4 5B88     	 ldrh r3,[r3,#2]
 2346 04d6 03F00F03 	 and r3,r3,#15
 2347 04da 002B     	 cmp r3,#0
 2348 04dc 06D0     	 beq .L161
1183:../SSC/Src/objdef.c ****                                 {
1184:../SSC/Src/objdef.c ****                                     /*current entry has an odd word length => clear last byte of ne
1185:../SSC/Src/objdef.c ****                                     *pData &= 0xFF;
 2349              	 .loc 1 1185 0
 2350 04de BB6C     	 ldr r3,[r7,#72]
 2351 04e0 1B88     	 ldrh r3,[r3]
 2352 04e2 DBB2     	 uxtb r3,r3
 2353 04e4 9AB2     	 uxth r2,r3
 2354 04e6 BB6C     	 ldr r3,[r7,#72]
 2355 04e8 1A80     	 strh r2,[r3]
1186:../SSC/Src/objdef.c ****                                 }
1187:../SSC/Src/objdef.c ****                                 
1188:../SSC/Src/objdef.c ****                                 break;
 2356              	 .loc 1 1188 0
 2357 04ea 02E0     	 b .L150
 2358              	.L161:
 2359 04ec 01E0     	 b .L150
 2360              	.L132:
1189:../SSC/Src/objdef.c ****                             default:
1190:../SSC/Src/objdef.c ****                                 /* other data types are not supported from this example */
1191:../SSC/Src/objdef.c ****                                 return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 2361              	 .loc 1 1191 0
 2362 04ee 1823     	 movs r3,#24
 2363 04f0 58E0     	 b .L115
 2364              	.L150:
1192:../SSC/Src/objdef.c ****                             } //switch (deftype)
1193:../SSC/Src/objdef.c **** 
1194:../SSC/Src/objdef.c ****                             bRead = 1;
 2365              	 .loc 1 1194 0
 2366 04f2 0123     	 movs r3,#1
 2367 04f4 87F83130 	 strb r3,[r7,#49]
 2368              	.LBE14:
 2369              	.LBE13:
 2370 04f8 44E0     	 b .L162
 2371              	.L127:
 2372 04fa 43E0     	 b .L162
 2373              	.L125:
 2374              	.LBB16:
1195:../SSC/Src/objdef.c ****                         }
1196:../SSC/Src/objdef.c ****                     }
1197:../SSC/Src/objdef.c ****                 }
1198:../SSC/Src/objdef.c ****                 else
1199:../SSC/Src/objdef.c ****                 {
1200:../SSC/Src/objdef.c ****                     /*No access to current object entry => shift pData if required*/
1201:../SSC/Src/objdef.c ****                     UINT8 cnt = 0;
 2375              	 .loc 1 1201 0
 2376 04fc 0023     	 movs r3,#0
 2377 04fe 87F82B30 	 strb r3,[r7,#43]
1202:../SSC/Src/objdef.c **** 
1203:../SSC/Src/objdef.c ****                     /*If this entry is the first in the 16Bit block clear the memory*/
1204:../SSC/Src/objdef.c ****                     if ((bitOffset & 0x0F) == 0) 
 2378              	 .loc 1 1204 0
 2379 0502 FB8D     	 ldrh r3,[r7,#46]
 2380 0504 03F00F03 	 and r3,r3,#15
 2381 0508 002B     	 cmp r3,#0
 2382 050a 02D1     	 bne .L163
1205:../SSC/Src/objdef.c ****                     {
1206:../SSC/Src/objdef.c ****                         *pData = 0;
 2383              	 .loc 1 1206 0
 2384 050c BB6C     	 ldr r3,[r7,#72]
 2385 050e 0022     	 movs r2,#0
 2386 0510 1A80     	 strh r2,[r3]
 2387              	.L163:
1207:../SSC/Src/objdef.c ****                     }
1208:../SSC/Src/objdef.c **** 
1209:../SSC/Src/objdef.c ****                     /*Handle Bit/Byte Offset*/
1210:../SSC/Src/objdef.c ****                     if (((pEntry->BitLength & 0xF) > 0)
 2388              	 .loc 1 1210 0
 2389 0512 7B6A     	 ldr r3,[r7,#36]
 2390 0514 5B88     	 ldrh r3,[r3,#2]
 2391 0516 03F00F03 	 and r3,r3,#15
 2392 051a 002B     	 cmp r3,#0
 2393 051c 0DDD     	 ble .L164
1211:../SSC/Src/objdef.c ****                         && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 2394              	 .loc 1 1211 0
 2395 051e FB8D     	 ldrh r3,[r7,#46]
 2396 0520 7A6A     	 ldr r2,[r7,#36]
 2397 0522 5288     	 ldrh r2,[r2,#2]
 2398 0524 1344     	 add r3,r3,r2
 2399 0526 03F00F03 	 and r3,r3,#15
 2400 052a 002B     	 cmp r3,#0
 2401 052c 05D1     	 bne .L164
1212:../SSC/Src/objdef.c ****                     {
1213:../SSC/Src/objdef.c ****                         /* we have reached the UINT16 border */
1214:../SSC/Src/objdef.c ****                         pData++;
 2402              	 .loc 1 1214 0
 2403 052e BB6C     	 ldr r3,[r7,#72]
 2404 0530 0233     	 adds r3,r3,#2
 2405 0532 BB64     	 str r3,[r7,#72]
1215:../SSC/Src/objdef.c ****                         
1216:../SSC/Src/objdef.c ****                         /*Clear new buffer*/
1217:../SSC/Src/objdef.c ****                         *pData = 0;
 2406              	 .loc 1 1217 0
 2407 0534 BB6C     	 ldr r3,[r7,#72]
 2408 0536 0022     	 movs r2,#0
 2409 0538 1A80     	 strh r2,[r3]
 2410              	.L164:
1218:../SSC/Src/objdef.c ****                     }
1219:../SSC/Src/objdef.c **** 
1220:../SSC/Src/objdef.c ****                     /*increment WORD offset*/
1221:../SSC/Src/objdef.c ****                     for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
 2411              	 .loc 1 1221 0
 2412 053a 0023     	 movs r3,#0
 2413 053c 87F82B30 	 strb r3,[r7,#43]
 2414 0540 0AE0     	 b .L165
 2415              	.L166:
1222:../SSC/Src/objdef.c ****                     {
1223:../SSC/Src/objdef.c ****                         
1224:../SSC/Src/objdef.c ****                         /*current 16Bit are skipped => clear current buffer */
1225:../SSC/Src/objdef.c ****                         pData++;
 2416              	 .loc 1 1225 0 discriminator 3
 2417 0542 BB6C     	 ldr r3,[r7,#72]
 2418 0544 0233     	 adds r3,r3,#2
 2419 0546 BB64     	 str r3,[r7,#72]
1226:../SSC/Src/objdef.c **** 
1227:../SSC/Src/objdef.c ****                         /*Clear new buffer*/
1228:../SSC/Src/objdef.c ****                         *pData = 0;
 2420              	 .loc 1 1228 0 discriminator 3
 2421 0548 BB6C     	 ldr r3,[r7,#72]
 2422 054a 0022     	 movs r2,#0
 2423 054c 1A80     	 strh r2,[r3]
1221:../SSC/Src/objdef.c ****                     {
 2424              	 .loc 1 1221 0 discriminator 3
 2425 054e 97F82B30 	 ldrb r3,[r7,#43]
 2426 0552 0133     	 adds r3,r3,#1
 2427 0554 87F82B30 	 strb r3,[r7,#43]
 2428              	.L165:
1221:../SSC/Src/objdef.c ****                     {
 2429              	 .loc 1 1221 0 is_stmt 0 discriminator 1
 2430 0558 97F82B20 	 ldrb r2,[r7,#43]
 2431 055c 7B6A     	 ldr r3,[r7,#36]
 2432 055e 5B88     	 ldrh r3,[r3,#2]
 2433 0560 03F0F003 	 and r3,r3,#240
 2434 0564 1B11     	 asrs r3,r3,#4
 2435 0566 9A42     	 cmp r2,r3
 2436 0568 EBDB     	 blt .L166
1229:../SSC/Src/objdef.c ****                     }
1230:../SSC/Src/objdef.c **** 
1231:../SSC/Src/objdef.c **** 
1232:../SSC/Src/objdef.c ****                     
1233:../SSC/Src/objdef.c **** 
1234:../SSC/Src/objdef.c ****                     /* we don't have read access */
1235:../SSC/Src/objdef.c ****                     if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
 2437              	 .loc 1 1235 0 is_stmt 1
 2438 056a 7B6A     	 ldr r3,[r7,#36]
 2439 056c 9B88     	 ldrh r3,[r3,#4]
 2440 056e 03F00703 	 and r3,r3,#7
 2441 0572 002B     	 cmp r3,#0
 2442 0574 03D1     	 bne .L167
1236:../SSC/Src/objdef.c ****                     {
1237:../SSC/Src/objdef.c ****                         /* it is a write only entry */
1238:../SSC/Src/objdef.c ****                         result = ABORTIDX_WRITE_ONLY_ENTRY;
 2443              	 .loc 1 1238 0
 2444 0576 0623     	 movs r3,#6
 2445 0578 87F83030 	 strb r3,[r7,#48]
 2446 057c 02E0     	 b .L162
 2447              	.L167:
1239:../SSC/Src/objdef.c ****                     }
1240:../SSC/Src/objdef.c ****                     else
1241:../SSC/Src/objdef.c ****                     {
1242:../SSC/Src/objdef.c ****                         /* we don't have read access in this state */
1243:../SSC/Src/objdef.c ****                         result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 2448              	 .loc 1 1243 0
 2449 057e 1A23     	 movs r3,#26
 2450 0580 87F83030 	 strb r3,[r7,#48]
 2451              	.L162:
 2452              	.LBE16:
 2453              	.LBE12:
 957:../SSC/Src/objdef.c ****             {
 2454              	 .loc 1 957 0 discriminator 2
 2455 0584 FB8E     	 ldrh r3,[r7,#54]
 2456 0586 0133     	 adds r3,r3,#1
 2457 0588 FB86     	 strh r3,[r7,#54]
 2458              	.L123:
 957:../SSC/Src/objdef.c ****             {
 2459              	 .loc 1 957 0 is_stmt 0 discriminator 1
 2460 058a FA8E     	 ldrh r2,[r7,#54]
 2461 058c 7B8E     	 ldrh r3,[r7,#50]
 2462 058e 9A42     	 cmp r2,r3
 2463 0590 7FF6ECAD 	 bls .L168
1244:../SSC/Src/objdef.c ****                     }
1245:../SSC/Src/objdef.c ****                 }
1246:../SSC/Src/objdef.c ****             }
1247:../SSC/Src/objdef.c **** 
1248:../SSC/Src/objdef.c ****             if(bRead == 0)
 2464              	 .loc 1 1248 0 is_stmt 1
 2465 0594 97F83130 	 ldrb r3,[r7,#49]
 2466 0598 002B     	 cmp r3,#0
 2467 059a 02D1     	 bne .L122
1249:../SSC/Src/objdef.c ****             {
1250:../SSC/Src/objdef.c ****                 return result;
 2468              	 .loc 1 1250 0
 2469 059c 97F83030 	 ldrb r3,[r7,#48]
 2470 05a0 00E0     	 b .L115
 2471              	.L122:
 2472              	.LBE11:
1251:../SSC/Src/objdef.c ****             }
1252:../SSC/Src/objdef.c ****         }
1253:../SSC/Src/objdef.c **** 
1254:../SSC/Src/objdef.c ****     return 0;
 2473              	 .loc 1 1254 0
 2474 05a2 0023     	 movs r3,#0
 2475              	.L115:
1255:../SSC/Src/objdef.c **** }
 2476              	 .loc 1 1255 0
 2477 05a4 1846     	 mov r0,r3
 2478 05a6 3C37     	 adds r7,r7,#60
 2479              	.LCFI59:
 2480              	 .cfi_def_cfa_offset 12
 2481 05a8 BD46     	 mov sp,r7
 2482              	.LCFI60:
 2483              	 .cfi_def_cfa_register 13
 2484              	 
 2485 05aa 90BD     	 pop {r4,r7,pc}
 2486              	.L172:
 2487              	 .align 2
 2488              	.L171:
 2489 05ac 00000000 	 .word cBitMask
 2490              	 .cfi_endproc
 2491              	.LFE189:
 2493              	 .section .text.OBJ_Write,"ax",%progbits
 2494              	 .align 2
 2495              	 .global OBJ_Write
 2496              	 .thumb
 2497              	 .thumb_func
 2499              	OBJ_Write:
 2500              	.LFB190:
1256:../SSC/Src/objdef.c **** 
1257:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
1258:../SSC/Src/objdef.c **** /**
1259:../SSC/Src/objdef.c ****  \param     index                 index of the requested object.
1260:../SSC/Src/objdef.c ****  \param     subindex                subindex of the requested object.
1261:../SSC/Src/objdef.c ****  \param    dataSize                received data size of the SDO Download
1262:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
1263:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
1264:../SSC/Src/objdef.c ****  \param    pData                    Pointer to the buffer where the written data can be copied from
1265:../SSC/Src/objdef.c ****  \param    bCompleteAccess    Indicates if a complete write of all subindices of the
1266:../SSC/Src/objdef.c ****                                      object shall be done or not
1267:../SSC/Src/objdef.c **** 
1268:../SSC/Src/objdef.c ****  \return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
1269:../SSC/Src/objdef.c ****             sdosrv.h))
1270:../SSC/Src/objdef.c **** 
1271:../SSC/Src/objdef.c ****  \brief    This function writes the requested object
1272:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
1273:../SSC/Src/objdef.c **** 
1274:../SSC/Src/objdef.c **** UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry
1275:../SSC/Src/objdef.c **** {
 2501              	 .loc 1 1275 0
 2502              	 .cfi_startproc
 2503              	 
 2504              	 
 2505 0000 90B5     	 push {r4,r7,lr}
 2506              	.LCFI61:
 2507              	 .cfi_def_cfa_offset 12
 2508              	 .cfi_offset 4,-12
 2509              	 .cfi_offset 7,-8
 2510              	 .cfi_offset 14,-4
 2511 0002 91B0     	 sub sp,sp,#68
 2512              	.LCFI62:
 2513              	 .cfi_def_cfa_offset 80
 2514 0004 02AF     	 add r7,sp,#8
 2515              	.LCFI63:
 2516              	 .cfi_def_cfa 7,72
 2517 0006 BA60     	 str r2,[r7,#8]
 2518 0008 7B60     	 str r3,[r7,#4]
 2519 000a 0346     	 mov r3,r0
 2520 000c FB81     	 strh r3,[r7,#14]
 2521 000e 0B46     	 mov r3,r1
 2522 0010 7B73     	 strb r3,[r7,#13]
1276:../SSC/Src/objdef.c ****     UINT16 i = subindex;
 2523              	 .loc 1 1276 0
 2524 0012 7B7B     	 ldrb r3,[r7,#13]
 2525 0014 FB86     	 strh r3,[r7,#54]
1277:../SSC/Src/objdef.c ****     /* get the information of ObjCode and MaxSubindex in local variables to support different types
1278:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 2526              	 .loc 1 1278 0
 2527 0016 7B68     	 ldr r3,[r7,#4]
 2528 0018 9B89     	 ldrh r3,[r3,#12]
 2529 001a 03F47063 	 and r3,r3,#3840
 2530 001e 1B12     	 asrs r3,r3,#8
 2531 0020 87F82330 	 strb r3,[r7,#35]
1279:../SSC/Src/objdef.c ****     UINT16 maxSubindex = 0;
 2532              	 .loc 1 1279 0
 2533 0024 0023     	 movs r3,#0
 2534 0026 BB86     	 strh r3,[r7,#52]
1280:../SSC/Src/objdef.c ****     UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJF
 2535              	 .loc 1 1280 0
 2536 0028 7B68     	 ldr r3,[r7,#4]
 2537 002a 9B89     	 ldrh r3,[r3,#12]
 2538 002c DBB2     	 uxtb r3,r3
 2539 002e 3B84     	 strh r3,[r7,#32]
1281:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
1282:../SSC/Src/objdef.c ****     BOOL bClearSubindex0Required = FALSE;
 2540              	 .loc 1 1282 0
 2541 0030 0023     	 movs r3,#0
 2542 0032 87F83330 	 strb r3,[r7,#51]
1283:../SSC/Src/objdef.c ****     /* lastSubindex is used for complete access to make loop over the requested entries
1284:../SSC/Src/objdef.c ****        to be read, we initialize this variable with the requested subindex that only
1285:../SSC/Src/objdef.c ****        one loop will be done for a single access */
1286:../SSC/Src/objdef.c ****     UINT16 lastSubindex = subindex;
 2543              	 .loc 1 1286 0
 2544 0036 7B7B     	 ldrb r3,[r7,#13]
 2545 0038 3B86     	 strh r3,[r7,#48]
1287:../SSC/Src/objdef.c **** 
1288:../SSC/Src/objdef.c ****     /* if subindex 0 is writable, the maximum subindex should be checked in an object specific func
1289:../SSC/Src/objdef.c ****         because for the PDO mapping and PDO assign the object shall only be written if subindex 0 i
1290:../SSC/Src/objdef.c ****     if ( objCode != OBJCODE_VAR )
 2546              	 .loc 1 1290 0
 2547 003a 97F82330 	 ldrb r3,[r7,#35]
 2548 003e 072B     	 cmp r3,#7
 2549 0040 28D0     	 beq .L174
1291:../SSC/Src/objdef.c ****     {
1292:../SSC/Src/objdef.c ****         /* if the object is an array or record we have to get the maxSubindex from the
1293:../SSC/Src/objdef.c ****            actual value of subindex 0, which is stored as UINT16 at the beginning of the
1294:../SSC/Src/objdef.c ****             object's variable */
1295:../SSC/Src/objdef.c ****         maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
 2550              	 .loc 1 1295 0
 2551 0042 7B68     	 ldr r3,[r7,#4]
 2552 0044 9B69     	 ldr r3,[r3,#24]
 2553 0046 1B88     	 ldrh r3,[r3]
 2554 0048 DBB2     	 uxtb r3,r3
 2555 004a BB86     	 strh r3,[r7,#52]
1296:../SSC/Src/objdef.c **** 
1297:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.12) COE9*/
1298:../SSC/Src/objdef.c ****         /*If the subindex0 of a PDO assign or PDO mapping object is 0 the maximum subindex is speci
1299:../SSC/Src/objdef.c ****         if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (in
 2556              	 .loc 1 1299 0
 2557 004c BB8E     	 ldrh r3,[r7,#52]
 2558 004e 002B     	 cmp r3,#0
 2559 0050 20D1     	 bne .L174
 2560              	 .loc 1 1299 0 is_stmt 0 discriminator 1
 2561 0052 FB89     	 ldrh r3,[r7,#14]
 2562 0054 41F60F42 	 movw r2,#7183
 2563 0058 9342     	 cmp r3,r2
 2564 005a 04D9     	 bls .L175
 2565              	 .loc 1 1299 0 discriminator 2
 2566 005c FB89     	 ldrh r3,[r7,#14]
 2567 005e 41F62F42 	 movw r2,#7215
 2568 0062 9342     	 cmp r3,r2
 2569 0064 14D9     	 bls .L176
 2570              	.L175:
 2571              	 .loc 1 1299 0 discriminator 4
 2572 0066 FB89     	 ldrh r3,[r7,#14]
 2573 0068 B3F5B05F 	 cmp r3,#5632
 2574 006c 03D3     	 bcc .L177
 2575              	 .loc 1 1299 0 discriminator 5
 2576 006e FB89     	 ldrh r3,[r7,#14]
 2577 0070 B3F5C05F 	 cmp r3,#6144
 2578 0074 0CD3     	 bcc .L176
 2579              	.L177:
 2580              	 .loc 1 1299 0 discriminator 7
 2581 0076 FB89     	 ldrh r3,[r7,#14]
 2582 0078 B3F5D05F 	 cmp r3,#6656
 2583 007c 03D3     	 bcc .L178
 2584              	 .loc 1 1299 0 discriminator 8
 2585 007e FB89     	 ldrh r3,[r7,#14]
 2586 0080 B3F5E05F 	 cmp r3,#7168
 2587 0084 04D3     	 bcc .L176
 2588              	.L178:
 2589              	 .loc 1 1299 0 discriminator 10
 2590 0086 FB89     	 ldrh r3,[r7,#14]
 2591 0088 4FF23002 	 movw r2,#61488
 2592 008c 9342     	 cmp r3,r2
 2593 008e 01D1     	 bne .L174
 2594              	.L176:
1300:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.12) COE9*/
1301:../SSC/Src/objdef.c ****         {
1302:../SSC/Src/objdef.c ****             maxSubindex = maxConfiguredSubindex;
 2595              	 .loc 1 1302 0 is_stmt 1
 2596 0090 3B8C     	 ldrh r3,[r7,#32]
 2597 0092 BB86     	 strh r3,[r7,#52]
 2598              	.L174:
1303:../SSC/Src/objdef.c ****         }
1304:../SSC/Src/objdef.c ****     }
1305:../SSC/Src/objdef.c **** 
1306:../SSC/Src/objdef.c **** 
1307:../SSC/Src/objdef.c ****     if ( bCompleteAccess )
 2599              	 .loc 1 1307 0
 2600 0094 97F84C30 	 ldrb r3,[r7,#76]
 2601 0098 002B     	 cmp r3,#0
 2602 009a 12D0     	 beq .L179
1308:../SSC/Src/objdef.c ****     {
1309:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR )
 2603              	 .loc 1 1309 0
 2604 009c 97F82330 	 ldrb r3,[r7,#35]
 2605 00a0 072B     	 cmp r3,#7
 2606 00a2 01D1     	 bne .L180
1310:../SSC/Src/objdef.c ****         {
1311:../SSC/Src/objdef.c ****             /* complete access is not supported with simple objects */
1312:../SSC/Src/objdef.c ****             return ABORTIDX_UNSUPPORTED_ACCESS;
 2607              	 .loc 1 1312 0
 2608 00a4 0523     	 movs r3,#5
 2609 00a6 0FE3     	 b .L181
 2610              	.L180:
1313:../SSC/Src/objdef.c ****         }
1314:../SSC/Src/objdef.c **** 
1315:../SSC/Src/objdef.c ****         if ((subindex == 0) && (dataSize > 0))
 2611              	 .loc 1 1315 0
 2612 00a8 7B7B     	 ldrb r3,[r7,#13]
 2613 00aa 002B     	 cmp r3,#0
 2614 00ac 06D1     	 bne .L182
 2615              	 .loc 1 1315 0 is_stmt 0 discriminator 1
 2616 00ae BB68     	 ldr r3,[r7,#8]
 2617 00b0 002B     	 cmp r3,#0
 2618 00b2 03D0     	 beq .L182
1316:../SSC/Src/objdef.c ****         {
1317:../SSC/Src/objdef.c ****             /* we change the subindex 0 */
1318:../SSC/Src/objdef.c ****             maxSubindex = (UINT8) SWAPWORD(pData[0]);
 2619              	 .loc 1 1318 0 is_stmt 1
 2620 00b4 BB6C     	 ldr r3,[r7,#72]
 2621 00b6 1B88     	 ldrh r3,[r3]
 2622 00b8 DBB2     	 uxtb r3,r3
 2623 00ba BB86     	 strh r3,[r7,#52]
 2624              	.L182:
1319:../SSC/Src/objdef.c ****         }
1320:../SSC/Src/objdef.c **** 
1321:../SSC/Src/objdef.c **** 
1322:../SSC/Src/objdef.c ****         /* we write until the maximum subindex */
1323:../SSC/Src/objdef.c ****         lastSubindex = maxSubindex;
 2625              	 .loc 1 1323 0
 2626 00bc BB8E     	 ldrh r3,[r7,#52]
 2627 00be 3B86     	 strh r3,[r7,#48]
 2628 00c0 2AE0     	 b .L183
 2629              	.L179:
1324:../SSC/Src/objdef.c ****     }
1325:../SSC/Src/objdef.c ****     else
1326:../SSC/Src/objdef.c ****     if (subindex > maxSubindex)
 2630              	 .loc 1 1326 0
 2631 00c2 7B7B     	 ldrb r3,[r7,#13]
 2632 00c4 9BB2     	 uxth r3,r3
 2633 00c6 BA8E     	 ldrh r2,[r7,#52]
 2634 00c8 9A42     	 cmp r2,r3
 2635 00ca 01D2     	 bcs .L184
1327:../SSC/Src/objdef.c ****     {
1328:../SSC/Src/objdef.c ****         /* the maximum subindex is reached */
1329:../SSC/Src/objdef.c ****         return ABORTIDX_SUBINDEX_NOT_EXISTING;
 2636              	 .loc 1 1329 0
 2637 00cc 1123     	 movs r3,#17
 2638 00ce FBE2     	 b .L181
 2639              	.L184:
1330:../SSC/Src/objdef.c ****     }
1331:../SSC/Src/objdef.c ****     else
1332:../SSC/Src/objdef.c ****     {
1333:../SSC/Src/objdef.c ****         /* we check the write access for single accesses here, a complete write access
1334:../SSC/Src/objdef.c ****            is allowed if at least one entry is writable (in this case the values for the
1335:../SSC/Src/objdef.c ****             read only entries shall be ignored) */
1336:../SSC/Src/objdef.c ****         /* we get the corresponding entry description */
1337:../SSC/Src/objdef.c ****         pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
 2640              	 .loc 1 1337 0
 2641 00d0 7B7B     	 ldrb r3,[r7,#13]
 2642 00d2 7868     	 ldr r0,[r7,#4]
 2643 00d4 1946     	 mov r1,r3
 2644 00d6 FFF7FEFF 	 bl OBJ_GetEntryDesc
 2645 00da F861     	 str r0,[r7,#28]
1338:../SSC/Src/objdef.c **** 
1339:../SSC/Src/objdef.c ****         /* check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
1340:../SSC/Src/objdef.c ****            by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
1341:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.12) COE3*/
1342:../SSC/Src/objdef.c ****         if (0 == (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
 2646              	 .loc 1 1342 0
 2647 00dc FB69     	 ldr r3,[r7,#28]
 2648 00de 9B88     	 ldrh r3,[r3,#4]
 2649 00e0 03F03803 	 and r3,r3,#56
 2650 00e4 9B10     	 asrs r3,r3,#2
 2651 00e6 DBB2     	 uxtb r3,r3
 2652 00e8 1A46     	 mov r2,r3
 2653 00ea A24B     	 ldr r3,.L248
 2654 00ec 1B78     	 ldrb r3,[r3]
 2655 00ee 03F00F03 	 and r3,r3,#15
 2656 00f2 1340     	 ands r3,r3,r2
 2657 00f4 002B     	 cmp r3,#0
 2658 00f6 0FD1     	 bne .L183
1343:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.12) COE3*/
1344:../SSC/Src/objdef.c ****         {
1345:../SSC/Src/objdef.c ****             /* we don't have write access */
1346:../SSC/Src/objdef.c ****             if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
 2659              	 .loc 1 1346 0
 2660 00f8 FB69     	 ldr r3,[r7,#28]
 2661 00fa 9B88     	 ldrh r3,[r3,#4]
 2662 00fc 03F03803 	 and r3,r3,#56
 2663 0100 002B     	 cmp r3,#0
 2664 0102 07D1     	 bne .L185
1347:../SSC/Src/objdef.c ****             {
1348:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.12) COE7*/
1349:../SSC/Src/objdef.c ****                 if (pEntry->ObjAccess == 0)
 2665              	 .loc 1 1349 0
 2666 0104 FB69     	 ldr r3,[r7,#28]
 2667 0106 9B88     	 ldrh r3,[r3,#4]
 2668 0108 002B     	 cmp r3,#0
 2669 010a 01D1     	 bne .L186
1350:../SSC/Src/objdef.c ****                 {
1351:../SSC/Src/objdef.c ****                         return ABORTIDX_UNSUPPORTED_ACCESS;
 2670              	 .loc 1 1351 0
 2671 010c 0523     	 movs r3,#5
 2672 010e DBE2     	 b .L181
 2673              	.L186:
1352:../SSC/Src/objdef.c ****                 }
1353:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.12) COE7*/
1354:../SSC/Src/objdef.c ****                 else
1355:../SSC/Src/objdef.c ****                 {
1356:../SSC/Src/objdef.c ****                         /* it is a read only entry */
1357:../SSC/Src/objdef.c ****                         return ABORTIDX_READ_ONLY_ENTRY;
 2674              	 .loc 1 1357 0
 2675 0110 0723     	 movs r3,#7
 2676 0112 D9E2     	 b .L181
 2677              	.L185:
1358:../SSC/Src/objdef.c ****                 }
1359:../SSC/Src/objdef.c ****             }
1360:../SSC/Src/objdef.c ****             else
1361:../SSC/Src/objdef.c ****             {
1362:../SSC/Src/objdef.c ****                 /* we don't have write access in this state */
1363:../SSC/Src/objdef.c ****                 return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 2678              	 .loc 1 1363 0
 2679 0114 1A23     	 movs r3,#26
 2680 0116 D7E2     	 b .L181
 2681              	.L183:
1364:../SSC/Src/objdef.c ****             }
1365:../SSC/Src/objdef.c ****         }
1366:../SSC/Src/objdef.c ****     }
1367:../SSC/Src/objdef.c **** 
1368:../SSC/Src/objdef.c ****     /* Subindex 0 shall be set to zero if a single PDO / PDO assign entry is written
1369:../SSC/Src/objdef.c ****     or a complete access without subindex0 is requested */
1370:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.12) COE9*/
1371:../SSC/Src/objdef.c ****     if((subindex > 0) &&
 2682              	 .loc 1 1371 0
 2683 0118 7B7B     	 ldrb r3,[r7,#13]
 2684 011a 002B     	 cmp r3,#0
 2685 011c 29D0     	 beq .L187
 2686              	 .loc 1 1371 0 is_stmt 0 discriminator 1
 2687 011e FB89     	 ldrh r3,[r7,#14]
 2688 0120 41F60F42 	 movw r2,#7183
 2689 0124 9342     	 cmp r3,r2
 2690 0126 04D9     	 bls .L188
1372:../SSC/Src/objdef.c ****         (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
 2691              	 .loc 1 1372 0 is_stmt 1
 2692 0128 FB89     	 ldrh r3,[r7,#14]
 2693 012a 41F62F42 	 movw r2,#7215
 2694 012e 9342     	 cmp r3,r2
 2695 0130 14D9     	 bls .L189
 2696              	.L188:
 2697              	 .loc 1 1372 0 is_stmt 0 discriminator 1
 2698 0132 FB89     	 ldrh r3,[r7,#14]
 2699 0134 B3F5B05F 	 cmp r3,#5632
 2700 0138 03D3     	 bcc .L190
 2701              	 .loc 1 1372 0 discriminator 2
 2702 013a FB89     	 ldrh r3,[r7,#14]
 2703 013c B3F5C05F 	 cmp r3,#6144
 2704 0140 0CD3     	 bcc .L189
 2705              	.L190:
 2706              	 .loc 1 1372 0 discriminator 4
 2707 0142 FB89     	 ldrh r3,[r7,#14]
 2708 0144 B3F5D05F 	 cmp r3,#6656
 2709 0148 03D3     	 bcc .L191
 2710              	 .loc 1 1372 0 discriminator 5
 2711 014a FB89     	 ldrh r3,[r7,#14]
 2712 014c B3F5E05F 	 cmp r3,#7168
 2713 0150 04D3     	 bcc .L189
 2714              	.L191:
 2715              	 .loc 1 1372 0 discriminator 7
 2716 0152 FB89     	 ldrh r3,[r7,#14]
 2717 0154 4FF23002 	 movw r2,#61488
 2718 0158 9342     	 cmp r3,r2
 2719 015a 0AD1     	 bne .L187
 2720              	.L189:
 2721              	.LBB17:
1373:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.12) COE9*/
1374:../SSC/Src/objdef.c ****         )
1375:../SSC/Src/objdef.c ****     {
1376:../SSC/Src/objdef.c ****         /*Check if Subindex0 was cleared before*/
1377:../SSC/Src/objdef.c ****         UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
 2722              	 .loc 1 1377 0 is_stmt 1
 2723 015c 7B68     	 ldr r3,[r7,#4]
 2724 015e 9B69     	 ldr r3,[r3,#24]
 2725 0160 1B88     	 ldrh r3,[r3]
 2726 0162 DBB2     	 uxtb r3,r3
 2727 0164 7B83     	 strh r3,[r7,#26]
1378:../SSC/Src/objdef.c ****         if(Subindex0 != 0x00)
 2728              	 .loc 1 1378 0
 2729 0166 7B8B     	 ldrh r3,[r7,#26]
 2730 0168 002B     	 cmp r3,#0
 2731 016a 02D0     	 beq .L187
1379:../SSC/Src/objdef.c ****         {
1380:../SSC/Src/objdef.c ****             bClearSubindex0Required = TRUE;
 2732              	 .loc 1 1380 0
 2733 016c 0123     	 movs r3,#1
 2734 016e 87F83330 	 strb r3,[r7,#51]
 2735              	.L187:
 2736              	.LBE17:
1381:../SSC/Src/objdef.c ****         }
1382:../SSC/Src/objdef.c ****     }
1383:../SSC/Src/objdef.c **** 
1384:../SSC/Src/objdef.c ****     if ( pObjEntry->Write != NULL )
 2737              	 .loc 1 1384 0
 2738 0172 7B68     	 ldr r3,[r7,#4]
 2739 0174 1B6A     	 ldr r3,[r3,#32]
 2740 0176 002B     	 cmp r3,#0
 2741 0178 0DD0     	 beq .L192
1385:../SSC/Src/objdef.c ****     {
1386:../SSC/Src/objdef.c ****         /* Write function is defined, we call the object specific write function */
1387:../SSC/Src/objdef.c ****         return pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
 2742              	 .loc 1 1387 0
 2743 017a 7B68     	 ldr r3,[r7,#4]
 2744 017c 1C6A     	 ldr r4,[r3,#32]
 2745 017e F989     	 ldrh r1,[r7,#14]
 2746 0180 7A7B     	 ldrb r2,[r7,#13]
 2747 0182 97F84C30 	 ldrb r3,[r7,#76]
 2748 0186 0093     	 str r3,[sp]
 2749 0188 0846     	 mov r0,r1
 2750 018a 1146     	 mov r1,r2
 2751 018c BA68     	 ldr r2,[r7,#8]
 2752 018e BB6C     	 ldr r3,[r7,#72]
 2753 0190 A047     	 blx r4
 2754 0192 0346     	 mov r3,r0
 2755 0194 98E2     	 b .L181
 2756              	.L192:
 2757              	.LBB18:
1388:../SSC/Src/objdef.c ****     }
1389:../SSC/Src/objdef.c ****     else
1390:../SSC/Src/objdef.c ****     {
1391:../SSC/Src/objdef.c ****         UINT8 bWritten = 0;
 2758              	 .loc 1 1391 0
 2759 0196 0023     	 movs r3,#0
 2760 0198 87F82F30 	 strb r3,[r7,#47]
1392:../SSC/Src/objdef.c ****         UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
 2761              	 .loc 1 1392 0
 2762 019c 0723     	 movs r3,#7
 2763 019e 87F82E30 	 strb r3,[r7,#46]
1393:../SSC/Src/objdef.c **** 
1394:../SSC/Src/objdef.c ****         if (dataSize == 0)
 2764              	 .loc 1 1394 0
 2765 01a2 BB68     	 ldr r3,[r7,#8]
 2766 01a4 002B     	 cmp r3,#0
 2767 01a6 01D1     	 bne .L193
1395:../SSC/Src/objdef.c ****         {
1396:../SSC/Src/objdef.c ****            return 0; //no error
 2768              	 .loc 1 1396 0
 2769 01a8 0023     	 movs r3,#0
 2770 01aa 8DE2     	 b .L181
 2771              	.L193:
1397:../SSC/Src/objdef.c ****         }
1398:../SSC/Src/objdef.c **** 
1399:../SSC/Src/objdef.c ****         /* we use the standard write function */
1400:../SSC/Src/objdef.c ****         for (i = subindex; i <= lastSubindex; i++)
 2772              	 .loc 1 1400 0
 2773 01ac 7B7B     	 ldrb r3,[r7,#13]
 2774 01ae FB86     	 strh r3,[r7,#54]
 2775 01b0 7DE2     	 b .L194
 2776              	.L246:
 2777              	.LBB19:
1401:../SSC/Src/objdef.c ****         {
1402:../SSC/Src/objdef.c ****             /* if only a single entry is requested, this loop will only be done once */
1403:../SSC/Src/objdef.c ****             UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 2778              	 .loc 1 1403 0
 2779 01b2 7B68     	 ldr r3,[r7,#4]
 2780 01b4 9B69     	 ldr r3,[r3,#24]
 2781 01b6 BB62     	 str r3,[r7,#40]
1404:../SSC/Src/objdef.c ****             UINT16 bitOffset = 0;
 2782              	 .loc 1 1404 0
 2783 01b8 0023     	 movs r3,#0
 2784 01ba 3B83     	 strh r3,[r7,#24]
1405:../SSC/Src/objdef.c **** 
1406:../SSC/Src/objdef.c ****             /* we get the corresponding entry description */
1407:../SSC/Src/objdef.c ****             pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
 2785              	 .loc 1 1407 0
 2786 01bc FB8E     	 ldrh r3,[r7,#54]
 2787 01be DBB2     	 uxtb r3,r3
 2788 01c0 7868     	 ldr r0,[r7,#4]
 2789 01c2 1946     	 mov r1,r3
 2790 01c4 FFF7FEFF 	 bl OBJ_GetEntryDesc
 2791 01c8 F861     	 str r0,[r7,#28]
1408:../SSC/Src/objdef.c **** 
1409:../SSC/Src/objdef.c ****             /*Get the bitOffset before check the access rights to calculate pData offset*/
1410:../SSC/Src/objdef.c ****             bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
 2792              	 .loc 1 1410 0
 2793 01ca FB8E     	 ldrh r3,[r7,#54]
 2794 01cc DBB2     	 uxtb r3,r3
 2795 01ce 1846     	 mov r0,r3
 2796 01d0 7968     	 ldr r1,[r7,#4]
 2797 01d2 FFF7FEFF 	 bl OBJ_GetEntryOffset
 2798 01d6 0346     	 mov r3,r0
 2799 01d8 3B83     	 strh r3,[r7,#24]
1411:../SSC/Src/objdef.c **** 
1412:../SSC/Src/objdef.c ****             /* we check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
1413:../SSC/Src/objdef.c ****                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
1414:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.12) COE3*/
1415:../SSC/Src/objdef.c ****             if (0 != (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK)
 2800              	 .loc 1 1415 0
 2801 01da FB69     	 ldr r3,[r7,#28]
 2802 01dc 9B88     	 ldrh r3,[r3,#4]
 2803 01de 03F03803 	 and r3,r3,#56
 2804 01e2 9B10     	 asrs r3,r3,#2
 2805 01e4 DBB2     	 uxtb r3,r3
 2806 01e6 1A46     	 mov r2,r3
 2807 01e8 624B     	 ldr r3,.L248
 2808 01ea 1B78     	 ldrb r3,[r3]
 2809 01ec 03F00F03 	 and r3,r3,#15
 2810 01f0 1340     	 ands r3,r3,r2
 2811 01f2 002B     	 cmp r3,#0
 2812 01f4 00F03582 	 beq .L195
1416:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.12) COE3*/
1417:../SSC/Src/objdef.c ****             {
1418:../SSC/Src/objdef.c ****                 /* we have write access for this entry */
1419:../SSC/Src/objdef.c ****                 if (i != 0)
 2813              	 .loc 1 1419 0
 2814 01f8 FB8E     	 ldrh r3,[r7,#54]
 2815 01fa 002B     	 cmp r3,#0
 2816 01fc 06D0     	 beq .L196
1420:../SSC/Src/objdef.c ****                 {
1421:../SSC/Src/objdef.c ****                     /* we increment the variable pointer to the corresponding word address */
1422:../SSC/Src/objdef.c ****                     pVarPtr += (bitOffset >> 4);
 2817              	 .loc 1 1422 0
 2818 01fe 3B8B     	 ldrh r3,[r7,#24]
 2819 0200 1B09     	 lsrs r3,r3,#4
 2820 0202 9BB2     	 uxth r3,r3
 2821 0204 5B00     	 lsls r3,r3,#1
 2822 0206 BA6A     	 ldr r2,[r7,#40]
 2823 0208 1344     	 add r3,r3,r2
 2824 020a BB62     	 str r3,[r7,#40]
 2825              	.L196:
1423:../SSC/Src/objdef.c ****                 }
1424:../SSC/Src/objdef.c **** 
1425:../SSC/Src/objdef.c **** 
1426:../SSC/Src/objdef.c ****                 if ( i == subindex                                     /* requested entry */
 2826              	 .loc 1 1426 0
 2827 020c 7B7B     	 ldrb r3,[r7,#13]
 2828 020e 9BB2     	 uxth r3,r3
 2829 0210 FA8E     	 ldrh r2,[r7,#54]
 2830 0212 9A42     	 cmp r2,r3
 2831 0214 0AD0     	 beq .L197
1427:../SSC/Src/objdef.c ****                   || (bCompleteAccess && i >= subindex) )       /* complete access and entry should
 2832              	 .loc 1 1427 0
 2833 0216 97F84C30 	 ldrb r3,[r7,#76]
 2834 021a 002B     	 cmp r3,#0
 2835 021c 00F04482 	 beq .L242
 2836              	 .loc 1 1427 0 is_stmt 0 discriminator 1
 2837 0220 7B7B     	 ldrb r3,[r7,#13]
 2838 0222 9BB2     	 uxth r3,r3
 2839 0224 FA8E     	 ldrh r2,[r7,#54]
 2840 0226 9A42     	 cmp r2,r3
 2841 0228 C0F03E82 	 bcc .L242
 2842              	.L197:
 2843              	.LBB20:
1428:../SSC/Src/objdef.c ****                 {
1429:../SSC/Src/objdef.c ****                     UINT16 bitMask;
1430:../SSC/Src/objdef.c **** 
1431:../SSC/Src/objdef.c ****                     /* we have to copy the entry */
1432:../SSC/Src/objdef.c ****                     if (i == 0 && objCode != OBJCODE_VAR)
 2844              	 .loc 1 1432 0 is_stmt 1
 2845 022c FB8E     	 ldrh r3,[r7,#54]
 2846 022e 002B     	 cmp r3,#0
 2847 0230 15D1     	 bne .L199
 2848              	 .loc 1 1432 0 is_stmt 0 discriminator 1
 2849 0232 97F82330 	 ldrb r3,[r7,#35]
 2850 0236 072B     	 cmp r3,#7
 2851 0238 11D0     	 beq .L199
 2852              	.LBB21:
1433:../SSC/Src/objdef.c ****                     {
1434:../SSC/Src/objdef.c ****                         /*check if the value for subindex0 is valid */
1435:../SSC/Src/objdef.c ****                         UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
 2853              	 .loc 1 1435 0 is_stmt 1
 2854 023a BB6C     	 ldr r3,[r7,#72]
 2855 023c 1B88     	 ldrh r3,[r3]
 2856 023e FB74     	 strb r3,[r7,#19]
1436:../SSC/Src/objdef.c ****                         
1437:../SSC/Src/objdef.c ****                         if(maxConfiguredSubindex < NewSubindex0)
 2857              	 .loc 1 1437 0
 2858 0240 FB7C     	 ldrb r3,[r7,#19]
 2859 0242 9BB2     	 uxth r3,r3
 2860 0244 3A8C     	 ldrh r2,[r7,#32]
 2861 0246 9A42     	 cmp r2,r3
 2862 0248 01D2     	 bcs .L200
1438:../SSC/Src/objdef.c ****                         {
1439:../SSC/Src/objdef.c ****                             return ABORTIDX_VALUE_TOO_GREAT;
 2863              	 .loc 1 1439 0
 2864 024a 1323     	 movs r3,#19
 2865 024c 3CE2     	 b .L181
 2866              	.L200:
1440:../SSC/Src/objdef.c ****                         }
1441:../SSC/Src/objdef.c **** 
1442:../SSC/Src/objdef.c ****                         /* subindex 0 of an array or record shall be written */
1443:../SSC/Src/objdef.c ****                         pVarPtr[0] = SWAPWORD(pData[0]);
 2867              	 .loc 1 1443 0
 2868 024e BB6C     	 ldr r3,[r7,#72]
 2869 0250 1A88     	 ldrh r2,[r3]
 2870 0252 BB6A     	 ldr r3,[r7,#40]
 2871 0254 1A80     	 strh r2,[r3]
1444:../SSC/Src/objdef.c ****                         /* we increment the destination pointer by 2 because the subindex 0 will be
1445:../SSC/Src/objdef.c ****                            transmitted as UINT16 for a complete access */
1446:../SSC/Src/objdef.c ****                         pData++;
 2872              	 .loc 1 1446 0
 2873 0256 BB6C     	 ldr r3,[r7,#72]
 2874 0258 0233     	 adds r3,r3,#2
 2875 025a BB64     	 str r3,[r7,#72]
 2876              	.LBE21:
1433:../SSC/Src/objdef.c ****                         /*check if the value for subindex0 is valid */
 2877              	 .loc 1 1433 0
 2878 025c FDE1     	 b .L201
 2879              	.L199:
 2880              	.LBB22:
1447:../SSC/Src/objdef.c ****                     }
1448:../SSC/Src/objdef.c ****                     else
1449:../SSC/Src/objdef.c ****                     {
1450:../SSC/Src/objdef.c ****                         UINT16 dataType = pEntry->DataType;
 2881              	 .loc 1 1450 0
 2882 025e FB69     	 ldr r3,[r7,#28]
 2883 0260 1B88     	 ldrh r3,[r3]
 2884 0262 FB84     	 strh r3,[r7,#38]
1451:../SSC/Src/objdef.c ****                         if (pEntry->DataType >= 0x700)
 2885              	 .loc 1 1451 0
 2886 0264 FB69     	 ldr r3,[r7,#28]
 2887 0266 1B88     	 ldrh r3,[r3]
 2888 0268 B3F5E06F 	 cmp r3,#1792
 2889 026c 15D3     	 bcc .L202
1452:../SSC/Src/objdef.c ****                         {
1453:../SSC/Src/objdef.c ****                             /* the ENUM data types are defined from index 0x700 in this example
1454:../SSC/Src/objdef.c ****                                convert in standard data type for the write access */
1455:../SSC/Src/objdef.c ****                             if ( pEntry->BitLength <= 8 )
 2890              	 .loc 1 1455 0
 2891 026e FB69     	 ldr r3,[r7,#28]
 2892 0270 5B88     	 ldrh r3,[r3,#2]
 2893 0272 082B     	 cmp r3,#8
 2894 0274 04D8     	 bhi .L203
1456:../SSC/Src/objdef.c ****                             {
1457:../SSC/Src/objdef.c ****                                 dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
 2895              	 .loc 1 1457 0
 2896 0276 FB69     	 ldr r3,[r7,#28]
 2897 0278 5B88     	 ldrh r3,[r3,#2]
 2898 027a 2F33     	 adds r3,r3,#47
 2899 027c FB84     	 strh r3,[r7,#38]
 2900 027e 0CE0     	 b .L202
 2901              	.L203:
1458:../SSC/Src/objdef.c ****                             }
1459:../SSC/Src/objdef.c ****                             else if ( pEntry->BitLength == 16 )
 2902              	 .loc 1 1459 0
 2903 0280 FB69     	 ldr r3,[r7,#28]
 2904 0282 5B88     	 ldrh r3,[r3,#2]
 2905 0284 102B     	 cmp r3,#16
 2906 0286 02D1     	 bne .L204
1460:../SSC/Src/objdef.c ****                             {
1461:../SSC/Src/objdef.c ****                                 dataType = DEFTYPE_UNSIGNED16;
 2907              	 .loc 1 1461 0
 2908 0288 0623     	 movs r3,#6
 2909 028a FB84     	 strh r3,[r7,#38]
 2910 028c 05E0     	 b .L202
 2911              	.L204:
1462:../SSC/Src/objdef.c ****                             }
1463:../SSC/Src/objdef.c ****                             else if ( pEntry->BitLength == 32 )
 2912              	 .loc 1 1463 0
 2913 028e FB69     	 ldr r3,[r7,#28]
 2914 0290 5B88     	 ldrh r3,[r3,#2]
 2915 0292 202B     	 cmp r3,#32
 2916 0294 01D1     	 bne .L202
1464:../SSC/Src/objdef.c ****                             {
1465:../SSC/Src/objdef.c ****                                 dataType = DEFTYPE_UNSIGNED32;
 2917              	 .loc 1 1465 0
 2918 0296 0723     	 movs r3,#7
 2919 0298 FB84     	 strh r3,[r7,#38]
 2920              	.L202:
1466:../SSC/Src/objdef.c ****                             }
1467:../SSC/Src/objdef.c ****                         }
1468:../SSC/Src/objdef.c **** 
1469:../SSC/Src/objdef.c ****                         switch (dataType)
 2921              	 .loc 1 1469 0
 2922 029a FB8C     	 ldrh r3,[r7,#38]
 2923 029c 112B     	 cmp r3,#17
 2924 029e 00F07B81 	 beq .L206
 2925 02a2 112B     	 cmp r3,#17
 2926 02a4 1EDC     	 bgt .L207
 2927 02a6 052B     	 cmp r3,#5
 2928 02a8 66D0     	 beq .L208
 2929 02aa 052B     	 cmp r3,#5
 2930 02ac 0DDC     	 bgt .L209
 2931 02ae 022B     	 cmp r3,#2
 2932 02b0 04DC     	 bgt .L210
 2933 02b2 012B     	 cmp r3,#1
 2934 02b4 60DA     	 bge .L208
 2935 02b6 002B     	 cmp r3,#0
 2936 02b8 3BD0     	 beq .L211
 2937 02ba CCE1     	 b .L205
 2938              	.L210:
 2939 02bc 032B     	 cmp r3,#3
 2940 02be 00F0B580 	 beq .L212
 2941 02c2 042B     	 cmp r3,#4
 2942 02c4 00F04081 	 beq .L213
 2943 02c8 C5E1     	 b .L205
 2944              	.L209:
 2945 02ca 082B     	 cmp r3,#8
 2946 02cc 03DC     	 bgt .L214
 2947 02ce 072B     	 cmp r3,#7
 2948 02d0 80F23A81 	 bge .L213
 2949 02d4 AAE0     	 b .L212
 2950              	.L214:
 2951 02d6 092B     	 cmp r3,#9
 2952 02d8 00F07C81 	 beq .L215
 2953 02dc 0B2B     	 cmp r3,#11
 2954 02de 00F3BA81 	 bgt .L205
 2955 02e2 9DE1     	 b .L216
 2956              	.L207:
 2957 02e4 2D2B     	 cmp r3,#45
 2958 02e6 47D0     	 beq .L208
 2959 02e8 2D2B     	 cmp r3,#45
 2960 02ea 11DC     	 bgt .L217
 2961 02ec 1E2B     	 cmp r3,#30
 2962 02ee 43D0     	 beq .L208
 2963 02f0 1E2B     	 cmp r3,#30
 2964 02f2 06DC     	 bgt .L218
 2965 02f4 152B     	 cmp r3,#21
 2966 02f6 00F04F81 	 beq .L206
 2967 02fa 1B2B     	 cmp r3,#27
 2968 02fc 00F04C81 	 beq .L206
 2969 0300 A9E1     	 b .L205
 2970              	.L218:
 2971 0302 1F2B     	 cmp r3,#31
 2972 0304 00F09280 	 beq .L212
 2973 0308 202B     	 cmp r3,#32
 2974 030a 00F01D81 	 beq .L213
 2975 030e A2E1     	 b .L205
 2976              	.L217:
 2977 0310 372B     	 cmp r3,#55
 2978 0312 08DC     	 bgt .L219
 2979 0314 302B     	 cmp r3,#48
 2980 0316 2FDA     	 bge .L208
 2981 0318 2E2B     	 cmp r3,#46
 2982 031a 00F08780 	 beq .L212
 2983 031e 2F2B     	 cmp r3,#47
 2984 0320 00F01281 	 beq .L213
 2985 0324 97E1     	 b .L205
 2986              	.L219:
 2987 0326 A3F51873 	 sub r3,r3,#608
 2988 032a 032B     	 cmp r3,#3
 2989 032c 00F29381 	 bhi .L205
 2990 0330 76E1     	 b .L216
 2991              	.L211:
1470:../SSC/Src/objdef.c ****                         {
1471:../SSC/Src/objdef.c ****                         case DEFTYPE_NULL:
1472:../SSC/Src/objdef.c ****                             if(bCompleteAccess)
 2992              	 .loc 1 1472 0
 2993 0332 97F84C30 	 ldrb r3,[r7,#76]
 2994 0336 002B     	 cmp r3,#0
 2995 0338 1AD0     	 beq .L220
1473:../SSC/Src/objdef.c ****                             {
1474:../SSC/Src/objdef.c ****                                 /*Handle alignment entry*/
1475:../SSC/Src/objdef.c ****                                 if (((pEntry->BitLength & 0xF) > 0)
 2996              	 .loc 1 1475 0
 2997 033a FB69     	 ldr r3,[r7,#28]
 2998 033c 5B88     	 ldrh r3,[r3,#2]
 2999 033e 03F00F03 	 and r3,r3,#15
 3000 0342 002B     	 cmp r3,#0
 3001 0344 0ADD     	 ble .L221
1476:../SSC/Src/objdef.c ****                                     && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 3002              	 .loc 1 1476 0
 3003 0346 3B8B     	 ldrh r3,[r7,#24]
 3004 0348 FA69     	 ldr r2,[r7,#28]
 3005 034a 5288     	 ldrh r2,[r2,#2]
 3006 034c 1344     	 add r3,r3,r2
 3007 034e 03F00F03 	 and r3,r3,#15
 3008 0352 002B     	 cmp r3,#0
 3009 0354 02D1     	 bne .L221
1477:../SSC/Src/objdef.c ****                                 {
1478:../SSC/Src/objdef.c ****                                     /* we have reached the UINT16 border */
1479:../SSC/Src/objdef.c ****                                     pData++;
 3010              	 .loc 1 1479 0
 3011 0356 BB6C     	 ldr r3,[r7,#72]
 3012 0358 0233     	 adds r3,r3,#2
 3013 035a BB64     	 str r3,[r7,#72]
 3014              	.L221:
1480:../SSC/Src/objdef.c ****                                 }
1481:../SSC/Src/objdef.c **** 
1482:../SSC/Src/objdef.c ****                                 /*increment WORD offset*/
1483:../SSC/Src/objdef.c ****                                 pData += ((pEntry->BitLength & 0xF0) >> 4);
 3015              	 .loc 1 1483 0
 3016 035c FB69     	 ldr r3,[r7,#28]
 3017 035e 5B88     	 ldrh r3,[r3,#2]
 3018 0360 03F0F003 	 and r3,r3,#240
 3019 0364 1B11     	 asrs r3,r3,#4
 3020 0366 5B00     	 lsls r3,r3,#1
 3021 0368 BA6C     	 ldr r2,[r7,#72]
 3022 036a 1344     	 add r3,r3,r2
 3023 036c BB64     	 str r3,[r7,#72]
1484:../SSC/Src/objdef.c ****                             }
1485:../SSC/Src/objdef.c ****                             else
1486:../SSC/Src/objdef.c ****                             {
1487:../SSC/Src/objdef.c ****                                 return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
1488:../SSC/Src/objdef.c ****                             }
1489:../SSC/Src/objdef.c ****                             break;
 3024              	 .loc 1 1489 0
 3025 036e 74E1     	 b .L201
 3026              	.L220:
1487:../SSC/Src/objdef.c ****                             }
 3027              	 .loc 1 1487 0
 3028 0370 1823     	 movs r3,#24
 3029 0372 A9E1     	 b .L181
 3030              	.L249:
 3031              	 .align 2
 3032              	.L248:
 3033 0374 00000000 	 .word nAlStatus
 3034              	.L208:
 3035              	.LBB23:
1490:../SSC/Src/objdef.c ****                         case     DEFTYPE_BOOLEAN:
1491:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT1:
1492:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT2:
1493:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT3:
1494:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT4:
1495:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT5:
1496:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT6:
1497:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT7:
1498:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT8:
1499:../SSC/Src/objdef.c ****                         case     DEFTYPE_BITARR8:
1500:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1501:../SSC/Src/objdef.c ****                                that the bit types are always inside a 16-bit field,
1502:../SSC/Src/objdef.c ****                                and shall not overlap a byte border*/
1503:../SSC/Src/objdef.c ****                         case    DEFTYPE_INTEGER8:
1504:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED8:
1505:../SSC/Src/objdef.c ****                         case    DEFTYPE_BYTE :
1506:../SSC/Src/objdef.c ****                         {
1507:../SSC/Src/objdef.c ****                             /* depending on the bitOffset we have to copy the Hi or the Lo-Byte */
1508:../SSC/Src/objdef.c ****                             UINT16 TmpValue = 0x0000;
 3036              	 .loc 1 1508 0
 3037 0378 0023     	 movs r3,#0
 3038 037a BB84     	 strh r3,[r7,#36]
1509:../SSC/Src/objdef.c **** 
1510:../SSC/Src/objdef.c ****                             bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
 3039              	 .loc 1 1510 0
 3040 037c FB69     	 ldr r3,[r7,#28]
 3041 037e 5B88     	 ldrh r3,[r3,#2]
 3042 0380 1A46     	 mov r2,r3
 3043 0382 A24B     	 ldr r3,.L250
 3044 0384 33F81230 	 ldrh r3,[r3,r2,lsl#1]
 3045 0388 1A46     	 mov r2,r3
 3046 038a 3B8B     	 ldrh r3,[r7,#24]
 3047 038c 03F00F03 	 and r3,r3,#15
 3048 0390 02FA03F3 	 lsl r3,r2,r3
 3049 0394 FB82     	 strh r3,[r7,#22]
1511:../SSC/Src/objdef.c **** 
1512:../SSC/Src/objdef.c ****                             /*Swap object data (if required); all masks and offsets are defined for
1513:../SSC/Src/objdef.c ****                             TmpValue = SWAPWORD(pVarPtr[0]);
 3050              	 .loc 1 1513 0
 3051 0396 BB6A     	 ldr r3,[r7,#40]
 3052 0398 1B88     	 ldrh r3,[r3]
 3053 039a BB84     	 strh r3,[r7,#36]
1514:../SSC/Src/objdef.c **** 
1515:../SSC/Src/objdef.c ****                             /*Clear corresponding bits*/
1516:../SSC/Src/objdef.c ****                             TmpValue &= ~bitMask;
 3054              	 .loc 1 1516 0
 3055 039c FB8A     	 ldrh r3,[r7,#22]
 3056 039e DB43     	 mvns r3,r3
 3057 03a0 9AB2     	 uxth r2,r3
 3058 03a2 BB8C     	 ldrh r3,[r7,#36]
 3059 03a4 1340     	 ands r3,r3,r2
 3060 03a6 9BB2     	 uxth r3,r3
 3061 03a8 BB84     	 strh r3,[r7,#36]
1517:../SSC/Src/objdef.c **** 
1518:../SSC/Src/objdef.c ****                             if (bCompleteAccess) 
 3062              	 .loc 1 1518 0
 3063 03aa 97F84C30 	 ldrb r3,[r7,#76]
 3064 03ae 002B     	 cmp r3,#0
 3065 03b0 08D0     	 beq .L223
1519:../SSC/Src/objdef.c ****                             {
1520:../SSC/Src/objdef.c ****                                 /*shifting is not required for Complete access because the bits are
1521:../SSC/Src/objdef.c ****                                 TmpValue |= (SWAPWORD(pData[0]) & bitMask);
 3066              	 .loc 1 1521 0
 3067 03b2 BB6C     	 ldr r3,[r7,#72]
 3068 03b4 1A88     	 ldrh r2,[r3]
 3069 03b6 FB8A     	 ldrh r3,[r7,#22]
 3070 03b8 1340     	 ands r3,r3,r2
 3071 03ba 9AB2     	 uxth r2,r3
 3072 03bc BB8C     	 ldrh r3,[r7,#36]
 3073 03be 1343     	 orrs r3,r3,r2
 3074 03c0 BB84     	 strh r3,[r7,#36]
 3075 03c2 23E0     	 b .L224
 3076              	.L223:
1522:../SSC/Src/objdef.c ****                             }
1523:../SSC/Src/objdef.c ****                             else
1524:../SSC/Src/objdef.c ****                             {
1525:../SSC/Src/objdef.c ****                                 if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
 3077              	 .loc 1 1525 0
 3078 03c4 BB6C     	 ldr r3,[r7,#72]
 3079 03c6 1B88     	 ldrh r3,[r3]
 3080 03c8 1A46     	 mov r2,r3
 3081 03ca FB69     	 ldr r3,[r7,#28]
 3082 03cc 5B88     	 ldrh r3,[r3,#2]
 3083 03ce 1946     	 mov r1,r3
 3084 03d0 8E4B     	 ldr r3,.L250
 3085 03d2 33F81130 	 ldrh r3,[r3,r1,lsl#1]
 3086 03d6 DB43     	 mvns r3,r3
 3087 03d8 1340     	 ands r3,r3,r2
 3088 03da 002B     	 cmp r3,#0
 3089 03dc 01D0     	 beq .L225
1526:../SSC/Src/objdef.c ****                                 {
1527:../SSC/Src/objdef.c ****                                     /*written value exceed entry range*/
1528:../SSC/Src/objdef.c ****                                     return ABORTIDX_VALUE_EXCEEDED;
 3090              	 .loc 1 1528 0
 3091 03de 1223     	 movs r3,#18
 3092 03e0 72E1     	 b .L181
 3093              	.L225:
1529:../SSC/Src/objdef.c ****                                 }
1530:../SSC/Src/objdef.c ****                                 else
1531:../SSC/Src/objdef.c ****                                 {
1532:../SSC/Src/objdef.c ****                                     /*Shift Bits to corresponding offset within the object memory*/
1533:../SSC/Src/objdef.c ****                                     TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength])
 3094              	 .loc 1 1533 0
 3095 03e2 BB6C     	 ldr r3,[r7,#72]
 3096 03e4 1A88     	 ldrh r2,[r3]
 3097 03e6 FB69     	 ldr r3,[r7,#28]
 3098 03e8 5B88     	 ldrh r3,[r3,#2]
 3099 03ea 1946     	 mov r1,r3
 3100 03ec 874B     	 ldr r3,.L250
 3101 03ee 33F81130 	 ldrh r3,[r3,r1,lsl#1]
 3102 03f2 1340     	 ands r3,r3,r2
 3103 03f4 9BB2     	 uxth r3,r3
 3104 03f6 1A46     	 mov r2,r3
 3105 03f8 3B8B     	 ldrh r3,[r7,#24]
 3106 03fa 03F00F03 	 and r3,r3,#15
 3107 03fe 02FA03F3 	 lsl r3,r2,r3
 3108 0402 9AB2     	 uxth r2,r3
 3109 0404 BB8C     	 ldrh r3,[r7,#36]
 3110 0406 1343     	 orrs r3,r3,r2
 3111 0408 9BB2     	 uxth r3,r3
 3112 040a BB84     	 strh r3,[r7,#36]
 3113              	.L224:
1534:../SSC/Src/objdef.c ****                                 }
1535:../SSC/Src/objdef.c ****                             }
1536:../SSC/Src/objdef.c **** 
1537:../SSC/Src/objdef.c ****                             /*Swap written data to big endian format (if required)*/
1538:../SSC/Src/objdef.c ****                             pVarPtr[0] = SWAPWORD(TmpValue);
 3114              	 .loc 1 1538 0
 3115 040c BB6A     	 ldr r3,[r7,#40]
 3116 040e BA8C     	 ldrh r2,[r7,#36]
 3117 0410 1A80     	 strh r2,[r3]
1539:../SSC/Src/objdef.c **** 
1540:../SSC/Src/objdef.c ****                             if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
 3118              	 .loc 1 1540 0
 3119 0412 3B8B     	 ldrh r3,[r7,#24]
 3120 0414 FA69     	 ldr r2,[r7,#28]
 3121 0416 5288     	 ldrh r2,[r2,#2]
 3122 0418 1344     	 add r3,r3,r2
 3123 041a 03F00F03 	 and r3,r3,#15
 3124 041e 002B     	 cmp r3,#0
 3125 0420 03D1     	 bne .L226
1541:../SSC/Src/objdef.c ****                             {
1542:../SSC/Src/objdef.c ****                                 /* we have reached the UINT16 border */
1543:../SSC/Src/objdef.c ****                                 pData++;
 3126              	 .loc 1 1543 0
 3127 0422 BB6C     	 ldr r3,[r7,#72]
 3128 0424 0233     	 adds r3,r3,#2
 3129 0426 BB64     	 str r3,[r7,#72]
 3130              	.LBE23:
1544:../SSC/Src/objdef.c ****                             }
1545:../SSC/Src/objdef.c ****                         }
1546:../SSC/Src/objdef.c ****                             break;
 3131              	 .loc 1 1546 0
 3132 0428 17E1     	 b .L201
 3133              	.L226:
 3134 042a 16E1     	 b .L201
 3135              	.L212:
1547:../SSC/Src/objdef.c ****                         case    DEFTYPE_INTEGER16:
1548:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED16:
1549:../SSC/Src/objdef.c ****                         case    DEFTYPE_BITARR16:
1550:../SSC/Src/objdef.c ****                         case    DEFTYPE_WORD:
1551:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3136              	 .loc 1 1551 0
 3137 042c 3B8B     	 ldrh r3,[r7,#24]
 3138 042e 03F00F03 	 and r3,r3,#15
 3139 0432 002B     	 cmp r3,#0
 3140 0434 01D0     	 beq .L227
1552:../SSC/Src/objdef.c ****                             {
1553:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1554:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3141              	 .loc 1 1554 0
 3142 0436 0523     	 movs r3,#5
 3143 0438 46E1     	 b .L181
 3144              	.L227:
 3145              	.LBB24:
1555:../SSC/Src/objdef.c ****                             }
1556:../SSC/Src/objdef.c **** 
1557:../SSC/Src/objdef.c ****                             {
1558:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1559:../SSC/Src/objdef.c ****                             that the 16 bit type are always starting at an exact WORD offset */
1560:../SSC/Src/objdef.c ****                             UINT16 u16NewData = SWAPWORD(pData[0]);
 3146              	 .loc 1 1560 0
 3147 043a BB6C     	 ldr r3,[r7,#72]
 3148 043c 1B88     	 ldrh r3,[r3]
 3149 043e BB82     	 strh r3,[r7,#20]
1561:../SSC/Src/objdef.c ****                             if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
 3150              	 .loc 1 1561 0
 3151 0440 97F83330 	 ldrb r3,[r7,#51]
 3152 0444 002B     	 cmp r3,#0
 3153 0446 06D0     	 beq .L228
 3154              	 .loc 1 1561 0 is_stmt 0 discriminator 1
 3155 0448 BB6A     	 ldr r3,[r7,#40]
 3156 044a 1B88     	 ldrh r3,[r3]
 3157 044c BA8A     	 ldrh r2,[r7,#20]
 3158 044e 9A42     	 cmp r2,r3
 3159 0450 01D0     	 beq .L228
1562:../SSC/Src/objdef.c ****                             {
1563:../SSC/Src/objdef.c ****                                 /* try to write new data when subindex0 shall be reset*/
1564:../SSC/Src/objdef.c ****                                 return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
 3160              	 .loc 1 1564 0 is_stmt 1
 3161 0452 1C23     	 movs r3,#28
 3162 0454 38E1     	 b .L181
 3163              	.L228:
1565:../SSC/Src/objdef.c ****                             }
1566:../SSC/Src/objdef.c **** 
1567:../SSC/Src/objdef.c ****                             /*check value if a new PDO assign entry should be written*/
1568:../SSC/Src/objdef.c ****                             if(IS_PDO_ASSIGN(index))  //PDO assign
 3164              	 .loc 1 1568 0
 3165 0456 FB89     	 ldrh r3,[r7,#14]
 3166 0458 41F60F42 	 movw r2,#7183
 3167 045c 9342     	 cmp r3,r2
 3168 045e 19D9     	 bls .L229
 3169              	 .loc 1 1568 0 is_stmt 0 discriminator 1
 3170 0460 FB89     	 ldrh r3,[r7,#14]
 3171 0462 41F62F42 	 movw r2,#7215
 3172 0466 9342     	 cmp r3,r2
 3173 0468 14D8     	 bhi .L229
1569:../SSC/Src/objdef.c ****                             {
1570:../SSC/Src/objdef.c ****                                 if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData
 3174              	 .loc 1 1570 0 is_stmt 1
 3175 046a BB8A     	 ldrh r3,[r7,#20]
 3176 046c B3F5B05F 	 cmp r3,#5632
 3177 0470 03D3     	 bcc .L230
 3178              	 .loc 1 1570 0 is_stmt 0 discriminator 2
 3179 0472 BB8A     	 ldrh r3,[r7,#20]
 3180 0474 B3F5C05F 	 cmp r3,#6144
 3181 0478 0CD3     	 bcc .L229
 3182              	.L230:
 3183              	 .loc 1 1570 0 discriminator 3
 3184 047a BB8A     	 ldrh r3,[r7,#20]
 3185 047c B3F5D05F 	 cmp r3,#6656
 3186 0480 03D3     	 bcc .L231
 3187              	 .loc 1 1570 0 discriminator 5
 3188 0482 BB8A     	 ldrh r3,[r7,#20]
 3189 0484 B3F5E05F 	 cmp r3,#7168
 3190 0488 04D3     	 bcc .L229
 3191              	.L231:
 3192              	 .loc 1 1570 0 discriminator 6
 3193 048a BB8A     	 ldrh r3,[r7,#20]
 3194 048c 002B     	 cmp r3,#0
 3195 048e 01D0     	 beq .L229
1571:../SSC/Src/objdef.c ****                                 {
1572:../SSC/Src/objdef.c ****                                     return ABORTIDX_VALUE_EXCEEDED;
 3196              	 .loc 1 1572 0 is_stmt 1
 3197 0490 1223     	 movs r3,#18
 3198 0492 19E1     	 b .L181
 3199              	.L229:
1573:../SSC/Src/objdef.c ****                                 }
1574:../SSC/Src/objdef.c ****                             }
1575:../SSC/Src/objdef.c **** 
1576:../SSC/Src/objdef.c ****                             if(index == 0x1C32 || index == 0x1C33)
 3200              	 .loc 1 1576 0
 3201 0494 FB89     	 ldrh r3,[r7,#14]
 3202 0496 41F63242 	 movw r2,#7218
 3203 049a 9342     	 cmp r3,r2
 3204 049c 04D0     	 beq .L232
 3205              	 .loc 1 1576 0 is_stmt 0 discriminator 1
 3206 049e FB89     	 ldrh r3,[r7,#14]
 3207 04a0 41F63342 	 movw r2,#7219
 3208 04a4 9342     	 cmp r3,r2
 3209 04a6 48D1     	 bne .L233
 3210              	.L232:
1577:../SSC/Src/objdef.c ****                             {
1578:../SSC/Src/objdef.c ****                                if (i == 1) /* "Synchronisation type" written */
 3211              	 .loc 1 1578 0 is_stmt 1
 3212 04a8 FB8E     	 ldrh r3,[r7,#54]
 3213 04aa 012B     	 cmp r3,#1
 3214 04ac 17D1     	 bne .L234
1579:../SSC/Src/objdef.c ****                                {
1580:../SSC/Src/objdef.c ****                                   /* The Synchronisation type (0x1C3x.1) was written by the user =>
1581:../SSC/Src/objdef.c ****                                   if (pVarPtr[0] != u16NewData)
 3215              	 .loc 1 1581 0
 3216 04ae BB6A     	 ldr r3,[r7,#40]
 3217 04b0 1B88     	 ldrh r3,[r3]
 3218 04b2 BA8A     	 ldrh r2,[r7,#20]
 3219 04b4 9A42     	 cmp r2,r3
 3220 04b6 0FD0     	 beq .L235
1582:../SSC/Src/objdef.c ****                                   {
1583:../SSC/Src/objdef.c ****                                      result = CheckSyncTypeValue(index, u16NewData);
 3221              	 .loc 1 1583 0
 3222 04b8 FA89     	 ldrh r2,[r7,#14]
 3223 04ba BB8A     	 ldrh r3,[r7,#20]
 3224 04bc 1046     	 mov r0,r2
 3225 04be 1946     	 mov r1,r3
 3226 04c0 FFF7FEFF 	 bl CheckSyncTypeValue
 3227 04c4 0346     	 mov r3,r0
 3228 04c6 87F82E30 	 strb r3,[r7,#46]
1584:../SSC/Src/objdef.c **** 
1585:../SSC/Src/objdef.c ****                                      if (result != 0)
 3229              	 .loc 1 1585 0
 3230 04ca 97F82E30 	 ldrb r3,[r7,#46]
 3231 04ce 002B     	 cmp r3,#0
 3232 04d0 02D0     	 beq .L235
1586:../SSC/Src/objdef.c ****                                      {
1587:../SSC/Src/objdef.c ****                                         return result;
 3233              	 .loc 1 1587 0
 3234 04d2 97F82E30 	 ldrb r3,[r7,#46]
 3235 04d6 F7E0     	 b .L181
 3236              	.L235:
1588:../SSC/Src/objdef.c ****                                      }
1589:../SSC/Src/objdef.c ****                                   }
1590:../SSC/Src/objdef.c **** 
1591:../SSC/Src/objdef.c ****                                   /* The user may force to current Sync Mode for that reason the fl
1592:../SSC/Src/objdef.c ****                                   bSyncSetByUser = TRUE;
 3237              	 .loc 1 1592 0
 3238 04d8 4D4B     	 ldr r3,.L250+4
 3239 04da 0122     	 movs r2,#1
 3240 04dc 1A70     	 strb r2,[r3]
 3241              	.L234:
1593:../SSC/Src/objdef.c ****                                }
1594:../SSC/Src/objdef.c **** 
1595:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.12) ECAT1*/
1596:../SSC/Src/objdef.c ****                                if (i == 8) /* "Get Cycle Time" written*/
 3242              	 .loc 1 1596 0
 3243 04de FB8E     	 ldrh r3,[r7,#54]
 3244 04e0 082B     	 cmp r3,#8
 3245 04e2 2AD1     	 bne .L233
1597:../SSC/Src/objdef.c ****                                {
1598:../SSC/Src/objdef.c **** 
1599:../SSC/Src/objdef.c ****                                    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIM
 3246              	 .loc 1 1599 0
 3247 04e4 4B4B     	 ldr r3,.L250+8
 3248 04e6 0022     	 movs r2,#0
 3249 04e8 5A61     	 str r2,[r3,#20]
1600:../SSC/Src/objdef.c ****                                    sSyncManOutPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
 3250              	 .loc 1 1600 0
 3251 04ea 4A4B     	 ldr r3,.L250+8
 3252 04ec 4A4A     	 ldr r2,.L250+12
 3253 04ee 1A61     	 str r2,[r3,#16]
1601:../SSC/Src/objdef.c ****                                    sSyncManOutPar.u32CycleTime = 0;
 3254              	 .loc 1 1601 0
 3255 04f0 484B     	 ldr r3,.L250+8
 3256 04f2 0022     	 movs r2,#0
 3257 04f4 5A60     	 str r2,[r3,#4]
1602:../SSC/Src/objdef.c **** 
1603:../SSC/Src/objdef.c ****                                    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME)
 3258              	 .loc 1 1603 0
 3259 04f6 494B     	 ldr r3,.L250+16
 3260 04f8 0022     	 movs r2,#0
 3261 04fa 5A61     	 str r2,[r3,#20]
1604:../SSC/Src/objdef.c ****                                    sSyncManInPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
 3262              	 .loc 1 1604 0
 3263 04fc 474B     	 ldr r3,.L250+16
 3264 04fe 464A     	 ldr r2,.L250+12
 3265 0500 1A61     	 str r2,[r3,#16]
1605:../SSC/Src/objdef.c ****                                    sSyncManInPar.u32CycleTime = 0;
 3266              	 .loc 1 1605 0
 3267 0502 464B     	 ldr r3,.L250+16
 3268 0504 0022     	 movs r2,#0
 3269 0506 5A60     	 str r2,[r3,#4]
1606:../SSC/Src/objdef.c **** 
1607:../SSC/Src/objdef.c **** 
1608:../SSC/Src/objdef.c ****                                   if ((u16NewData & 0x2) == 0x2)
 3270              	 .loc 1 1608 0
 3271 0508 BB8A     	 ldrh r3,[r7,#20]
 3272 050a 03F00203 	 and r3,r3,#2
 3273 050e 002B     	 cmp r3,#0
 3274 0510 13D0     	 beq .L233
1609:../SSC/Src/objdef.c ****                                   {
1610:../SSC/Src/objdef.c ****                                      /* reset the error counters*/
1611:../SSC/Src/objdef.c ****                                      sSyncManOutPar.u16CycleExceededCounter = 0;
 3275              	 .loc 1 1611 0
 3276 0512 404B     	 ldr r3,.L250+8
 3277 0514 0022     	 movs r2,#0
 3278 0516 5A85     	 strh r2,[r3,#42]
1612:../SSC/Src/objdef.c ****                                      sSyncManOutPar.u16SmEventMissedCounter = 0;
 3279              	 .loc 1 1612 0
 3280 0518 3E4B     	 ldr r3,.L250+8
 3281 051a 0022     	 movs r2,#0
 3282 051c 1A85     	 strh r2,[r3,#40]
1613:../SSC/Src/objdef.c ****                                      sSyncManOutPar.u8SyncError = 0;
 3283              	 .loc 1 1613 0
 3284 051e 3D4B     	 ldr r3,.L250+8
 3285 0520 0022     	 movs r2,#0
 3286 0522 83F84020 	 strb r2,[r3,#64]
1614:../SSC/Src/objdef.c **** 
1615:../SSC/Src/objdef.c ****                                      sSyncManInPar.u16CycleExceededCounter = 0;
 3287              	 .loc 1 1615 0
 3288 0526 3D4B     	 ldr r3,.L250+16
 3289 0528 0022     	 movs r2,#0
 3290 052a 5A85     	 strh r2,[r3,#42]
1616:../SSC/Src/objdef.c ****                                      sSyncManInPar.u16SmEventMissedCounter = 0;
 3291              	 .loc 1 1616 0
 3292 052c 3B4B     	 ldr r3,.L250+16
 3293 052e 0022     	 movs r2,#0
 3294 0530 1A85     	 strh r2,[r3,#40]
1617:../SSC/Src/objdef.c ****                                      sSyncManInPar.u8SyncError = 0;
 3295              	 .loc 1 1617 0
 3296 0532 3A4B     	 ldr r3,.L250+16
 3297 0534 0022     	 movs r2,#0
 3298 0536 83F84020 	 strb r2,[r3,#64]
 3299              	.L233:
1618:../SSC/Src/objdef.c ****                                   }
1619:../SSC/Src/objdef.c ****                                } /* Subindex 8 written*/
1620:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.12) ECAT1*/
1621:../SSC/Src/objdef.c ****                             }
1622:../SSC/Src/objdef.c **** 
1623:../SSC/Src/objdef.c ****                             pVarPtr[0] = u16NewData;
 3300              	 .loc 1 1623 0
 3301 053a BB6A     	 ldr r3,[r7,#40]
 3302 053c BA8A     	 ldrh r2,[r7,#20]
 3303 053e 1A80     	 strh r2,[r3]
1624:../SSC/Src/objdef.c ****                             pData++;
 3304              	 .loc 1 1624 0
 3305 0540 BB6C     	 ldr r3,[r7,#72]
 3306 0542 0233     	 adds r3,r3,#2
 3307 0544 BB64     	 str r3,[r7,#72]
 3308              	.LBE24:
1625:../SSC/Src/objdef.c ****                             }
1626:../SSC/Src/objdef.c ****                             break;
 3309              	 .loc 1 1626 0
 3310 0546 88E0     	 b .L201
 3311              	.L213:
1627:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED32:
1628:../SSC/Src/objdef.c ****                         case    DEFTYPE_INTEGER32:
1629:../SSC/Src/objdef.c ****                         case    DEFTYPE_REAL32:
1630:../SSC/Src/objdef.c ****                         case    DEFTYPE_BITARR32:
1631:../SSC/Src/objdef.c ****                         case    DEFTYPE_DWORD:
1632:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3312              	 .loc 1 1632 0
 3313 0548 3B8B     	 ldrh r3,[r7,#24]
 3314 054a 03F00F03 	 and r3,r3,#15
 3315 054e 002B     	 cmp r3,#0
 3316 0550 01D0     	 beq .L236
1633:../SSC/Src/objdef.c ****                             {
1634:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1635:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3317              	 .loc 1 1635 0
 3318 0552 0523     	 movs r3,#5
 3319 0554 B8E0     	 b .L181
 3320              	.L236:
1636:../SSC/Src/objdef.c ****                             }
1637:../SSC/Src/objdef.c ****                             {
1638:../SSC/Src/objdef.c **** 
1639:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1640:../SSC/Src/objdef.c ****                                that the 32 bit type are always starting at an exact WORD offset */
1641:../SSC/Src/objdef.c ****                             if(bClearSubindex0Required && 
 3321              	 .loc 1 1641 0
 3322 0556 97F83330 	 ldrb r3,[r7,#51]
 3323 055a 002B     	 cmp r3,#0
 3324 055c 0FD0     	 beq .L237
1642:../SSC/Src/objdef.c ****                                 ((pVarPtr[0] != pData[0])
 3325              	 .loc 1 1642 0 discriminator 1
 3326 055e BB6A     	 ldr r3,[r7,#40]
 3327 0560 1A88     	 ldrh r2,[r3]
 3328 0562 BB6C     	 ldr r3,[r7,#72]
 3329 0564 1B88     	 ldrh r3,[r3]
1641:../SSC/Src/objdef.c ****                                 ((pVarPtr[0] != pData[0])
 3330              	 .loc 1 1641 0 discriminator 1
 3331 0566 9A42     	 cmp r2,r3
 3332 0568 07D1     	 bne .L238
1643:../SSC/Src/objdef.c ****                                 || (pVarPtr[1] != pData[1])))
 3333              	 .loc 1 1643 0
 3334 056a BB6A     	 ldr r3,[r7,#40]
 3335 056c 0233     	 adds r3,r3,#2
 3336 056e 1A88     	 ldrh r2,[r3]
 3337 0570 BB6C     	 ldr r3,[r7,#72]
 3338 0572 0233     	 adds r3,r3,#2
 3339 0574 1B88     	 ldrh r3,[r3]
 3340 0576 9A42     	 cmp r2,r3
 3341 0578 01D0     	 beq .L237
 3342              	.L238:
1644:../SSC/Src/objdef.c ****                             {
1645:../SSC/Src/objdef.c ****                                 /* try to write new data when subindex0 shall be reset*/
1646:../SSC/Src/objdef.c ****                                 return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
 3343              	 .loc 1 1646 0
 3344 057a 1C23     	 movs r3,#28
 3345 057c A4E0     	 b .L181
 3346              	.L237:
1647:../SSC/Src/objdef.c ****                             }
1648:../SSC/Src/objdef.c **** 
1649:../SSC/Src/objdef.c ****                             pVarPtr[0] = pData[0];
 3347              	 .loc 1 1649 0
 3348 057e BB6C     	 ldr r3,[r7,#72]
 3349 0580 1A88     	 ldrh r2,[r3]
 3350 0582 BB6A     	 ldr r3,[r7,#40]
 3351 0584 1A80     	 strh r2,[r3]
1650:../SSC/Src/objdef.c ****                             pVarPtr[1] = pData[1];
 3352              	 .loc 1 1650 0
 3353 0586 BB6A     	 ldr r3,[r7,#40]
 3354 0588 0233     	 adds r3,r3,#2
 3355 058a BA6C     	 ldr r2,[r7,#72]
 3356 058c 5288     	 ldrh r2,[r2,#2]
 3357 058e 1A80     	 strh r2,[r3]
1651:../SSC/Src/objdef.c ****                             pData += 2;
 3358              	 .loc 1 1651 0
 3359 0590 BB6C     	 ldr r3,[r7,#72]
 3360 0592 0433     	 adds r3,r3,#4
 3361 0594 BB64     	 str r3,[r7,#72]
1652:../SSC/Src/objdef.c ****                             }
1653:../SSC/Src/objdef.c ****                             break;
 3362              	 .loc 1 1653 0
 3363 0596 60E0     	 b .L201
 3364              	.L206:
1654:../SSC/Src/objdef.c ****                         case    DEFTYPE_REAL64:
1655:../SSC/Src/objdef.c ****                         case 	DEFTYPE_INTEGER64:
1656:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED64:
1657:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3365              	 .loc 1 1657 0
 3366 0598 3B8B     	 ldrh r3,[r7,#24]
 3367 059a 03F00F03 	 and r3,r3,#15
 3368 059e 002B     	 cmp r3,#0
 3369 05a0 01D0     	 beq .L239
1658:../SSC/Src/objdef.c ****                             {
1659:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1660:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3370              	 .loc 1 1660 0
 3371 05a2 0523     	 movs r3,#5
 3372 05a4 90E0     	 b .L181
 3373              	.L239:
1661:../SSC/Src/objdef.c ****                             }
1662:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1663:../SSC/Src/objdef.c ****                                that the 64 bit type are always starting at an exact WORD offset */
1664:../SSC/Src/objdef.c ****                             pVarPtr[0] = pData[0];
 3374              	 .loc 1 1664 0
 3375 05a6 BB6C     	 ldr r3,[r7,#72]
 3376 05a8 1A88     	 ldrh r2,[r3]
 3377 05aa BB6A     	 ldr r3,[r7,#40]
 3378 05ac 1A80     	 strh r2,[r3]
1665:../SSC/Src/objdef.c ****                             pVarPtr[1] = pData[1];
 3379              	 .loc 1 1665 0
 3380 05ae BB6A     	 ldr r3,[r7,#40]
 3381 05b0 0233     	 adds r3,r3,#2
 3382 05b2 BA6C     	 ldr r2,[r7,#72]
 3383 05b4 5288     	 ldrh r2,[r2,#2]
 3384 05b6 1A80     	 strh r2,[r3]
1666:../SSC/Src/objdef.c ****                             pVarPtr[2] = pData[2];
 3385              	 .loc 1 1666 0
 3386 05b8 BB6A     	 ldr r3,[r7,#40]
 3387 05ba 0433     	 adds r3,r3,#4
 3388 05bc BA6C     	 ldr r2,[r7,#72]
 3389 05be 9288     	 ldrh r2,[r2,#4]
 3390 05c0 1A80     	 strh r2,[r3]
1667:../SSC/Src/objdef.c ****                             pVarPtr[3] = pData[3];
 3391              	 .loc 1 1667 0
 3392 05c2 BB6A     	 ldr r3,[r7,#40]
 3393 05c4 0633     	 adds r3,r3,#6
 3394 05c6 BA6C     	 ldr r2,[r7,#72]
 3395 05c8 D288     	 ldrh r2,[r2,#6]
 3396 05ca 1A80     	 strh r2,[r3]
1668:../SSC/Src/objdef.c ****                             pData += 4;
 3397              	 .loc 1 1668 0
 3398 05cc BB6C     	 ldr r3,[r7,#72]
 3399 05ce 0833     	 adds r3,r3,#8
 3400 05d0 BB64     	 str r3,[r7,#72]
1669:../SSC/Src/objdef.c ****                             break;
 3401              	 .loc 1 1669 0
 3402 05d2 42E0     	 b .L201
 3403              	.L215:
1670:../SSC/Src/objdef.c ****                         case    DEFTYPE_VISIBLESTRING:
1671:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3404              	 .loc 1 1671 0
 3405 05d4 3B8B     	 ldrh r3,[r7,#24]
 3406 05d6 03F00F03 	 and r3,r3,#15
 3407 05da 002B     	 cmp r3,#0
 3408 05dc 01D0     	 beq .L240
1672:../SSC/Src/objdef.c ****                             {
1673:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1674:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3409              	 .loc 1 1674 0
 3410 05de 0523     	 movs r3,#5
 3411 05e0 72E0     	 b .L181
 3412              	.L240:
1675:../SSC/Src/objdef.c ****                             }
1676:../SSC/Src/objdef.c **** 
1677:../SSC/Src/objdef.c ****                             OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
 3413              	 .loc 1 1677 0
 3414 05e2 FB69     	 ldr r3,[r7,#28]
 3415 05e4 5B88     	 ldrh r3,[r3,#2]
 3416 05e6 0733     	 adds r3,r3,#7
 3417 05e8 DB10     	 asrs r3,r3,#3
 3418 05ea B86A     	 ldr r0,[r7,#40]
 3419 05ec B96C     	 ldr r1,[r7,#72]
 3420 05ee 1A46     	 mov r2,r3
 3421 05f0 FFF7FEFF 	 bl memcpy
1678:../SSC/Src/objdef.c **** 
1679:../SSC/Src/objdef.c ****                             pData += BIT2WORD((pEntry->BitLength)& ~0xF);
 3422              	 .loc 1 1679 0
 3423 05f4 FB69     	 ldr r3,[r7,#28]
 3424 05f6 5B88     	 ldrh r3,[r3,#2]
 3425 05f8 23F00F03 	 bic r3,r3,#15
 3426 05fc 0F33     	 adds r3,r3,#15
 3427 05fe 1B11     	 asrs r3,r3,#4
 3428 0600 5B00     	 lsls r3,r3,#1
 3429 0602 BA6C     	 ldr r2,[r7,#72]
 3430 0604 1344     	 add r3,r3,r2
 3431 0606 BB64     	 str r3,[r7,#72]
1680:../SSC/Src/objdef.c ****                             break;
 3432              	 .loc 1 1680 0
 3433 0608 27E0     	 b .L201
 3434              	.L251:
 3435 060a 00BF     	 .align 2
 3436              	.L250:
 3437 060c 00000000 	 .word cBitMask
 3438 0610 00000000 	 .word bSyncSetByUser
 3439 0614 00000000 	 .word sSyncManOutPar
 3440 0618 48E80100 	 .word 125000
 3441 061c 00000000 	 .word sSyncManInPar
 3442              	.L216:
1681:../SSC/Src/objdef.c ****                         case    DEFTYPE_OCTETSTRING:
1682:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNICODE_STRING:
1683:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_INT :
1684:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_SINT :
1685:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_DINT :
1686:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_UDINT:
1687:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3443              	 .loc 1 1687 0
 3444 0620 3B8B     	 ldrh r3,[r7,#24]
 3445 0622 03F00F03 	 and r3,r3,#15
 3446 0626 002B     	 cmp r3,#0
 3447 0628 01D0     	 beq .L241
1688:../SSC/Src/objdef.c ****                             {
1689:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1690:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3448              	 .loc 1 1690 0
 3449 062a 0523     	 movs r3,#5
 3450 062c 4CE0     	 b .L181
 3451              	.L241:
1691:../SSC/Src/objdef.c ****                             }
1692:../SSC/Src/objdef.c **** 
1693:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1694:../SSC/Src/objdef.c ****                                that the other types are always starting at an even byte offset */
1695:../SSC/Src/objdef.c ****                             OBJTOMBXMEMCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
 3452              	 .loc 1 1695 0
 3453 062e FB69     	 ldr r3,[r7,#28]
 3454 0630 5B88     	 ldrh r3,[r3,#2]
 3455 0632 0733     	 adds r3,r3,#7
 3456 0634 DB10     	 asrs r3,r3,#3
 3457 0636 B86A     	 ldr r0,[r7,#40]
 3458 0638 B96C     	 ldr r1,[r7,#72]
 3459 063a 1A46     	 mov r2,r3
 3460 063c FFF7FEFF 	 bl memcpy
1696:../SSC/Src/objdef.c ****                             pData += BIT2WORD((pEntry->BitLength) & ~0xF);
 3461              	 .loc 1 1696 0
 3462 0640 FB69     	 ldr r3,[r7,#28]
 3463 0642 5B88     	 ldrh r3,[r3,#2]
 3464 0644 23F00F03 	 bic r3,r3,#15
 3465 0648 0F33     	 adds r3,r3,#15
 3466 064a 1B11     	 asrs r3,r3,#4
 3467 064c 5B00     	 lsls r3,r3,#1
 3468 064e BA6C     	 ldr r2,[r7,#72]
 3469 0650 1344     	 add r3,r3,r2
 3470 0652 BB64     	 str r3,[r7,#72]
1697:../SSC/Src/objdef.c **** 
1698:../SSC/Src/objdef.c ****                             break;
 3471              	 .loc 1 1698 0
 3472 0654 01E0     	 b .L201
 3473              	.L205:
1699:../SSC/Src/objdef.c ****                         default:
1700:../SSC/Src/objdef.c ****                             /* other data types are not supported from this example */
1701:../SSC/Src/objdef.c ****                             return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 3474              	 .loc 1 1701 0
 3475 0656 1823     	 movs r3,#24
 3476 0658 36E0     	 b .L181
 3477              	.L201:
 3478              	.LBE22:
1702:../SSC/Src/objdef.c ****                         }
1703:../SSC/Src/objdef.c ****                     }
1704:../SSC/Src/objdef.c **** 
1705:../SSC/Src/objdef.c ****                     /* set flag */
1706:../SSC/Src/objdef.c ****                     bWritten = 1;
 3479              	 .loc 1 1706 0
 3480 065a 0123     	 movs r3,#1
 3481 065c 87F82F30 	 strb r3,[r7,#47]
 3482 0660 22E0     	 b .L242
 3483              	.L195:
 3484              	.LBE20:
1707:../SSC/Src/objdef.c **** 
1708:../SSC/Src/objdef.c ****                 }
1709:../SSC/Src/objdef.c ****             }
1710:../SSC/Src/objdef.c ****             else
1711:../SSC/Src/objdef.c ****             {
1712:../SSC/Src/objdef.c ****                 if(i == 0)
 3485              	 .loc 1 1712 0
 3486 0662 FB8E     	 ldrh r3,[r7,#54]
 3487 0664 002B     	 cmp r3,#0
 3488 0666 03D1     	 bne .L243
1713:../SSC/Src/objdef.c ****                 {
1714:../SSC/Src/objdef.c ****                     /* For SubIndex0 16Bit are reserved even if the BitLength is 8 */
1715:../SSC/Src/objdef.c ****                     pData++;
 3489              	 .loc 1 1715 0
 3490 0668 BB6C     	 ldr r3,[r7,#72]
 3491 066a 0233     	 adds r3,r3,#2
 3492 066c BB64     	 str r3,[r7,#72]
 3493 066e 18E0     	 b .L244
 3494              	.L243:
1716:../SSC/Src/objdef.c ****                 }
1717:../SSC/Src/objdef.c ****                 else
1718:../SSC/Src/objdef.c ****                 {
1719:../SSC/Src/objdef.c ****                     /*Handle Bit/Byte Offset*/
1720:../SSC/Src/objdef.c ****                     if (((pEntry->BitLength & 0xF) > 0)
 3495              	 .loc 1 1720 0
 3496 0670 FB69     	 ldr r3,[r7,#28]
 3497 0672 5B88     	 ldrh r3,[r3,#2]
 3498 0674 03F00F03 	 and r3,r3,#15
 3499 0678 002B     	 cmp r3,#0
 3500 067a 0ADD     	 ble .L245
1721:../SSC/Src/objdef.c ****                         && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 3501              	 .loc 1 1721 0
 3502 067c 3B8B     	 ldrh r3,[r7,#24]
 3503 067e FA69     	 ldr r2,[r7,#28]
 3504 0680 5288     	 ldrh r2,[r2,#2]
 3505 0682 1344     	 add r3,r3,r2
 3506 0684 03F00F03 	 and r3,r3,#15
 3507 0688 002B     	 cmp r3,#0
 3508 068a 02D1     	 bne .L245
1722:../SSC/Src/objdef.c ****                     {
1723:../SSC/Src/objdef.c ****                         /* we have reached the UINT16 border */
1724:../SSC/Src/objdef.c ****                         pData++;
 3509              	 .loc 1 1724 0
 3510 068c BB6C     	 ldr r3,[r7,#72]
 3511 068e 0233     	 adds r3,r3,#2
 3512 0690 BB64     	 str r3,[r7,#72]
 3513              	.L245:
1725:../SSC/Src/objdef.c ****                     }
1726:../SSC/Src/objdef.c **** 
1727:../SSC/Src/objdef.c ****                     /*increment WORD offset*/
1728:../SSC/Src/objdef.c ****                     pData += ((pEntry->BitLength & 0xFFF0) >> 4);
 3514              	 .loc 1 1728 0
 3515 0692 FB69     	 ldr r3,[r7,#28]
 3516 0694 5B88     	 ldrh r3,[r3,#2]
 3517 0696 1B09     	 lsrs r3,r3,#4
 3518 0698 9BB2     	 uxth r3,r3
 3519 069a 5B00     	 lsls r3,r3,#1
 3520 069c BA6C     	 ldr r2,[r7,#72]
 3521 069e 1344     	 add r3,r3,r2
 3522 06a0 BB64     	 str r3,[r7,#72]
 3523              	.L244:
1729:../SSC/Src/objdef.c ****                 }
1730:../SSC/Src/objdef.c ****                 /*If no other entry was written this result will be returned*/
1731:../SSC/Src/objdef.c ****                 result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 3524              	 .loc 1 1731 0
 3525 06a2 1823     	 movs r3,#24
 3526 06a4 87F82E30 	 strb r3,[r7,#46]
 3527              	.L242:
 3528              	.LBE19:
1400:../SSC/Src/objdef.c ****         {
 3529              	 .loc 1 1400 0 discriminator 2
 3530 06a8 FB8E     	 ldrh r3,[r7,#54]
 3531 06aa 0133     	 adds r3,r3,#1
 3532 06ac FB86     	 strh r3,[r7,#54]
 3533              	.L194:
1400:../SSC/Src/objdef.c ****         {
 3534              	 .loc 1 1400 0 is_stmt 0 discriminator 1
 3535 06ae FA8E     	 ldrh r2,[r7,#54]
 3536 06b0 3B8E     	 ldrh r3,[r7,#48]
 3537 06b2 9A42     	 cmp r2,r3
 3538 06b4 7FF67DAD 	 bls .L246
1732:../SSC/Src/objdef.c ****             }
1733:../SSC/Src/objdef.c ****         }
1734:../SSC/Src/objdef.c **** 
1735:../SSC/Src/objdef.c ****         if (bWritten == 0)
 3539              	 .loc 1 1735 0 is_stmt 1
 3540 06b8 97F82F30 	 ldrb r3,[r7,#47]
 3541 06bc 002B     	 cmp r3,#0
 3542 06be 02D1     	 bne .L247
1736:../SSC/Src/objdef.c ****         {
1737:../SSC/Src/objdef.c ****             /* we didn't write anything, so we have to return the stored error code */
1738:../SSC/Src/objdef.c ****             return result;
 3543              	 .loc 1 1738 0
 3544 06c0 97F82E30 	 ldrb r3,[r7,#46]
 3545 06c4 00E0     	 b .L181
 3546              	.L247:
 3547              	.LBE18:
1739:../SSC/Src/objdef.c ****         }
1740:../SSC/Src/objdef.c ****     }
1741:../SSC/Src/objdef.c **** 
1742:../SSC/Src/objdef.c ****     return 0;
 3548              	 .loc 1 1742 0
 3549 06c6 0023     	 movs r3,#0
 3550              	.L181:
1743:../SSC/Src/objdef.c **** }
 3551              	 .loc 1 1743 0
 3552 06c8 1846     	 mov r0,r3
 3553 06ca 3C37     	 adds r7,r7,#60
 3554              	.LCFI64:
 3555              	 .cfi_def_cfa_offset 12
 3556 06cc BD46     	 mov sp,r7
 3557              	.LCFI65:
 3558              	 .cfi_def_cfa_register 13
 3559              	 
 3560 06ce 90BD     	 pop {r4,r7,pc}
 3561              	 .cfi_endproc
 3562              	.LFE190:
 3564              	 .text
 3565              	.Letext0:
 3566              	 .file 2 "c:\\tools\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 3567              	 .file 3 "c:\\tools\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 3568              	 .file 4 "../SSC/Src/sdoserv.h"
 3569              	 .file 5 "../SSC/Src/objdef.h"
 3570              	 .file 6 "C:/Users/Admin/DaveWorkspaces/XMC4300_PWMTest/Libraries/CMSIS/Include/cmsis_gcc.h"
 3571              	 .file 7 "C:/Users/Admin/DaveWorkspaces/XMC4300_PWMTest/Libraries/CMSIS/Include/core_cm4.h"
 3572              	 .file 8 "../SSC/Src/ecatslv.h"
DEFINED SYMBOLS
                            *ABS*:00000000 objdef.c
                            *COM*:00000001 bSyncSetByUser
                            *COM*:00000002 sCycleDiag
                            *COM*:00000044 sSyncManOutPar
                            *COM*:00000044 sSyncManInPar
    {standard input}:28     .data.sErrorSettings:00000000 sErrorSettings
    {standard input}:25     .data.sErrorSettings:00000000 $d
    {standard input}:39     .data.aSubindexDesc:00000000 aSubindexDesc
    {standard input}:36     .data.aSubindexDesc:00000000 $d
    {standard input}:46     .rodata.cBitMask:00000000 cBitMask
    {standard input}:43     .rodata.cBitMask:00000000 $d
    {standard input}:64     .text.OBJ_GetObjectHandle:00000000 $t
    {standard input}:69     .text.OBJ_GetObjectHandle:00000000 OBJ_GetObjectHandle
    {standard input}:131    .text.OBJ_GetObjectLength:00000000 $t
    {standard input}:136    .text.OBJ_GetObjectLength:00000000 OBJ_GetObjectLength
    {standard input}:344    .text.OBJ_CopyNumberToString:00000000 $t
    {standard input}:349    .text.OBJ_CopyNumberToString:00000000 OBJ_CopyNumberToString
    {standard input}:446    .text.OBJ_CopyNumberToString:0000008c $d
    {standard input}:452    .text.OBJ_GetNoOfObjects:00000000 $t
    {standard input}:457    .text.OBJ_GetNoOfObjects:00000000 OBJ_GetNoOfObjects
    {standard input}:991    .text.OBJ_GetEntryDesc:00000000 OBJ_GetEntryDesc
    {standard input}:583    .text.OBJ_GetObjectList:00000000 $t
    {standard input}:588    .text.OBJ_GetObjectList:00000000 OBJ_GetObjectList
    {standard input}:774    .text.OBJ_GetObjectList:000000f4 $d
    {standard input}:779    .text.OBJ_GetDesc:00000000 $t
    {standard input}:784    .text.OBJ_GetDesc:00000000 OBJ_GetDesc
    {standard input}:981    .text.OBJ_GetDesc:0000011c $d
    {standard input}:986    .text.OBJ_GetEntryDesc:00000000 $t
    {standard input}:1069   .text.OBJ_GetObjDesc:00000000 $t
    {standard input}:1074   .text.OBJ_GetObjDesc:00000000 OBJ_GetObjDesc
    {standard input}:1113   .text.OBJ_GetEntryOffset:00000000 $t
    {standard input}:1118   .text.OBJ_GetEntryOffset:00000000 OBJ_GetEntryOffset
    {standard input}:1364   .text.CheckSyncTypeValue:00000000 $t
    {standard input}:1369   .text.CheckSyncTypeValue:00000000 CheckSyncTypeValue
    {standard input}:1399   .text.CheckSyncTypeValue:00000020 $d
    {standard input}:1434   .text.CheckSyncTypeValue:000000ac $t
    {standard input}:1597   .text.CheckSyncTypeValue:0000019c $d
    {standard input}:1605   .text.OBJ_Read:00000000 $t
    {standard input}:1610   .text.OBJ_Read:00000000 OBJ_Read
    {standard input}:2086   .text.OBJ_Read:00000324 $d
    {standard input}:2090   .text.OBJ_Read:00000328 $t
    {standard input}:2489   .text.OBJ_Read:000005ac $d
    {standard input}:2494   .text.OBJ_Write:00000000 $t
    {standard input}:2499   .text.OBJ_Write:00000000 OBJ_Write
    {standard input}:3033   .text.OBJ_Write:00000374 $d
    {standard input}:3037   .text.OBJ_Write:00000378 $t
    {standard input}:3437   .text.OBJ_Write:0000060c $d
    {standard input}:3444   .text.OBJ_Write:00000620 $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
COE_GetObjectDictionary
pSdoInfoObjEntry
strlen
memcpy
nPdOutputSize
nPdInputSize
nAlStatus
