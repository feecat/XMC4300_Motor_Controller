   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "ecatslv.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_ECAT_GetALEventRegister,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_ECAT_GetALEventRegister:
  25              	.LFB138:
  26              	 .file 1 "C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc/xmc_ecat.h"
   1:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
   2:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
   3:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @file xmc_ecat.h
   4:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @date 2015-12-27
   5:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
   6:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @cond
   7:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
   8:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * XMClib v2.1.24 - XMC Peripheral Driver Library 
   9:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  10:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Copyright (c) 2015-2019, Infineon Technologies AG
  11:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * All rights reserved.                        
  12:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *                                             
  13:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  14:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * following conditions are met:   
  15:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *                                                                              
  16:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  17:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * disclaimer.                        
  18:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * 
  19:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  20:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  21:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * 
  22:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  23:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * products derived from this software without specific prior written permission.                  
  24:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *                                                                              
  25:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  26:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  27:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  28:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  29:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  30:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  32:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *                                                                              
  33:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  34:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  35:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  36:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  37:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Change History
  38:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * --------------
  39:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  40:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * 2015-12-27:
  41:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *     - Initial Version<br>
  42:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  43:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @endcond
  44:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  45:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  46:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
  47:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @addtogroup XMClib XMC Peripheral Library
  48:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @{
  49:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  50:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  51:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
  52:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @addtogroup ECAT
  53:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @brief EtherCAT Low level driver for XMC4800/XMC4300 series.
  54:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  55:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * EtherCAT is an Ethernet-based fieldbus system.
  56:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The EtherCAT Slave Controller (ECAT) read the data addressed to them while the telegram passes t
  57:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * An EtherCAT Slave Controller (ESC) takes care of the EtherCAT communication as an interface betw
  58:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * fieldbus and the slave application. EtherCAT uses standard IEEE 802.3 Ethernet frames, thus a st
  59:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * controller can be used and no special hardware is required on master side. EtherCAT has a reserv
  60:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * 0x88A4 that distinguishes it from other Ethernet frames. Thus, EtherCAT can run in parallel to o
  61:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * protocols. EtherCAT does not require the IP protocol, however it can be encapsulated in IP/UDP. 
  62:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Slave Controller processes the frame in hardware. Thus, communication performance is independent
  63:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * power.
  64:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  65:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The XMC_ECAT low level driver provides functions to configure and initialize the ECAT hardware p
  66:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * For EHTERCAT stack integration, the necessary hardware accees layer APIs shall be explicitly imp
  67:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * upon the stack provider. The XMC_ECAT lld layer provides only the hardware initialization functi
  68:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * basic functionalities.
  69:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @{
  70:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  71:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  72:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #ifndef XMC_ECAT_H
  73:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #define XMC_ECAT_H
  74:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  75:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
  76:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * HEADER FILES
  77:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  78:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  79:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #include "xmc_common.h"
  80:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  81:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #if defined (ECAT0)
  82:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  83:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #include "xmc_ecat_map.h"
  84:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  85:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
  86:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * MACROS
  87:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  88:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  89:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
  90:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * ENUMS
  91:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  92:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
  93:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
  94:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * ECAT status return values
  95:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  96:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** typedef enum XMC_ECAT_STATUS
  97:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** {
  98:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_STATUS_OK    = 0U, /**< Driver accepted application request */
  99:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_STATUS_BUSY  = 1U, /**< Driver is busy and cannot handle request */
 100:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_STATUS_ERROR = 2U  /**< Driver could not fulfil application request */
 101:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_STATUS_t;
 102:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 103:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 104:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * EtherCAT event enumeration types
 105:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 106:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** typedef enum XMC_ECAT_EVENT
 107:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** {
 108:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_AL_CONTROL = ECAT_AL_EVENT_MASK_AL_CE_MASK_Msk, /**< Application control event mas
 109:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_DC_LATCH = ECAT_AL_EVENT_MASK_DC_LE_MASK_Msk,  /**< Distributed Clock latch event 
 110:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_DC_SYNC0 = ECAT_AL_EVENT_MASK_ST_S0_MASK_Msk, /**< State of distributed clock sync
 111:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_DC_SYNC1 = ECAT_AL_EVENT_MASK_ST_S1_MASK_Msk, /**< State of distributed clock sync
 112:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM_ACTIVATION_REGISTER = ECAT_AL_EVENT_MASK_SM_A_MASK_Msk, /**< SyncManager activa
 113:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_EEPROM = ECAT_AL_EVENT_MASK_EEP_E_MASK_Msk, /**< EEPROM Emulation event mask*/
 114:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_WATCHDOG = ECAT_AL_EVENT_MASK_WP_D_MASK_Msk, /**< WATCHDOG process data event mask
 115:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM0 = ECAT_AL_EVENT_MASK_SMI_0_MASK_Msk, /**< Sync Manager 0 event mask*/
 116:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM1 = ECAT_AL_EVENT_MASK_SMI_1_MASK_Msk, /**< Sync Manager 1 event mask*/
 117:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM2 = ECAT_AL_EVENT_MASK_SMI_2_MASK_Msk, /**< Sync Manager 2 event mask*/
 118:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM3 = ECAT_AL_EVENT_MASK_SMI_3_MASK_Msk, /**< Sync Manager 3 event mask*/
 119:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM4 = ECAT_AL_EVENT_MASK_SMI_4_MASK_Msk, /**< Sync Manager 4 event mask*/
 120:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM5 = ECAT_AL_EVENT_MASK_SMI_5_MASK_Msk, /**< Sync Manager 5 event mask*/
 121:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM6 = ECAT_AL_EVENT_MASK_SMI_6_MASK_Msk, /**< Sync Manager 6 event mask*/
 122:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM7 = ECAT_AL_EVENT_MASK_SMI_7_MASK_Msk  /**< Sync Manager 7 event mask*/
 123:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_EVENT_t;
 124:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 125:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
 126:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * DATA STRUCTURES
 127:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
 128:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 129:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /* Anonymous structure/union guard start */
 130:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #if defined (__CC_ARM)
 131:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma push
 132:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma anon_unions
 133:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #elif defined (__TASKING__)
 134:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma warning 586
 135:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #endif
 136:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 137:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 138:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * ECAT port control data structure
 139:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 140:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** typedef struct XMC_ECAT_PORT_CTRL
 141:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** {
 142:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   union 
 143:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   {
 144:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     struct
 145:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     {
 146:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t enable_rstreq: 1;     /**< Master can trigger a reset of the XMC4700 / XMC4800 (::bo
 147:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 7;                   /**< Reserved bits */
 148:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t latch_input0: 2;      /**< Latch input 0 selection (::XMC_ECAT_PORT_LATCHIN0_t) */
 149:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;                   /**< Reserved bits */
 150:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t latch_input1: 2;      /**< Latch input 1 selection (::XMC_ECAT_PORT_LATCHIN1_t) */
 151:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;                   /**< Reserved bits */
 152:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t phyaddr_offset: 5;    /**< Ethernet PHY address offset, address of port 0 */
 153:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 1;                   /**< Reserved bits */
 154:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t mdio: 2;              /**< Bidirectional, push-pull management data I/O line (::XMC_
 155:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 8;                   /**< Reserved bits */
 156:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     };
 157:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 158:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t raw;
 159:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   } common;
 160:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 161:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   union 
 162:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   {  
 163:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     struct
 164:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     {
 165:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd0: 2;     /**< Receive data bit 0 (::XMC_ECAT_PORT0_CTRL_RXD0_t) */
 166:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd1: 2;     /**< Receive data bit 1 (::XMC_ECAT_PORT0_CTRL_RXD1_t) */
 167:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd2: 2;     /**< Receive data bit 2 (::XMC_ECAT_PORT0_CTRL_RXD2_t) */
 168:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd3: 2;     /**< Receive data bit 3 (::XMC_ECAT_PORT0_CTRL_RXD3_t) */
 169:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_err: 2;   /**< RX Error (::XMC_ECAT_PORT0_CTRL_RX_ERR_t) */
 170:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_dv: 2;    /**< RX Data valid (::XMC_ECAT_PORT0_CTRL_RX_DV_t) */
 171:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_clk: 2;   /**< RX Clock (::XMC_ECAT_PORT0_CTRL_RX_CLK_t) */
 172:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;          /**< Reserved bits */
 173:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t link: 2;     /**< Link status (::XMC_ECAT_PORT0_CTRL_LINK_t) */
 174:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 10;         /**< Reserved bits */
 175:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_clk: 2;   /**< TX Clock (::XMC_ECAT_PORT0_CTRL_TX_CLK_t) */
 176:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_shift: 2; /**< TX signal delay (::XMC_ECAT_PORT0_CTRL_TX_SHIFT_t) */
 177:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     };
 178:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 179:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t raw;
 180:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   } port0;
 181:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 182:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   union 
 183:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   {      
 184:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     struct
 185:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     {
 186:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd0: 2;     /**< Receive data bit 0 (::XMC_ECAT_PORT_CTRL_RXD0_t) */
 187:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd1: 2;     /**< Receive data bit 1 (::XMC_ECAT_PORT_CTRL_RXD1_t) */
 188:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd2: 2;     /**< Receive data bit 2 (::XMC_ECAT_PORT_CTRL_RXD2_t) */
 189:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd3: 2;     /**< Receive data bit 3 (::XMC_ECAT_PORT_CTRL_RXD3_t) */
 190:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_err: 2;   /**< RX Error (::XMC_ECAT_PORT_CTRL_RX_ERR_t) */
 191:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_dv: 2;    /**< RX Data valid (::XMC_ECAT_PORT_CTRL_RX_DV_t) */
 192:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_clk: 2;   /**< RX Clock (::XMC_ECAT_PORT_CTRL_RX_CLK_t) */
 193:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;          /**< Reserved bits */
 194:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t link: 2;     /**< Link status (::XMC_ECAT_PORT_CTRL_LINK_t) */
 195:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 10;         /**< Reserved bits */
 196:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_clk: 2;   /**< TX Clock (::XMC_ECAT_PORT_CTRL_TX_CLK_t) */
 197:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_shift: 2; /**< TX signal delay (::XMC_ECAT_PORT1_CTRL_TX_SHIFT_t) */
 198:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     };
 199:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 200:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t raw;
 201:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   } port1;
 202:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   
 203:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_PORT_CTRL_t;
 204:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 205:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 206:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * ECAT EEPROM configuration area data structure
 207:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 208:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** typedef union XMC_ECAT_CONFIG
 209:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** {
 210:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   struct
 211:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   {
 212:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 8;
 213:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 214:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 2;
 215:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_dc_sync_out : 1;
 216:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_dc_latch_in : 1;
 217:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_enhanced_link_p0 : 1;
 218:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_enhanced_link_p1 : 1;
 219:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 2;
 220:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 221:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 16;
 222:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 223:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t sync_pulse_length; /**< Initialization value for Pulse Length of SYNC Signals register
 224:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 225:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 16;
 226:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 227:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t station_alias; /**< Initialization value for Configured Station Alias Address register
 228:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 229:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t : 16;
 230:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 231:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t : 16;
 232:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 233:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t checksum;
 234:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   };
 235:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 236:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   uint32_t dword[4]; /**< Four 32 bit double word equivalent to 8 16 bit configuration area word. *
 237:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_CONFIG_t;
 238:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 239:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /* Anonymous structure/union guard end */
 240:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #if defined (__CC_ARM)
 241:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma pop
 242:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #elif defined (__TASKING__)
 243:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma warning restore
 244:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #endif
 245:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 246:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
 247:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * API PROTOTYPES
 248:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
 249:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 250:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #ifdef __cplusplus
 251:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** extern "C" {
 252:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** #endif
 253:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 254:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 255:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param config XMC_ECAT_CONFIG_t
 256:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return XMC_ECAT_STATUS_t ECAT Initialization status
 257:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 258:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 259:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Initialize the Ethernet MAC peripheral <br>
 260:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 261:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 262:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function sets the link speed, applies the duplex mode, sets auto-negotiation
 263:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * and loop-back settings.
 264:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 265:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_Init(XMC_ECAT_CONFIG_t *const config);
 266:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 267:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 268:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 269:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 270:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 271:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 272:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Enable the EtherCAT peripheral <br>
 273:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 274:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 275:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function de-asserts the peripheral reset.
 276:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 277:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_Enable(void);
 278:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 279:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 280:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 281:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 282:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 283:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 284:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Disable the EtherCAT peripheral <br>
 285:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 286:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 287:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function asserts the peripheral reset.
 288:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 289:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_Disable(void);
 290:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 291:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 292:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param phy_addr PHY address
 293:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param reg_addr Register address
 294:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param data The destination to which the read data needs to be copied to.
 295:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 296:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return XMC_ECAT_STATUS_t EtherCAT Read PHY API return status
 297:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 298:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 299:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Read a PHY register <br>
 300:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 301:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 302:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function reads a PHY register. It essentially polls busy bit during max
 303:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * PHY_TIMEOUT time and reads the information into 'data' when not busy.
 304:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 305:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** XMC_ECAT_STATUS_t XMC_ECAT_ReadPhy(uint8_t phy_addr, uint8_t reg_addr, uint16_t *data);
 306:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 307:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 308:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param phy_addr PHY address
 309:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param reg_addr Register address
 310:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param data The data to write
 311:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return XMC_ECAT_STATUS_t EtherCAT Write PHY API return status
 312:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 313:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 314:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Write a PHY register <br>
 315:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 316:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 317:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function reads a PHY register. It essentially writes the data and polls
 318:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * the busy bit until it is no longer busy.
 319:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 320:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** XMC_ECAT_STATUS_t XMC_ECAT_WritePhy(uint8_t phy_addr, uint8_t reg_addr, uint16_t data);
 321:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 322:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 323:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param port_ctrl Port control configuration
 324:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 325:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 326:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 327:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Set port control configuration <br>
 328:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 329:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 330:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function sets the port control by writing the configuration into the ECAT CON register.
 331:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 332:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 333:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** __STATIC_INLINE void XMC_ECAT_SetPortControl(const XMC_ECAT_PORT_CTRL_t port_ctrl)
 334:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** {
 335:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   ECAT0_CON->CON = (uint32_t)port_ctrl.common.raw;
 336:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   ECAT0_CON->CONP0 = (uint32_t)port_ctrl.port0.raw;
 337:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   ECAT0_CON->CONP1 = (uint32_t)port_ctrl.port1.raw;
 338:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** }
 339:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 340:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 341:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param event Single or logically OR'd events specified in the enum type @refXMC_ECAT_EVENT_t
 342:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 343:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 344:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 345:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Enable ECAT event(s) <br>
 346:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 347:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 348:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function can be used to enable ECAT event(s).
 349:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 350:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_EnableEvent(uint32_t event);
 351:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 352:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 353:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param event Single or logically OR'd events specified in the enum type @refXMC_ECAT_EVENT_t
 354:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 355:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 356:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 357:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Disable an ECAT event(s) <br>
 358:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 359:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 360:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function can be used to disable ECAT event(s).
 361:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 362:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_DisableEvent(uint32_t event);
 363:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 364:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 365:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 366:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return uint32_t Event status
 367:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 368:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 369:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Get event status <br>
 370:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 371:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 372:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function returns the ECAT status and interrupt status as a single word. The user
 373:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * can then check the status of the events by using an appropriate mask.
 374:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 375:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** uint32_t XMC_ECAT_GetEventStatus(void);
 376:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 377:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 378:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 379:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param channel SyncManager channel number.
 380:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 381:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 382:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 383:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Disables selected SyncManager channel <br>
 384:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 385:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 386:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Sets bit 0 of the corresponding 0x807 register.
 387:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 388:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_DisableSyncManChannel(const uint8_t channel);
 389:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 390:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 391:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param channel SyncManager channel number.
 392:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 393:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 394:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 395:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Enables selected SyncManager channel <br>
 396:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 397:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 398:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Resets bit 0 of the corresponding 0x807 register.
 399:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 400:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_EnableSyncManChannel(const uint8_t channel);
 401:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** 
 402:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 403:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 404:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return uint16_t Content of register 0x220-0x221
 405:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 406:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 407:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Get content of AL event register <br>
 408:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 409:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 410:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  * Get the first two bytes of the AL Event register (0x220-0x221).
 411:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 412:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** __STATIC_INLINE uint16_t XMC_ECAT_GetALEventRegister(void)
 413:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** {
  27              	 .loc 1 413 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 00AF     	 add r7,sp,#0
  37              	.LCFI1:
  38              	 .cfi_def_cfa_register 7
 414:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h ****   return ((uint16_t)ECAT0->AL_EVENT_REQ);
  39              	 .loc 1 414 0
  40 0004 044B     	 ldr r3,.L3
  41 0006 D3F82032 	 ldr r3,[r3,#544]
  42 000a 9BB2     	 uxth r3,r3
 415:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/XMCLib/inc\xmc_ecat.h **** }
  43              	 .loc 1 415 0
  44 000c 1846     	 mov r0,r3
  45 000e BD46     	 mov sp,r7
  46              	.LCFI2:
  47              	 .cfi_def_cfa_register 13
  48              	 
  49 0010 5DF8047B 	 ldr r7,[sp],#4
  50              	.LCFI3:
  51              	 .cfi_restore 7
  52              	 .cfi_def_cfa_offset 0
  53 0014 7047     	 bx lr
  54              	.L4:
  55 0016 00BF     	 .align 2
  56              	.L3:
  57 0018 00000154 	 .word 1409351680
  58              	 .cfi_endproc
  59              	.LFE138:
  61              	 .section .text.HW_EscRead,"ax",%progbits
  62              	 .align 2
  63              	 .thumb
  64              	 .thumb_func
  66              	HW_EscRead:
  67              	.LFB171:
  68              	 .file 2 "C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC/xmc_eschw.h"
   1:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
   2:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @file xmc_eschw.h
   3:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @date 2018-01-24
   4:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
   5:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * NOTE:
   6:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * This file is copied by DAVE. Any manual modification done to this file will be lost when the cod
   7:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
   8:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @cond
   9:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  10:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * ECAT_SSC v4.0.26 - ECAT_SSC APP initializes the XMC ESC and sets up the interface for Beckhoff E
  11:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  12:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Copyright (c) 2016-2019, Infineon Technologies AG
  13:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * All rights reserved.
  14:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  15:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  16:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * following conditions are met:
  17:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  18:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  19:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   disclaimer.
  20:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  21:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  22:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   disclaimer in the documentation and/or other materials provided with the distribution.
  23:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  24:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  25:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   products derived from this software without specific prior written permission.
  26:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  27:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  28:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  29:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  30:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  31:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  32:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  33:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  35:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  36:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * with Infineon Technologies AG (dave@infineon.com).
  37:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  38:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  39:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Change History
  40:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * --------------
  41:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  42:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * 2016-02-05:
  43:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *     - Initial version
  44:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  45:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * 2018-01-24:
  46:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *     - Added HW_ClearTimer()
  47:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  48:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @endcond
  49:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  50:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
  51:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  52:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #ifndef XMC_ESCHW_H
  53:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define XMC_ESCHW_H
  54:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  55:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**************************************************************************************************
  56:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * HEADER FILES
  57:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  58:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #include "SSC/Src/esc.h"
  59:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #include "xmc_ecat.h"
  60:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #include "../E_EEPROM_XMC4/e_eeprom_xmc4.h"
  61:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  62:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  /*************************************************************************************************
  63:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   * MACROS
  64:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   *************************************************************************************************
  65:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  66:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define ECAT_TIMER_INC_P_MS (1U) /**< Timer increment value */
  67:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  68:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define pEsc ((uint8_t *)ECAT0)  /**< EtherCAT module address */
  69:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  70:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** extern uint8_t aEepromData[];
  71:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  72:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**************************************************************************************************
  73:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * API Prototypes
  74:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  75:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  76:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #ifdef __cplusplus
  77:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** extern "C" {
  78:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #endif
  79:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  80:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
  81:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @ingroup ECAT_SSC_apidoc
  82:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @{
  83:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
  84:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  85:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadDWord(DWordValue, Address)     ((DWordValue) = (UINT32)(((volatile UINT32 *)pEsc)
  86:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  87:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadDWordIsr(DWordValue, Address)  HW_EscReadDWord(DWordValue, Address)              
  88:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  89:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadWord(WordValue, Address)       ((WordValue) = (((volatile UINT16 *)pEsc)[((Addres
  90:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  91:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadWordIsr(WordValue, Address)    HW_EscReadWord(WordValue, Address)                
  92:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  93:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadByte(ByteValue, Address)       ((ByteValue) = (((volatile UINT8 *)pEsc)[(Address)
  94:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  95:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadByteIsr(ByteValue, Address)    HW_EscReadByte(ByteValue, Address)                
  96:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  97:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteDWord(DWordValue, Address)    ((((volatile UINT32 *)pEsc)[(Address>>2)]) = (DWor
  98:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  99:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteDWordIsr(DWordValue, Address) HW_EscWriteWord(DWordValue, Address)              
 100:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 101:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteWord(WordValue, Address)      ((((volatile UINT16 *)pEsc)[((Address)>>1)]) = (Wo
 102:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 103:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteWordIsr(WordValue, Address)   HW_EscWriteWord(WordValue, Address)               
 104:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 105:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteByte(ByteValue, Address)      ((((volatile UINT8 *)pEsc)[(Address)]) = (ByteValu
 106:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 107:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteByteIsr(ByteValue, Address)   HW_EscWriteByte(ByteValue, Address)               
 108:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 109:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 110:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief 16Bit ESC read access
 111:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 112:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local destination buffer.
 113:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 114:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 115:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 116:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 117:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 118:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 119:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 120:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the 
 121:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 122:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 123:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscRead(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 124:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
  69              	 .loc 2 124 0
  70              	 .cfi_startproc
  71              	 
  72              	 
  73 0000 80B5     	 push {r7,lr}
  74              	.LCFI4:
  75              	 .cfi_def_cfa_offset 8
  76              	 .cfi_offset 7,-8
  77              	 .cfi_offset 14,-4
  78 0002 82B0     	 sub sp,sp,#8
  79              	.LCFI5:
  80              	 .cfi_def_cfa_offset 16
  81 0004 00AF     	 add r7,sp,#0
  82              	.LCFI6:
  83              	 .cfi_def_cfa_register 7
  84 0006 7860     	 str r0,[r7,#4]
  85 0008 0B46     	 mov r3,r1
  86 000a 7B80     	 strh r3,[r7,#2]
  87 000c 1346     	 mov r3,r2
  88 000e 3B80     	 strh r3,[r7]
 125:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   memcpy(pData, &pEsc[Address], Len);
  89              	 .loc 2 125 0
  90 0010 7B88     	 ldrh r3,[r7,#2]
  91 0012 03F1A843 	 add r3,r3,#1409286144
  92 0016 03F58033 	 add r3,r3,#65536
  93 001a 3A88     	 ldrh r2,[r7]
  94 001c 7868     	 ldr r0,[r7,#4]
  95 001e 1946     	 mov r1,r3
  96 0020 FFF7FEFF 	 bl memcpy
 126:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
  97              	 .loc 2 126 0
  98 0024 0837     	 adds r7,r7,#8
  99              	.LCFI7:
 100              	 .cfi_def_cfa_offset 8
 101 0026 BD46     	 mov sp,r7
 102              	.LCFI8:
 103              	 .cfi_def_cfa_register 13
 104              	 
 105 0028 80BD     	 pop {r7,pc}
 106              	 .cfi_endproc
 107              	.LFE171:
 109 002a 00BF     	 .section .text.HW_GetALEventRegister,"ax",%progbits
 110              	 .align 2
 111              	 .thumb
 112              	 .thumb_func
 114              	HW_GetALEventRegister:
 115              	.LFB177:
 127:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 128:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 129:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Interrupt specific 16Bit ESC read access
 130:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 131:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local destination buffer.
 132:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 133:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 134:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 135:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 136:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 137:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 138:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 139:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the 
 140:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 141:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 142:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscReadIsr(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 143:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 144:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscRead(pData, Address, Len);
 145:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 146:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 147:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 148:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Reads data from the ESC and copies to slave mailbox memory.
 149:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 150:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local destination buffer.
 151:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 152:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 153:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 154:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 155:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 156:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 157:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 158:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Reads data from the ESC and copies to slave mailbox memory. If the local mailbox memory is also 
 159:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * application memory this function is equal to HW_EscRead.
 160:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 161:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 162:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscReadMbxMem(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 163:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 164:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscRead(pData, Address, Len);
 165:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 166:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 167:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 168:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief 16Bit ESC write access
 169:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 170:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local source buffer.
 171:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 172:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 173:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 174:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 175:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 176:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 177:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 178:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Writes from the EtherCAT Slave Controller. This function is used to access ESC registers and the
 179:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 180:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 181:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscWrite(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 182:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 183:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   memcpy(&pEsc[Address], pData, Len);
 184:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 185:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 186:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 187:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Interrupt specific 16Bit ESC write access
 188:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 189:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local source buffer.
 190:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 191:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 192:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 193:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 194:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 195:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 196:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 197:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Writes from the EtherCAT Slave Controller. This function is used to access ESC registers and the
 198:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 199:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 200:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscWriteIsr(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 201:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 202:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscWrite(pData, Address, Len);
 203:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 204:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 205:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 206:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Writes data from the slave mailbox memory to ESC memory.
 207:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 208:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local source mailbox buffer.
 209:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 210:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 211:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 212:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 213:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 214:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 215:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 216:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Writes data from the slave mailbox memory to ESC memory. If the local mailbox memory is also loc
 217:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * application memory this function is equal to HW_EscWrite.
 218:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 219:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 220:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscWriteMbxMem(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 221:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 222:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscWrite(pData, Address, Len);
 223:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 224:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 225:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 226:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Get the first two bytes of the AL Event register
 227:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 228:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param None
 229:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 230:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return Content of register 0x220-0x221
 231:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 232:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 233:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 234:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 235:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 236:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 237:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE UINT16 HW_GetALEventRegister(void)
 238:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 116              	 .loc 2 238 0
 117              	 .cfi_startproc
 118              	 
 119              	 
 120 0000 80B5     	 push {r7,lr}
 121              	.LCFI9:
 122              	 .cfi_def_cfa_offset 8
 123              	 .cfi_offset 7,-8
 124              	 .cfi_offset 14,-4
 125 0002 00AF     	 add r7,sp,#0
 126              	.LCFI10:
 127              	 .cfi_def_cfa_register 7
 239:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   return XMC_ECAT_GetALEventRegister();
 128              	 .loc 2 239 0
 129 0004 FFF7FEFF 	 bl XMC_ECAT_GetALEventRegister
 130 0008 0346     	 mov r3,r0
 240:C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 131              	 .loc 2 240 0
 132 000a 1846     	 mov r0,r3
 133 000c 80BD     	 pop {r7,pc}
 134              	 .cfi_endproc
 135              	.LFE177:
 137              	 .comm bEcatOutputUpdateRunning,1,1
 138              	 .comm bEcatInputUpdateRunning,1,1
 139              	 .comm bEcatFirstOutputsReceived,1,1
 140              	 .comm bWdTrigger,1,1
 141              	 .comm bDcSyncActive,1,1
 142              	 .comm EsmTimeoutCounter,2,2
 143              	 .comm bDcRunning,1,1
 144              	 .comm u16SmSync0Counter,2,2
 145              	 .comm u16SmSync0Value,2,2
 146              	 .comm bSmSyncSequenceValid,1,1
 147              	 .comm i16WaitForPllRunningTimeout,2,2
 148              	 .comm i16WaitForPllRunningCnt,2,2
 149              	 .comm Sync0WdCounter,2,2
 150              	 .comm Sync0WdValue,2,2
 151              	 .comm Sync1WdCounter,2,2
 152              	 .comm Sync1WdValue,2,2
 153              	 .comm LatchInputSync0Value,2,2
 154              	 .comm LatchInputSync0Counter,2,2
 155              	 .comm b32BitDc,1,1
 156              	 .comm bEscIntEnabled,1,1
 157              	 .comm b3BufferMode,1,1
 158              	 .comm bLocalErrorFlag,1,1
 159              	 .comm u16LocalErrorCode,2,2
 160              	 .comm bApplEsmPending,1,1
 161              	 .comm bEcatWaitForAlControlRes,1,1
 162              	 .comm nEcatStateTrans,2,2
 163              	 .comm u8EcatErrorLed,1,1
 164              	 .comm u8EcatRunLed,1,1
 165              	 .comm nPdInputSize,2,2
 166              	 .comm nPdOutputSize,2,2
 167              	 .comm nMaxSyncMan,1,1
 168              	 .comm nMaxEscAddress,2,2
 169              	 .comm nAlStatus,1,1
 170              	 .comm EcatWdValue,2,2
 171              	 .comm nEscAddrOutputData,2,2
 172              	 .comm nEscAddrInputData,2,2
 173              	 .comm u16ALEventMask,2,2
 174              	 .comm u8dummy,1,1
 175              	 .global SMActivate
 176 000e 00BF     	 .section .bss.SMActivate,"aw",%nobits
 179              	SMActivate:
 180 0000 00       	 .space 1
 181              	 .comm SyncManInfo,8,4
 182              	 .global EepromLoaded
 183              	 .section .bss.EepromLoaded,"aw",%nobits
 186              	EepromLoaded:
 187 0000 00       	 .space 1
 188              	 .section .text.ResetALEventMask,"ax",%progbits
 189              	 .align 2
 190              	 .global ResetALEventMask
 191              	 .thumb
 192              	 .thumb_func
 194              	ResetALEventMask:
 195              	.LFB179:
 196              	 .file 3 "../SSC/Src/ecatslv.c"
   1:../SSC/Src/ecatslv.c **** /*
   2:../SSC/Src/ecatslv.c **** * This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & 
   3:../SSC/Src/ecatslv.c **** * The corresponding license agreement applies. This hint shall not be removed.
   4:../SSC/Src/ecatslv.c **** */
   5:../SSC/Src/ecatslv.c **** 
   6:../SSC/Src/ecatslv.c **** /**
   7:../SSC/Src/ecatslv.c **** \addtogroup ESM EtherCAT State Machine
   8:../SSC/Src/ecatslv.c **** @{
   9:../SSC/Src/ecatslv.c **** */
  10:../SSC/Src/ecatslv.c **** 
  11:../SSC/Src/ecatslv.c **** /**
  12:../SSC/Src/ecatslv.c **** \file ecatslv.c
  13:../SSC/Src/ecatslv.c **** \author EthercatSSC@beckhoff.com
  14:../SSC/Src/ecatslv.c **** \brief Implementation
  15:../SSC/Src/ecatslv.c **** This file contains the EtherCAT State Machine.
  16:../SSC/Src/ecatslv.c **** 
  17:../SSC/Src/ecatslv.c **** \version 5.12
  18:../SSC/Src/ecatslv.c **** 
  19:../SSC/Src/ecatslv.c **** <br>Changes to version V5.11:<br>
  20:../SSC/Src/ecatslv.c **** V5.12 BOOT1: add a bootloader sample application (only the ESM and FoE is supported)<br>
  21:../SSC/Src/ecatslv.c **** V5.12 ECAT1: update SM Parameter measurement (based on the system time), enhancement for input only
  22:../SSC/Src/ecatslv.c **** V5.12 ECAT4: update Sync1 watchdog calculation (in case of subordinated cycles take one addiitonal 
  23:../SSC/Src/ecatslv.c **** V5.12 ECAT5: update Sync error counter/flag handling,check enum memory alignment depending on the p
  24:../SSC/Src/ecatslv.c **** V5.12 ECAT7: set error single flash also in case of an application error<br>
  25:../SSC/Src/ecatslv.c **** V5.12 ESM1: overwrite the current error in case of a local error with a lower target state,Do not o
  26:../SSC/Src/ecatslv.c **** V5.12 ESM2: enable the PD SM in case of a clear error transition<br>
  27:../SSC/Src/ecatslv.c **** V5.12 ESM3: set internal ESM timeout to -10% of the configured value (to return an errorcode before
  28:../SSC/Src/ecatslv.c **** V5.12 ESM4: enable the AL Event mask in case of pending ESM transition<br>
  29:../SSC/Src/ecatslv.c **** V5.12 TEST2: add pending ESM test,trigger complete ESM transition from ecat main<br>
  30:../SSC/Src/ecatslv.c **** <br>Changes to version V5.10:<br>
  31:../SSC/Src/ecatslv.c **** V5.11 COE3: change 0x10F3.2 (Sync Error limit) from UINT32 to UINT16 (according to the ETG.1020)<br
  32:../SSC/Src/ecatslv.c **** V5.11 DIAG4: change parameter handling in DIAG_CreateNewMessage()<br>
  33:../SSC/Src/ecatslv.c **** V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
  34:../SSC/Src/ecatslv.c **** V5.11 ECAT4: enhance SM/Sync monitoring for input/output only slaves<br>
  35:../SSC/Src/ecatslv.c **** V5.11 ECAT5: "Add missing ""bEscIntEnabled"" initialization if ""AL_EVENT_ENBALED"" is 0"""<br>
  36:../SSC/Src/ecatslv.c **** V5.11 ECAT7: add missing big endian swapping<br>
  37:../SSC/Src/ecatslv.c **** V5.11 ESC1: update max address calculation<br>
  38:../SSC/Src/ecatslv.c **** V5.11 ESM1: update calculation of subordinated cycles<br>
  39:../SSC/Src/ecatslv.c **** V5.11 ESM2: DC_SUPPORTED, Sync0 is not supported and Sync0 is generated according register values t
  40:../SSC/Src/ecatslv.c **** V5.11 ESM3: update checking of the user configured sync type<br>
  41:../SSC/Src/ecatslv.c **** V5.11 ESM4: prevent to go from ErrSafeOP to OP without re enabling Sync0/1<br>
  42:../SSC/Src/ecatslv.c **** V5.11 ESM5: DPRAM range was double checked<br>
  43:../SSC/Src/ecatslv.c **** V5.11 ESM6: in the SO transition wait by default until the master has send process data<br>
  44:../SSC/Src/ecatslv.c **** V5.11 HW1: "move hardware independent functions ""HW_DisableSyncManChannel()"", ""HW_EnableSyncManC
  45:../SSC/Src/ecatslv.c **** V5.11 HW2: check during ESM handling if the SM address and length is aligned according the ESC acce
  46:../SSC/Src/ecatslv.c **** V5.11 TEST9: "add behaviour 0x2020.7 (SDO requests on 0x3006.0 are set to pending until an FoE read
  47:../SSC/Src/ecatslv.c **** <br>Changes to version V5.01:<br>
  48:../SSC/Src/ecatslv.c **** V5.10 COE1: Define one entry description for all 0x1C3x objects and change data type of SI11,12,13 
  49:../SSC/Src/ecatslv.c **** V5.10 DIAG1: Define diagmessage textIDs<br>
  50:../SSC/Src/ecatslv.c **** V5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
  51:../SSC/Src/ecatslv.c ****               Compare DC UINT configuration (by ESC Config data) vs. DC activation register setting
  52:../SSC/Src/ecatslv.c ****               Update 0x1C3x entries<br>
  53:../SSC/Src/ecatslv.c **** V5.10 ESC2: Check if defined SM settings do not exceed the available DPRAM range (in error case AL 
  54:../SSC/Src/ecatslv.c **** V5.10 ESC3: Handle DC cControl register values in case of 32Bit ESC access (a Sync activation mask 
  55:../SSC/Src/ecatslv.c **** V5.10 ESC4: Mask lower 4 Bit of AL status to get Run led value<br>
  56:../SSC/Src/ecatslv.c ****             Invalid RunLed code was calculated if ESC set ECAT Run Led<br>
  57:../SSC/Src/ecatslv.c **** V5.10 ESC5: Add missing swapping<br>
  58:../SSC/Src/ecatslv.c **** V5.10 ESM2: Update "bApplEsmPending" flag during a transition to a lower state<br>
  59:../SSC/Src/ecatslv.c **** V5.10 ESM3: Add "volatile" directive for ESM dummy variables<br>
  60:../SSC/Src/ecatslv.c **** V5.10 HW5: Block ESC interrupts during Timer ISR<br>
  61:../SSC/Src/ecatslv.c **** V5.10 TEST9: Add option to prevent SM3 unlock during PS<br>
  62:../SSC/Src/ecatslv.c **** <br>Changes to version V5.0:<br>
  63:../SSC/Src/ecatslv.c **** V5.01 APPL3: Include library demo application<br>
  64:../SSC/Src/ecatslv.c **** V5.01 ESC2: Add missed value swapping<br>
  65:../SSC/Src/ecatslv.c **** V5.01 ESM1: Don't overwrite the error reason in case of an failed PS transition<br>
  66:../SSC/Src/ecatslv.c **** V5.01 ESM2: Don't check the "appl trigger" flag in case on an regular transition to a lower state (
  67:../SSC/Src/ecatslv.c **** V5.01 ESM3: Call Error acknowledge indication only if error was acknowledged by the master<br>
  68:../SSC/Src/ecatslv.c **** V5.01 HW3: Update blink code of an SM watchdog error<br>
  69:../SSC/Src/ecatslv.c **** <br>Changes to version V4.42:<br>
  70:../SSC/Src/ecatslv.c **** V5.0 ECAT1: Support Explicit Device ID.<br>
  71:../SSC/Src/ecatslv.c **** V5.0 ECAT2: Application specific functions are moved to application files.<br>
  72:../SSC/Src/ecatslv.c **** V5.0 ECAT3: Global dummy variables used for dummy ESC operations.<br>
  73:../SSC/Src/ecatslv.c **** V5.0 ESC1: ESC 32Bit Access added.<br>
  74:../SSC/Src/ecatslv.c **** V5.0 ESC2: Support ESC EtherCAT LED Indication.<br>
  75:../SSC/Src/ecatslv.c **** V5.0 ESC3: Support EEPROM Emulation.<br>
  76:../SSC/Src/ecatslv.c **** V5.0 ESM1: Update "LocalErrorFlag" handling.<br>
  77:../SSC/Src/ecatslv.c **** V5.0 ESM2: Update Error Acknowledge by ALControl INIT (without error acknowledge)<br>
  78:../SSC/Src/ecatslv.c **** V5.0 ESM3: Handle pending ESM transition<br>
  79:../SSC/Src/ecatslv.c **** V5.0 ESM4: ECAT_StateChange() will only be called form application. In case of an communication err
  80:../SSC/Src/ecatslv.c **** V5.0 MBX1: Support configuration without mailbox protocol support.<br>
  81:../SSC/Src/ecatslv.c **** V5.0 TEST1: Add test application. See Application Note ET9300 for more details.<br>
  82:../SSC/Src/ecatslv.c **** <br>Changes to version V4.40:<br>
  83:../SSC/Src/ecatslv.c **** V4.42 ESM1: Reset local error flag if master set the acknowledge bit (0x120.4)<br>
  84:../SSC/Src/ecatslv.c **** <br>Changes to version V4.30:<br>
  85:../SSC/Src/ecatslv.c **** V4.40 ESM5: Enable output SyncManager if local error acknowledged<br>
  86:../SSC/Src/ecatslv.c **** V4.40 HW0: Use common hardware access functions<br>
  87:../SSC/Src/ecatslv.c **** V4.40 PDO3: Add support if only input process data is used<br>
  88:../SSC/Src/ecatslv.c **** V4.40 ECAT4: Add read SM activation register to acknowledge SM Change event<br>
  89:../SSC/Src/ecatslv.c **** V4.40 PDO2: Check if max process data size was exceed<br>
  90:../SSC/Src/ecatslv.c **** V4.40 DIAG1: add diagnosis message support<br>
  91:../SSC/Src/ecatslv.c **** V4.40 ESM4: Change Check WD setup; add define OP_PD_REQUIRED (defines if process data required in s
  92:../SSC/Src/ecatslv.c **** V4.40 WD1: change WD behaviour depending if process data required in OP state<br>
  93:../SSC/Src/ecatslv.c **** V4.40 MBX4: Change processing order of mailbox SyncManager flags<br>
  94:../SSC/Src/ecatslv.c **** V4.40 ECAT1: Merge content of HW_Main (spihw.c /mcihw.c) to ECAT_Main<br>
  95:../SSC/Src/ecatslv.c **** V4.40 ECAT2: Added CheckIfLocalError() to check local flags and set ALStatus /Al Status code if req
  96:../SSC/Src/ecatslv.c **** V4.40 ESM2: Add AL_ControlRes() to complete pending state requests. Change SafeOP to OP state respo
  97:../SSC/Src/ecatslv.c **** V4.40 ESM1: Prevent double call of StopOutputHandler()<br>
  98:../SSC/Src/ecatslv.c **** V4.40 BOOT1: Enable Mailbox SyncManger on state change to BOOT state (to enable FoE)<br>
  99:../SSC/Src/ecatslv.c **** V4.40 ESM3: Change State machine behaviour according to ETG.1000 V1.0.2 (state change #26)<br>
 100:../SSC/Src/ecatslv.c **** V4.40 LED1: Set error blink code<br>
 101:../SSC/Src/ecatslv.c **** V4.40 TIMER1: Added DC_CheckWatchdog() triggered from ECAT_CheckTimer(). Change local Sync0 watchdo
 102:../SSC/Src/ecatslv.c **** V4.40 WD1: Change check process data watchdog settings<br>
 103:../SSC/Src/ecatslv.c **** <br>Changes to version V4.20:<br>
 104:../SSC/Src/ecatslv.c **** V4.30 OBJ 3: initialize the object dictionary in state change INIT->PREOP; clear object dictionary 
 105:../SSC/Src/ecatslv.c **** V4.30 SYNC: add 0x1C32:10; 0x1C33:10 (Sync0 cycle), change synchronisation control functionality<br
 106:../SSC/Src/ecatslv.c **** V4.30 CiA402: add CiA402_Init() call in state change from PREOP to SAFEOP if DC synchronisation is 
 107:../SSC/Src/ecatslv.c ****                    else the Init function is called when bus cycle time is calculated [CalcSMCycleT
 108:../SSC/Src/ecatslv.c ****                    trigger error handling if the EtherCAT state machine gets a transition from OP t
 109:../SSC/Src/ecatslv.c **** V4.20 ECAT 1: add LEGACY_MODE behaviour in ECAT_CheckWatchdog()<br>
 110:../SSC/Src/ecatslv.c **** V4.20 DC 1: Add DC pending state machine handling and Dc watchdog functionality<br>
 111:../SSC/Src/ecatslv.c **** V4.20 ESM 2: Add State transition from BOOT to INIT<br>
 112:../SSC/Src/ecatslv.c **** V4.20 ESM 1: Non LEGACY_MODE State change handling<br>
 113:../SSC/Src/ecatslv.c **** V4.11 Renamed the function parameter "code" of Function "SendSmFailedEmergency() to avoid<br>
 114:../SSC/Src/ecatslv.c **** problems with some compilers"<br>
 115:../SSC/Src/ecatslv.c **** V4.11 ECAT 1: Fixed a possible problem with state change Init -> SafeOP. The output syncmanager<br>
 116:../SSC/Src/ecatslv.c **** was enabled by the state change-flag and not by the actual state<br>
 117:../SSC/Src/ecatslv.c **** V4.11 LED 1: Clear the error LED during error acknowledgement<br>
 118:../SSC/Src/ecatslv.c **** V4.11 ESC 1: fixed size of MBXHEADER in the TFOEMBX struct <br>
 119:../SSC/Src/ecatslv.c **** <br>Changes to version V4.08:<br>
 120:../SSC/Src/ecatslv.c **** V4.10 ECAT 1: clear bEcatOutputsReceived in startMailboxhandler()<br>
 121:../SSC/Src/ecatslv.c **** V4.10 ECAT 2: clear bEcatOutputsReceived in stopMailboxhandler()<br>
 122:../SSC/Src/ecatslv.c **** V4.10 ECAT 3: when switching from INIT to BOOT the SM settings shall be checked<br>
 123:../SSC/Src/ecatslv.c **** V4.10 ECAT 4: APPL_StartInputHandler shall always be called and bEcatInputUpdateRunning shall alway
 124:../SSC/Src/ecatslv.c ****               in StartInputHandler independent of the input size<br>
 125:../SSC/Src/ecatslv.c **** V4.10 ECAT 5: AL_ControlInd: the error acknowledge behaviour was changed<br>
 126:../SSC/Src/ecatslv.c ****               according to the protocol enhancements and the conformance test<br>
 127:../SSC/Src/ecatslv.c **** V4.10 ECAT 6: AL_ControlInd: if a state transitions failed the corresponding stop function is<br>
 128:../SSC/Src/ecatslv.c ****               called to get a consistent set of variables<br>
 129:../SSC/Src/ecatslv.c **** V4.10 ECAT 7: the local application requested to leave the state OP so we have to disable the SM2<b
 130:../SSC/Src/ecatslv.c ****                    and make the state change from OP to SAFEOP by calling StopOutputHandler<br>
 131:../SSC/Src/ecatslv.c **** V4.10 ECAT 8: the AL Status Code has to be reset if the error was acknowledged by the master<br>
 132:../SSC/Src/ecatslv.c **** V4.10 ECAT 9: ECAT_StateChange: when waiting for a State Change response from the application the<b
 133:../SSC/Src/ecatslv.c ****               AL Status shall only be written if the final state was reached<br>
 134:../SSC/Src/ecatslv.c **** <br>Changes to version V4.07:<br>
 135:../SSC/Src/ecatslv.c **** V4.08 ECAT 1: The watchdog value was not rounded up<br>
 136:../SSC/Src/ecatslv.c **** V4.08 ECAT 2: The value of u16WdValue was not set 0 if the register 0x420 is 0<br>
 137:../SSC/Src/ecatslv.c **** V4.08 ECAT 3: The AlStatusCode is changed as parameter of the function AL_ControlInd<br>
 138:../SSC/Src/ecatslv.c **** V4.08 ECAT 4: In a state transition OP2PREOP, SAFEOP2INIT or OP2INIT is requested,<br>
 139:../SSC/Src/ecatslv.c ****               this was not working correctly if one of the application functions<br>
 140:../SSC/Src/ecatslv.c ****               APPL_StopInputHandler or APPL_StopOutputHandler were returning NOERROR_INWORK<br>
 141:../SSC/Src/ecatslv.c ****               (because only the first state transition was made in that case)<br>
 142:../SSC/Src/ecatslv.c **** V4.08 AOE 1:    AoE was added<br>
 143:../SSC/Src/ecatslv.c **** <br>Changes to version V4.06:<br>
 144:../SSC/Src/ecatslv.c **** V4.07 ECAT 1: The sources for SPI and MCI were merged (in ecat_def.h<br>
 145:../SSC/Src/ecatslv.c ****                    set the switch MCI_HW to 1 when using the MCI,<br>
 146:../SSC/Src/ecatslv.c ****                    set the switch SPI_HW to 1 when using the SPI<br>
 147:../SSC/Src/ecatslv.c **** <br>Changes to version V4.00:<br>
 148:../SSC/Src/ecatslv.c **** V4.01 ECAT 1: The Output sync Manager was not disabled when the state OP was left<br>
 149:../SSC/Src/ecatslv.c ****               by a local request (watchdog or io error)<br>
 150:../SSC/Src/ecatslv.c **** V4.01 ECAT 2: APPL_StopOutputHandler returns an UINT16<br>
 151:../SSC/Src/ecatslv.c **** V4.01 ECAT 3: TwinCAT compatibility mode: The state transition to OP is allowed when the<br>
 152:../SSC/Src/ecatslv.c ****                     WD-Trigger-Bit of the SM2-Control-Byte (0x814.6) is FALSE, in that case the<br>
 153:../SSC/Src/ecatslv.c ****                     watchdog will not be started before the outputs were received the first time<br
 154:../SSC/Src/ecatslv.c **** V4.01 ECAT 4: "else" was too much<br>
 155:../SSC/Src/ecatslv.c **** <br>Changes to version V3.20:<br>
 156:../SSC/Src/ecatslv.c **** V4.00 ECAT 1: The handling of the Sync Manager Parameter was included according to<br>
 157:../SSC/Src/ecatslv.c ****               the EtherCAT Guidelines and Protocol Enhancements Specification<br>
 158:../SSC/Src/ecatslv.c **** V4.00 ECAT 2: The output sync manager is initialized during the state transition<br>
 159:../SSC/Src/ecatslv.c ****               from PREOP to SAFEOP that the master can check if the slave could update<br>
 160:../SSC/Src/ecatslv.c ****               inputs and outputs before switching the slave to OP<br>
 161:../SSC/Src/ecatslv.c ****               behaviour according to the EtherCAT Guidelines and Protocol Enhancements Specificatio
 162:../SSC/Src/ecatslv.c **** V4.00 ECAT 3: The watchdog will be enabled in SAFE-OP that it can be checked if the last SM event<b
 163:../SSC/Src/ecatslv.c ****               was received during the watchdog time before switching to OP<br>
 164:../SSC/Src/ecatslv.c **** V4.00 ECAT 4: The function CheckSmChannelParameters is included in the function<br>
 165:../SSC/Src/ecatslv.c ****               CheckSmSettings to get a better overview<br>
 166:../SSC/Src/ecatslv.c **** V4.00 ECAT 5: In synchronous mode the slave should support 1- and 3-buffer mode, 3-buffer mode<br>
 167:../SSC/Src/ecatslv.c ****               should be the standard setting, because the controlling if the process data was updat
 168:../SSC/Src/ecatslv.c ****               should be done with the TxPDO Toggle, but the 1-buffer mode should be setable too,<br
 169:../SSC/Src/ecatslv.c ****               that the master could easily check if all slaves are synchronous by checking the<br>
 170:../SSC/Src/ecatslv.c ****               the working counter (if the outputs were not read or the inputs were not written<br>
 171:../SSC/Src/ecatslv.c ****               the ESC of the slave would not increment the working counter with expected value<br>
 172:../SSC/Src/ecatslv.c ****               if the 1-buffer mode is running)<br>
 173:../SSC/Src/ecatslv.c **** V4.00 ECAT 6: The function ECAT_StateChange was added, which the application should call if a local
 174:../SSC/Src/ecatslv.c ****                    is detected (with the parameters alStatus = STATE_SAFEOP, alStatusCode = error c
 175:../SSC/Src/ecatslv.c ****                    or gone (with the parameters alStatus = STATE_OP, alStatusCode = 0)<br>
 176:../SSC/Src/ecatslv.c ****                    or if one of the functions APPL_StartMailboxHandler, APPL_StopMailboxHandler, AP
 177:../SSC/Src/ecatslv.c ****                    APPL_StopInputHandler, APPL_StartOutputHandler, APPL_StopOutputHandler has retur
 178:../SSC/Src/ecatslv.c ****                    to acknowledge the last state transition (with the parameters alStatus = new AL-
 179:../SSC/Src/ecatslv.c ****                    new AL-Status-Code)<br>
 180:../SSC/Src/ecatslv.c **** V4.00 ECAT 7: The return values for the AL-StatusCode were changed to UINT16
 181:../SSC/Src/ecatslv.c **** */
 182:../SSC/Src/ecatslv.c **** 
 183:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 184:../SSC/Src/ecatslv.c **** ------
 185:../SSC/Src/ecatslv.c **** ------    Includes
 186:../SSC/Src/ecatslv.c **** ------
 187:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 188:../SSC/Src/ecatslv.c **** 
 189:../SSC/Src/ecatslv.c **** #define    _ECATSLV_    1
 190:../SSC/Src/ecatslv.c **** #include "ecatslv.h"
 191:../SSC/Src/ecatslv.c **** #undef    _ECATSLV_
 192:../SSC/Src/ecatslv.c **** /*remove definition of _ECATSLV_ (#ifdef is used in ecatslv.h)*/
 193:../SSC/Src/ecatslv.c **** 
 194:../SSC/Src/ecatslv.c **** #include "ecatappl.h"
 195:../SSC/Src/ecatslv.c **** 
 196:../SSC/Src/ecatslv.c **** 
 197:../SSC/Src/ecatslv.c **** 
 198:../SSC/Src/ecatslv.c **** 
 199:../SSC/Src/ecatslv.c **** 
 200:../SSC/Src/ecatslv.c **** #include "mailbox.h"
 201:../SSC/Src/ecatslv.c **** 
 202:../SSC/Src/ecatslv.c **** #include "ecatcoe.h"
 203:../SSC/Src/ecatslv.c **** #include "objdef.h"
 204:../SSC/Src/ecatslv.c **** 
 205:../SSC/Src/ecatslv.c **** 
 206:../SSC/Src/ecatslv.c **** 
 207:../SSC/Src/ecatslv.c **** #include "XMC_ESC.h"
 208:../SSC/Src/ecatslv.c **** 
 209:../SSC/Src/ecatslv.c **** /*--------------------------------------------------------------------------------------
 210:../SSC/Src/ecatslv.c **** ------
 211:../SSC/Src/ecatslv.c **** ------    local Types and Defines
 212:../SSC/Src/ecatslv.c **** ------
 213:../SSC/Src/ecatslv.c **** --------------------------------------------------------------------------------------*/
 214:../SSC/Src/ecatslv.c **** 
 215:../SSC/Src/ecatslv.c **** 
 216:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 217:../SSC/Src/ecatslv.c **** ------
 218:../SSC/Src/ecatslv.c **** ------    local variables and constants
 219:../SSC/Src/ecatslv.c **** ------
 220:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 221:../SSC/Src/ecatslv.c **** UINT16    u16ALEventMask;                      // Value which will be written to the 0x204 register
 222:../SSC/Src/ecatslv.c **** 
 223:../SSC/Src/ecatslv.c **** /*Dummy variable to trigger read or writes events in the ESC*/
 224:../SSC/Src/ecatslv.c ****     VARVOLATILE UINT8 u8dummy;
 225:../SSC/Src/ecatslv.c **** 
 226:../SSC/Src/ecatslv.c **** 
 227:../SSC/Src/ecatslv.c ****         VARVOLATILE UINT8 SMActivate = 0;
 228:../SSC/Src/ecatslv.c **** 
 229:../SSC/Src/ecatslv.c **** TSYNCMAN		SyncManInfo;
 230:../SSC/Src/ecatslv.c **** 
 231:../SSC/Src/ecatslv.c **** //indicates if the EEPORM was loaded correct
 232:../SSC/Src/ecatslv.c **** BOOL EepromLoaded = FALSE;
 233:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 234:../SSC/Src/ecatslv.c **** ------
 235:../SSC/Src/ecatslv.c **** ------    local functions
 236:../SSC/Src/ecatslv.c **** ------
 237:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 238:../SSC/Src/ecatslv.c **** 
 239:../SSC/Src/ecatslv.c **** void ResetALEventMask(UINT16 intMask);
 240:../SSC/Src/ecatslv.c **** 
 241:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 242:../SSC/Src/ecatslv.c **** /**
 243:../SSC/Src/ecatslv.c ****  \param    intMask        interrupt mask (disabled interrupt shall be zero)
 244:../SSC/Src/ecatslv.c **** 
 245:../SSC/Src/ecatslv.c ****  \brief    This function makes an logical and with the AL Event Mask register (0x204)
 246:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 247:../SSC/Src/ecatslv.c **** void ResetALEventMask(UINT16 intMask)
 248:../SSC/Src/ecatslv.c **** {
 197              	 .loc 3 248 0
 198              	 .cfi_startproc
 199              	 
 200              	 
 201 0000 80B5     	 push {r7,lr}
 202              	.LCFI11:
 203              	 .cfi_def_cfa_offset 8
 204              	 .cfi_offset 7,-8
 205              	 .cfi_offset 14,-4
 206 0002 84B0     	 sub sp,sp,#16
 207              	.LCFI12:
 208              	 .cfi_def_cfa_offset 24
 209 0004 00AF     	 add r7,sp,#0
 210              	.LCFI13:
 211              	 .cfi_def_cfa_register 7
 212 0006 0346     	 mov r3,r0
 213 0008 FB80     	 strh r3,[r7,#6]
 249:../SSC/Src/ecatslv.c ****     UINT16 mask;
 250:../SSC/Src/ecatslv.c ****     HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
 214              	 .loc 3 250 0
 215 000a 084B     	 ldr r3,.L9
 216 000c 1B88     	 ldrh r3,[r3]
 217 000e FB81     	 strh r3,[r7,#14]
 251:../SSC/Src/ecatslv.c ****     
 252:../SSC/Src/ecatslv.c ****     mask &= intMask;
 218              	 .loc 3 252 0
 219 0010 FA89     	 ldrh r2,[r7,#14]
 220 0012 FB88     	 ldrh r3,[r7,#6]
 221 0014 1340     	 ands r3,r3,r2
 222 0016 FB81     	 strh r3,[r7,#14]
 253:../SSC/Src/ecatslv.c **** 
 254:../SSC/Src/ecatslv.c **** 
 255:../SSC/Src/ecatslv.c ****     DISABLE_ESC_INT();
 223              	 .loc 3 255 0
 224 0018 FFF7FEFF 	 bl DISABLE_ESC_INT
 256:../SSC/Src/ecatslv.c **** 
 257:../SSC/Src/ecatslv.c **** 
 258:../SSC/Src/ecatslv.c ****     HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
 225              	 .loc 3 258 0
 226 001c 034A     	 ldr r2,.L9
 227 001e FB89     	 ldrh r3,[r7,#14]
 228 0020 1380     	 strh r3,[r2]
 259:../SSC/Src/ecatslv.c ****     ENABLE_ESC_INT();
 229              	 .loc 3 259 0
 230 0022 FFF7FEFF 	 bl ENABLE_ESC_INT
 260:../SSC/Src/ecatslv.c **** }
 231              	 .loc 3 260 0
 232 0026 1037     	 adds r7,r7,#16
 233              	.LCFI14:
 234              	 .cfi_def_cfa_offset 8
 235 0028 BD46     	 mov sp,r7
 236              	.LCFI15:
 237              	 .cfi_def_cfa_register 13
 238              	 
 239 002a 80BD     	 pop {r7,pc}
 240              	.L10:
 241              	 .align 2
 242              	.L9:
 243 002c 04020154 	 .word 1409352196
 244              	 .cfi_endproc
 245              	.LFE179:
 247              	 .section .text.SetALEventMask,"ax",%progbits
 248              	 .align 2
 249              	 .global SetALEventMask
 250              	 .thumb
 251              	 .thumb_func
 253              	SetALEventMask:
 254              	.LFB180:
 261:../SSC/Src/ecatslv.c **** 
 262:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 263:../SSC/Src/ecatslv.c **** /**
 264:../SSC/Src/ecatslv.c ****  \param    intMask        interrupt mask (enabled interrupt shall be one)
 265:../SSC/Src/ecatslv.c **** 
 266:../SSC/Src/ecatslv.c ****   \brief    This function makes an logical or with the AL Event Mask register (0x204)
 267:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 268:../SSC/Src/ecatslv.c **** void SetALEventMask(UINT16 intMask)
 269:../SSC/Src/ecatslv.c **** {
 255              	 .loc 3 269 0
 256              	 .cfi_startproc
 257              	 
 258              	 
 259 0000 80B5     	 push {r7,lr}
 260              	.LCFI16:
 261              	 .cfi_def_cfa_offset 8
 262              	 .cfi_offset 7,-8
 263              	 .cfi_offset 14,-4
 264 0002 84B0     	 sub sp,sp,#16
 265              	.LCFI17:
 266              	 .cfi_def_cfa_offset 24
 267 0004 00AF     	 add r7,sp,#0
 268              	.LCFI18:
 269              	 .cfi_def_cfa_register 7
 270 0006 0346     	 mov r3,r0
 271 0008 FB80     	 strh r3,[r7,#6]
 270:../SSC/Src/ecatslv.c ****     UINT16 mask;
 271:../SSC/Src/ecatslv.c ****     HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
 272              	 .loc 3 271 0
 273 000a 084B     	 ldr r3,.L12
 274 000c 1B88     	 ldrh r3,[r3]
 275 000e FB81     	 strh r3,[r7,#14]
 272:../SSC/Src/ecatslv.c ****     
 273:../SSC/Src/ecatslv.c **** 
 274:../SSC/Src/ecatslv.c ****     mask |= intMask;
 276              	 .loc 3 274 0
 277 0010 FA89     	 ldrh r2,[r7,#14]
 278 0012 FB88     	 ldrh r3,[r7,#6]
 279 0014 1343     	 orrs r3,r3,r2
 280 0016 FB81     	 strh r3,[r7,#14]
 275:../SSC/Src/ecatslv.c **** 
 276:../SSC/Src/ecatslv.c ****     DISABLE_ESC_INT();
 281              	 .loc 3 276 0
 282 0018 FFF7FEFF 	 bl DISABLE_ESC_INT
 277:../SSC/Src/ecatslv.c **** 
 278:../SSC/Src/ecatslv.c **** 
 279:../SSC/Src/ecatslv.c ****     HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
 283              	 .loc 3 279 0
 284 001c 034A     	 ldr r2,.L12
 285 001e FB89     	 ldrh r3,[r7,#14]
 286 0020 1380     	 strh r3,[r2]
 280:../SSC/Src/ecatslv.c ****     ENABLE_ESC_INT();
 287              	 .loc 3 280 0
 288 0022 FFF7FEFF 	 bl ENABLE_ESC_INT
 281:../SSC/Src/ecatslv.c **** }
 289              	 .loc 3 281 0
 290 0026 1037     	 adds r7,r7,#16
 291              	.LCFI19:
 292              	 .cfi_def_cfa_offset 8
 293 0028 BD46     	 mov sp,r7
 294              	.LCFI20:
 295              	 .cfi_def_cfa_register 13
 296              	 
 297 002a 80BD     	 pop {r7,pc}
 298              	.L13:
 299              	 .align 2
 300              	.L12:
 301 002c 04020154 	 .word 1409352196
 302              	 .cfi_endproc
 303              	.LFE180:
 305              	 .section .text.UpdateEEPROMLoadedState,"ax",%progbits
 306              	 .align 2
 307              	 .global UpdateEEPROMLoadedState
 308              	 .thumb
 309              	 .thumb_func
 311              	UpdateEEPROMLoadedState:
 312              	.LFB181:
 282:../SSC/Src/ecatslv.c **** 
 283:../SSC/Src/ecatslv.c **** 
 284:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 285:../SSC/Src/ecatslv.c **** /**
 286:../SSC/Src/ecatslv.c **** 
 287:../SSC/Src/ecatslv.c **** \brief    This function reads the EEPROM loaded state
 288:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 289:../SSC/Src/ecatslv.c **** void UpdateEEPROMLoadedState(void)
 290:../SSC/Src/ecatslv.c **** {
 313              	 .loc 3 290 0
 314              	 .cfi_startproc
 315              	 
 316              	 
 317              	 
 318 0000 80B4     	 push {r7}
 319              	.LCFI21:
 320              	 .cfi_def_cfa_offset 4
 321              	 .cfi_offset 7,-4
 322 0002 83B0     	 sub sp,sp,#12
 323              	.LCFI22:
 324              	 .cfi_def_cfa_offset 16
 325 0004 00AF     	 add r7,sp,#0
 326              	.LCFI23:
 327              	 .cfi_def_cfa_register 7
 291:../SSC/Src/ecatslv.c ****     UINT16 TmpVar = 0;
 328              	 .loc 3 291 0
 329 0006 0023     	 movs r3,#0
 330 0008 FB80     	 strh r3,[r7,#6]
 292:../SSC/Src/ecatslv.c ****     //read EEPROM loaded information
 293:../SSC/Src/ecatslv.c ****     HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
 331              	 .loc 3 293 0
 332 000a 0C4B     	 ldr r3,.L18
 333 000c 1B88     	 ldrh r3,[r3]
 334 000e FB80     	 strh r3,[r7,#6]
 294:../SSC/Src/ecatslv.c ****     TmpVar = SWAPWORD(TmpVar);
 295:../SSC/Src/ecatslv.c **** 
 296:../SSC/Src/ecatslv.c **** 
 297:../SSC/Src/ecatslv.c ****     if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
 335              	 .loc 3 297 0
 336 0010 FB88     	 ldrh r3,[r7,#6]
 337 0012 03F40063 	 and r3,r3,#2048
 338 0016 002B     	 cmp r3,#0
 339 0018 04DC     	 bgt .L15
 298:../SSC/Src/ecatslv.c ****         || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
 340              	 .loc 3 298 0
 341 001a FB88     	 ldrh r3,[r7,#6]
 342 001c 03F48053 	 and r3,r3,#4096
 343 0020 002B     	 cmp r3,#0
 344 0022 03DD     	 ble .L16
 345              	.L15:
 299:../SSC/Src/ecatslv.c ****     {
 300:../SSC/Src/ecatslv.c ****         EepromLoaded = FALSE;
 346              	 .loc 3 300 0
 347 0024 064B     	 ldr r3,.L18+4
 348 0026 0022     	 movs r2,#0
 349 0028 1A70     	 strb r2,[r3]
 350 002a 02E0     	 b .L14
 351              	.L16:
 301:../SSC/Src/ecatslv.c ****     }
 302:../SSC/Src/ecatslv.c ****     else
 303:../SSC/Src/ecatslv.c ****     {
 304:../SSC/Src/ecatslv.c ****         EepromLoaded = TRUE;
 352              	 .loc 3 304 0
 353 002c 044B     	 ldr r3,.L18+4
 354 002e 0122     	 movs r2,#1
 355 0030 1A70     	 strb r2,[r3]
 356              	.L14:
 305:../SSC/Src/ecatslv.c ****     }
 306:../SSC/Src/ecatslv.c **** }
 357              	 .loc 3 306 0
 358 0032 0C37     	 adds r7,r7,#12
 359              	.LCFI24:
 360              	 .cfi_def_cfa_offset 4
 361 0034 BD46     	 mov sp,r7
 362              	.LCFI25:
 363              	 .cfi_def_cfa_register 13
 364              	 
 365 0036 5DF8047B 	 ldr r7,[sp],#4
 366              	.LCFI26:
 367              	 .cfi_restore 7
 368              	 .cfi_def_cfa_offset 0
 369 003a 7047     	 bx lr
 370              	.L19:
 371              	 .align 2
 372              	.L18:
 373 003c 02050154 	 .word 1409352962
 374 0040 00000000 	 .word EepromLoaded
 375              	 .cfi_endproc
 376              	.LFE181:
 378              	 .section .text.GetSyncMan,"ax",%progbits
 379              	 .align 2
 380              	 .global GetSyncMan
 381              	 .thumb
 382              	 .thumb_func
 384              	GetSyncMan:
 385              	.LFB182:
 307:../SSC/Src/ecatslv.c **** 
 308:../SSC/Src/ecatslv.c **** 
 309:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 310:../SSC/Src/ecatslv.c **** ------
 311:../SSC/Src/ecatslv.c **** ------    functions
 312:../SSC/Src/ecatslv.c **** ------
 313:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 314:../SSC/Src/ecatslv.c **** 
 315:../SSC/Src/ecatslv.c **** 
 316:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 317:../SSC/Src/ecatslv.c **** /**
 318:../SSC/Src/ecatslv.c ****  \param     channel        Sync Manager channel
 319:../SSC/Src/ecatslv.c **** 
 320:../SSC/Src/ecatslv.c ****  \return     pPdSyncMan        Pointer to the settings of requested SYNC Manager channel
 321:../SSC/Src/ecatslv.c **** 
 322:../SSC/Src/ecatslv.c ****  \brief    This function is called to read the SYNC Manager channel descriptions of the
 323:../SSC/Src/ecatslv.c ****              process data SYNC Managers.
 324:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 325:../SSC/Src/ecatslv.c **** 
 326:../SSC/Src/ecatslv.c **** TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
 327:../SSC/Src/ecatslv.c **** {
 386              	 .loc 3 327 0
 387              	 .cfi_startproc
 388              	 
 389              	 
 390 0000 80B5     	 push {r7,lr}
 391              	.LCFI27:
 392              	 .cfi_def_cfa_offset 8
 393              	 .cfi_offset 7,-8
 394              	 .cfi_offset 14,-4
 395 0002 82B0     	 sub sp,sp,#8
 396              	.LCFI28:
 397              	 .cfi_def_cfa_offset 16
 398 0004 00AF     	 add r7,sp,#0
 399              	.LCFI29:
 400              	 .cfi_def_cfa_register 7
 401 0006 0346     	 mov r3,r0
 402 0008 FB71     	 strb r3,[r7,#7]
 328:../SSC/Src/ecatslv.c ****     HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), S
 403              	 .loc 3 328 0
 404 000a FB79     	 ldrb r3,[r7,#7]
 405 000c 03F58073 	 add r3,r3,#256
 406 0010 9BB2     	 uxth r3,r3
 407 0012 DB00     	 lsls r3,r3,#3
 408 0014 9BB2     	 uxth r3,r3
 409 0016 0548     	 ldr r0,.L22
 410 0018 1946     	 mov r1,r3
 411 001a 0822     	 movs r2,#8
 412 001c FFF7FEFF 	 bl HW_EscRead
 329:../SSC/Src/ecatslv.c **** 
 330:../SSC/Src/ecatslv.c **** 
 331:../SSC/Src/ecatslv.c **** 
 332:../SSC/Src/ecatslv.c ****     return &SyncManInfo;
 413              	 .loc 3 332 0
 414 0020 024B     	 ldr r3,.L22
 333:../SSC/Src/ecatslv.c **** }
 415              	 .loc 3 333 0
 416 0022 1846     	 mov r0,r3
 417 0024 0837     	 adds r7,r7,#8
 418              	.LCFI30:
 419              	 .cfi_def_cfa_offset 8
 420 0026 BD46     	 mov sp,r7
 421              	.LCFI31:
 422              	 .cfi_def_cfa_register 13
 423              	 
 424 0028 80BD     	 pop {r7,pc}
 425              	.L23:
 426 002a 00BF     	 .align 2
 427              	.L22:
 428 002c 00000000 	 .word SyncManInfo
 429              	 .cfi_endproc
 430              	.LFE182:
 432              	 .section .text.DisableSyncManChannel,"ax",%progbits
 433              	 .align 2
 434              	 .global DisableSyncManChannel
 435              	 .thumb
 436              	 .thumb_func
 438              	DisableSyncManChannel:
 439              	.LFB183:
 334:../SSC/Src/ecatslv.c **** 
 335:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 336:../SSC/Src/ecatslv.c **** /**
 337:../SSC/Src/ecatslv.c ****  \param     channel        Sync Manager channel
 338:../SSC/Src/ecatslv.c **** 
 339:../SSC/Src/ecatslv.c ****  \brief    This function disables a Sync Manager channel
 340:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 341:../SSC/Src/ecatslv.c **** void DisableSyncManChannel(UINT8 channel)
 342:../SSC/Src/ecatslv.c **** {
 440              	 .loc 3 342 0
 441              	 .cfi_startproc
 442              	 
 443              	 
 444              	 
 445 0000 80B4     	 push {r7}
 446              	.LCFI32:
 447              	 .cfi_def_cfa_offset 4
 448              	 .cfi_offset 7,-4
 449 0002 85B0     	 sub sp,sp,#20
 450              	.LCFI33:
 451              	 .cfi_def_cfa_offset 24
 452 0004 00AF     	 add r7,sp,#0
 453              	.LCFI34:
 454              	 .cfi_def_cfa_register 7
 455 0006 0346     	 mov r3,r0
 456 0008 FB71     	 strb r3,[r7,#7]
 343:../SSC/Src/ecatslv.c ****     UINT16 Offset;
 344:../SSC/Src/ecatslv.c ****     VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
 457              	 .loc 3 344 0
 458 000a 0123     	 movs r3,#1
 459 000c 7B73     	 strb r3,[r7,#13]
 345:../SSC/Src/ecatslv.c ****     Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
 460              	 .loc 3 345 0
 461 000e FB79     	 ldrb r3,[r7,#7]
 462 0010 9BB2     	 uxth r3,r3
 463 0012 DB00     	 lsls r3,r3,#3
 464 0014 9BB2     	 uxth r3,r3
 465 0016 03F60703 	 addw r3,r3,#2055
 466 001a FB81     	 strh r3,[r7,#14]
 346:../SSC/Src/ecatslv.c **** 
 347:../SSC/Src/ecatslv.c ****     HW_EscWriteByte(smStatus,Offset);
 467              	 .loc 3 347 0
 468 001c FB89     	 ldrh r3,[r7,#14]
 469 001e 03F1A843 	 add r3,r3,#1409286144
 470 0022 03F58033 	 add r3,r3,#65536
 471 0026 7A7B     	 ldrb r2,[r7,#13]
 472 0028 D2B2     	 uxtb r2,r2
 473 002a 1A70     	 strb r2,[r3]
 474              	.L25:
 348:../SSC/Src/ecatslv.c ****     
 349:../SSC/Src/ecatslv.c ****     /*wait until SyncManager is disabled*/
 350:../SSC/Src/ecatslv.c ****     do
 351:../SSC/Src/ecatslv.c ****     {
 352:../SSC/Src/ecatslv.c ****         HW_EscReadByte(smStatus, Offset);
 475              	 .loc 3 352 0 discriminator 1
 476 002c FB89     	 ldrh r3,[r7,#14]
 477 002e 03F1A843 	 add r3,r3,#1409286144
 478 0032 03F58033 	 add r3,r3,#65536
 479 0036 1B78     	 ldrb r3,[r3]
 480 0038 DBB2     	 uxtb r3,r3
 481 003a 7B73     	 strb r3,[r7,#13]
 353:../SSC/Src/ecatslv.c ****     }while(!(smStatus & SM_SETTING_PDI_DISABLE));
 482              	 .loc 3 353 0 discriminator 1
 483 003c 7B7B     	 ldrb r3,[r7,#13]
 484 003e DBB2     	 uxtb r3,r3
 485 0040 03F00103 	 and r3,r3,#1
 486 0044 002B     	 cmp r3,#0
 487 0046 F1D0     	 beq .L25
 354:../SSC/Src/ecatslv.c **** }
 488              	 .loc 3 354 0
 489 0048 1437     	 adds r7,r7,#20
 490              	.LCFI35:
 491              	 .cfi_def_cfa_offset 4
 492 004a BD46     	 mov sp,r7
 493              	.LCFI36:
 494              	 .cfi_def_cfa_register 13
 495              	 
 496 004c 5DF8047B 	 ldr r7,[sp],#4
 497              	.LCFI37:
 498              	 .cfi_restore 7
 499              	 .cfi_def_cfa_offset 0
 500 0050 7047     	 bx lr
 501              	 .cfi_endproc
 502              	.LFE183:
 504 0052 00BF     	 .section .text.EnableSyncManChannel,"ax",%progbits
 505              	 .align 2
 506              	 .global EnableSyncManChannel
 507              	 .thumb
 508              	 .thumb_func
 510              	EnableSyncManChannel:
 511              	.LFB184:
 355:../SSC/Src/ecatslv.c **** 
 356:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 357:../SSC/Src/ecatslv.c **** /**
 358:../SSC/Src/ecatslv.c ****  \param     channel        Sync Manager channel
 359:../SSC/Src/ecatslv.c **** 
 360:../SSC/Src/ecatslv.c ****  \brief    This function enables a Sync Manager channel
 361:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 362:../SSC/Src/ecatslv.c **** void EnableSyncManChannel(UINT8 channel)
 363:../SSC/Src/ecatslv.c **** {
 512              	 .loc 3 363 0
 513              	 .cfi_startproc
 514              	 
 515              	 
 516              	 
 517 0000 80B4     	 push {r7}
 518              	.LCFI38:
 519              	 .cfi_def_cfa_offset 4
 520              	 .cfi_offset 7,-4
 521 0002 85B0     	 sub sp,sp,#20
 522              	.LCFI39:
 523              	 .cfi_def_cfa_offset 24
 524 0004 00AF     	 add r7,sp,#0
 525              	.LCFI40:
 526              	 .cfi_def_cfa_register 7
 527 0006 0346     	 mov r3,r0
 528 0008 FB71     	 strb r3,[r7,#7]
 364:../SSC/Src/ecatslv.c ****     UINT16 Offset;
 365:../SSC/Src/ecatslv.c ****     VARVOLATILE UINT8 smStatus = 0x00;
 529              	 .loc 3 365 0
 530 000a 0023     	 movs r3,#0
 531 000c 7B73     	 strb r3,[r7,#13]
 366:../SSC/Src/ecatslv.c ****     Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
 532              	 .loc 3 366 0
 533 000e FB79     	 ldrb r3,[r7,#7]
 534 0010 9BB2     	 uxth r3,r3
 535 0012 DB00     	 lsls r3,r3,#3
 536 0014 9BB2     	 uxth r3,r3
 537 0016 03F60703 	 addw r3,r3,#2055
 538 001a FB81     	 strh r3,[r7,#14]
 367:../SSC/Src/ecatslv.c **** 
 368:../SSC/Src/ecatslv.c ****     HW_EscWriteByte(smStatus,Offset);
 539              	 .loc 3 368 0
 540 001c FB89     	 ldrh r3,[r7,#14]
 541 001e 03F1A843 	 add r3,r3,#1409286144
 542 0022 03F58033 	 add r3,r3,#65536
 543 0026 7A7B     	 ldrb r2,[r7,#13]
 544 0028 D2B2     	 uxtb r2,r2
 545 002a 1A70     	 strb r2,[r3]
 546              	.L27:
 369:../SSC/Src/ecatslv.c ****     
 370:../SSC/Src/ecatslv.c ****     /*wait until SyncManager is enabled*/
 371:../SSC/Src/ecatslv.c ****     do
 372:../SSC/Src/ecatslv.c ****     {
 373:../SSC/Src/ecatslv.c ****         HW_EscReadByte(smStatus,Offset);
 547              	 .loc 3 373 0 discriminator 1
 548 002c FB89     	 ldrh r3,[r7,#14]
 549 002e 03F1A843 	 add r3,r3,#1409286144
 550 0032 03F58033 	 add r3,r3,#65536
 551 0036 1B78     	 ldrb r3,[r3]
 552 0038 DBB2     	 uxtb r3,r3
 553 003a 7B73     	 strb r3,[r7,#13]
 374:../SSC/Src/ecatslv.c ****     }while((smStatus & SM_SETTING_PDI_DISABLE));
 554              	 .loc 3 374 0 discriminator 1
 555 003c 7B7B     	 ldrb r3,[r7,#13]
 556 003e DBB2     	 uxtb r3,r3
 557 0040 03F00103 	 and r3,r3,#1
 558 0044 002B     	 cmp r3,#0
 559 0046 F1D1     	 bne .L27
 375:../SSC/Src/ecatslv.c **** }
 560              	 .loc 3 375 0
 561 0048 1437     	 adds r7,r7,#20
 562              	.LCFI41:
 563              	 .cfi_def_cfa_offset 4
 564 004a BD46     	 mov sp,r7
 565              	.LCFI42:
 566              	 .cfi_def_cfa_register 13
 567              	 
 568 004c 5DF8047B 	 ldr r7,[sp],#4
 569              	.LCFI43:
 570              	 .cfi_restore 7
 571              	 .cfi_def_cfa_offset 0
 572 0050 7047     	 bx lr
 573              	 .cfi_endproc
 574              	.LFE184:
 576 0052 00BF     	 .section .text.CheckSmSettings,"ax",%progbits
 577              	 .align 2
 578              	 .global CheckSmSettings
 579              	 .thumb
 580              	 .thumb_func
 582              	CheckSmSettings:
 583              	.LFB185:
 376:../SSC/Src/ecatslv.c **** 
 377:../SSC/Src/ecatslv.c **** 
 378:../SSC/Src/ecatslv.c **** 
 379:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 380:../SSC/Src/ecatslv.c **** /**
 381:../SSC/Src/ecatslv.c ****  \param  maxChannel    last SM channel which should be checked
 382:../SSC/Src/ecatslv.c **** 
 383:../SSC/Src/ecatslv.c ****  \return                 0: okay else AL Status Code
 384:../SSC/Src/ecatslv.c **** 
 385:../SSC/Src/ecatslv.c ****  \brief    This function checks all SM channels
 386:../SSC/Src/ecatslv.c **** 
 387:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 388:../SSC/Src/ecatslv.c **** 
 389:../SSC/Src/ecatslv.c **** UINT8    CheckSmSettings(UINT8 maxChannel)
 390:../SSC/Src/ecatslv.c **** {
 584              	 .loc 3 390 0
 585              	 .cfi_startproc
 586              	 
 587              	 
 588 0000 80B5     	 push {r7,lr}
 589              	.LCFI44:
 590              	 .cfi_def_cfa_offset 8
 591              	 .cfi_offset 7,-8
 592              	 .cfi_offset 14,-4
 593 0002 86B0     	 sub sp,sp,#24
 594              	.LCFI45:
 595              	 .cfi_def_cfa_offset 32
 596 0004 00AF     	 add r7,sp,#0
 597              	.LCFI46:
 598              	 .cfi_def_cfa_register 7
 599 0006 0346     	 mov r3,r0
 600 0008 FB71     	 strb r3,[r7,#7]
 391:../SSC/Src/ecatslv.c ****     UINT8 i;
 392:../SSC/Src/ecatslv.c ****     UINT8 result = 0;
 601              	 .loc 3 392 0
 602 000a 0023     	 movs r3,#0
 603 000c BB75     	 strb r3,[r7,#22]
 393:../SSC/Src/ecatslv.c ****     TSYNCMAN ESCMEM *pSyncMan;
 394:../SSC/Src/ecatslv.c ****     UINT16 SMLength = 0;
 604              	 .loc 3 394 0
 605 000e 0023     	 movs r3,#0
 606 0010 BB82     	 strh r3,[r7,#20]
 395:../SSC/Src/ecatslv.c ****     UINT16 SMAddress = 0;
 607              	 .loc 3 395 0
 608 0012 0023     	 movs r3,#0
 609 0014 7B82     	 strh r3,[r7,#18]
 396:../SSC/Src/ecatslv.c **** 
 397:../SSC/Src/ecatslv.c **** 
 398:../SSC/Src/ecatslv.c ****         //Check if max address defines are within the available ESC address range
 399:../SSC/Src/ecatslv.c ****         if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
 610              	 .loc 3 399 0
 611 0016 9F4B     	 ldr r3,.L79
 612 0018 1B88     	 ldrh r3,[r3]
 613 001a 42F6FE72 	 movw r2,#12286
 614 001e 9342     	 cmp r3,r2
 615 0020 11D9     	 bls .L29
 400:../SSC/Src/ecatslv.c ****             || (nMaxEscAddress < MAX_PD_READ_ADDRESS)
 616              	 .loc 3 400 0
 617 0022 9C4B     	 ldr r3,.L79
 618 0024 1B88     	 ldrh r3,[r3]
 619 0026 42F6FE72 	 movw r2,#12286
 620 002a 9342     	 cmp r3,r2
 621 002c 0BD9     	 bls .L29
 401:../SSC/Src/ecatslv.c ****             || (nMaxEscAddress < MAX_MBX_WRITE_ADDRESS)
 622              	 .loc 3 401 0
 623 002e 994B     	 ldr r3,.L79
 624 0030 1B88     	 ldrh r3,[r3]
 625 0032 42F6FE72 	 movw r2,#12286
 626 0036 9342     	 cmp r3,r2
 627 0038 05D9     	 bls .L29
 402:../SSC/Src/ecatslv.c ****             || (nMaxEscAddress < MAX_MBX_READ_ADDRESS))
 628              	 .loc 3 402 0
 629 003a 964B     	 ldr r3,.L79
 630 003c 1B88     	 ldrh r3,[r3]
 631 003e 42F6FE72 	 movw r2,#12286
 632 0042 9342     	 cmp r3,r2
 633 0044 01D8     	 bhi .L30
 634              	.L29:
 403:../SSC/Src/ecatslv.c ****         {
 404:../SSC/Src/ecatslv.c ****             /*The defines for maximum SM addresses are invalid for the used ESC (change the defines
 405:../SSC/Src/ecatslv.c ****             It may be also required to adapt the SM settings in the ESI file*/
 406:../SSC/Src/ecatslv.c **** 
 407:../SSC/Src/ecatslv.c **** 
 408:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_NOVALIDFIRMWARE;
 635              	 .loc 3 408 0
 636 0046 1423     	 movs r3,#20
 637 0048 A5E1     	 b .L31
 638              	.L30:
 409:../SSC/Src/ecatslv.c ****         }
 410:../SSC/Src/ecatslv.c **** 
 411:../SSC/Src/ecatslv.c ****     /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
 412:../SSC/Src/ecatslv.c ****     pSyncMan = GetSyncMan(MAILBOX_WRITE);
 639              	 .loc 3 412 0
 640 004a 0020     	 movs r0,#0
 641 004c FFF7FEFF 	 bl GetSyncMan
 642 0050 F860     	 str r0,[r7,#12]
 413:../SSC/Src/ecatslv.c **** 
 414:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 643              	 .loc 3 414 0
 644 0052 FB68     	 ldr r3,[r7,#12]
 645 0054 9A78     	 ldrb r2,[r3,#2]
 646 0056 DB78     	 ldrb r3,[r3,#3]
 647 0058 1B02     	 lsls r3,r3,#8
 648 005a 1343     	 orrs r3,r3,r2
 649 005c BB82     	 strh r3,[r7,#20]
 415:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 650              	 .loc 3 415 0
 651 005e FB68     	 ldr r3,[r7,#12]
 652 0060 1A78     	 ldrb r2,[r3]
 653 0062 5B78     	 ldrb r3,[r3,#1]
 654 0064 1B02     	 lsls r3,r3,#8
 655 0066 1343     	 orrs r3,r3,r2
 656 0068 7B82     	 strh r3,[r7,#18]
 416:../SSC/Src/ecatslv.c **** 
 417:../SSC/Src/ecatslv.c **** 
 418:../SSC/Src/ecatslv.c **** 
 419:../SSC/Src/ecatslv.c ****     if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
 657              	 .loc 3 419 0
 658 006a FB68     	 ldr r3,[r7,#12]
 659 006c 9B79     	 ldrb r3,[r3,#6]
 660 006e 03F00103 	 and r3,r3,#1
 661 0072 002B     	 cmp r3,#0
 662 0074 02D1     	 bne .L32
 420:../SSC/Src/ecatslv.c ****     {
 421:../SSC/Src/ecatslv.c ****         /* receive mailbox is not enabled */
 422:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 663              	 .loc 3 422 0
 664 0076 1623     	 movs r3,#22
 665 0078 BB75     	 strb r3,[r7,#22]
 666 007a 2AE0     	 b .L33
 667              	.L32:
 423:../SSC/Src/ecatslv.c ****     }
 424:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETT
 668              	 .loc 3 424 0
 669 007c FB68     	 ldr r3,[r7,#12]
 670 007e 1B79     	 ldrb r3,[r3,#4]
 671 0080 03F00C03 	 and r3,r3,#12
 672 0084 042B     	 cmp r3,#4
 673 0086 02D0     	 beq .L34
 425:../SSC/Src/ecatslv.c ****     {
 426:../SSC/Src/ecatslv.c ****         /* receive mailbox is not writable by the master*/
 427:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 674              	 .loc 3 427 0
 675 0088 1623     	 movs r3,#22
 676 008a BB75     	 strb r3,[r7,#22]
 677 008c 21E0     	 b .L33
 678              	.L34:
 428:../SSC/Src/ecatslv.c ****     }
 429:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_M
 679              	 .loc 3 429 0
 680 008e FB68     	 ldr r3,[r7,#12]
 681 0090 1B79     	 ldrb r3,[r3,#4]
 682 0092 03F00203 	 and r3,r3,#2
 683 0096 002B     	 cmp r3,#0
 684 0098 02D1     	 bne .L35
 430:../SSC/Src/ecatslv.c ****     {
 431:../SSC/Src/ecatslv.c ****         /* receive mailbox is not in one buffer mode */
 432:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 685              	 .loc 3 432 0
 686 009a 1623     	 movs r3,#22
 687 009c BB75     	 strb r3,[r7,#22]
 688 009e 18E0     	 b .L33
 689              	.L35:
 433:../SSC/Src/ecatslv.c ****     }
 434:../SSC/Src/ecatslv.c ****     else if (SMLength < MIN_MBX_SIZE)
 690              	 .loc 3 434 0
 691 00a0 BB8A     	 ldrh r3,[r7,#20]
 692 00a2 232B     	 cmp r3,#35
 693 00a4 02D8     	 bhi .L36
 435:../SSC/Src/ecatslv.c ****     {
 436:../SSC/Src/ecatslv.c ****         /* receive mailbox size is too small */
 437:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 694              	 .loc 3 437 0
 695 00a6 1623     	 movs r3,#22
 696 00a8 BB75     	 strb r3,[r7,#22]
 697 00aa 12E0     	 b .L33
 698              	.L36:
 438:../SSC/Src/ecatslv.c ****     }
 439:../SSC/Src/ecatslv.c ****     else if (SMLength > MAX_MBX_SIZE)
 699              	 .loc 3 439 0
 700 00ac BB8A     	 ldrh r3,[r7,#20]
 701 00ae 802B     	 cmp r3,#128
 702 00b0 02D9     	 bls .L37
 440:../SSC/Src/ecatslv.c ****     {
 441:../SSC/Src/ecatslv.c ****         /* receive mailbox size is too great */
 442:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 703              	 .loc 3 442 0
 704 00b2 1623     	 movs r3,#22
 705 00b4 BB75     	 strb r3,[r7,#22]
 706 00b6 0CE0     	 b .L33
 707              	.L37:
 443:../SSC/Src/ecatslv.c ****     }
 444:../SSC/Src/ecatslv.c ****     else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
 708              	 .loc 3 444 0
 709 00b8 7B8A     	 ldrh r3,[r7,#18]
 710 00ba B3F5805F 	 cmp r3,#4096
 711 00be 02D2     	 bcs .L38
 445:../SSC/Src/ecatslv.c ****     {
 446:../SSC/Src/ecatslv.c ****         /* receive mailbox address is too small */
 447:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 712              	 .loc 3 447 0
 713 00c0 1623     	 movs r3,#22
 714 00c2 BB75     	 strb r3,[r7,#22]
 715 00c4 05E0     	 b .L33
 716              	.L38:
 448:../SSC/Src/ecatslv.c ****     }
 449:../SSC/Src/ecatslv.c ****     else if (SMAddress > MAX_MBX_WRITE_ADDRESS)
 717              	 .loc 3 449 0
 718 00c6 7B8A     	 ldrh r3,[r7,#18]
 719 00c8 B3F5405F 	 cmp r3,#12288
 720 00cc 01D3     	 bcc .L33
 450:../SSC/Src/ecatslv.c ****     {
 451:../SSC/Src/ecatslv.c ****         /* receive mailbox address is too great */
 452:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 721              	 .loc 3 452 0
 722 00ce 1623     	 movs r3,#22
 723 00d0 BB75     	 strb r3,[r7,#22]
 724              	.L33:
 453:../SSC/Src/ecatslv.c ****     }
 454:../SSC/Src/ecatslv.c **** 
 455:../SSC/Src/ecatslv.c **** 
 456:../SSC/Src/ecatslv.c ****     if ( result == 0 )
 725              	 .loc 3 456 0
 726 00d2 BB7D     	 ldrb r3,[r7,#22]
 727 00d4 002B     	 cmp r3,#0
 728 00d6 43D1     	 bne .L39
 457:../SSC/Src/ecatslv.c ****     {
 458:../SSC/Src/ecatslv.c ****         /* check the Sync Manager Parameter for the Send Mailbox (Sync Manager Channel 1) */
 459:../SSC/Src/ecatslv.c ****         pSyncMan = GetSyncMan(MAILBOX_READ);
 729              	 .loc 3 459 0
 730 00d8 0120     	 movs r0,#1
 731 00da FFF7FEFF 	 bl GetSyncMan
 732 00de F860     	 str r0,[r7,#12]
 460:../SSC/Src/ecatslv.c **** 
 461:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 733              	 .loc 3 461 0
 734 00e0 FB68     	 ldr r3,[r7,#12]
 735 00e2 9A78     	 ldrb r2,[r3,#2]
 736 00e4 DB78     	 ldrb r3,[r3,#3]
 737 00e6 1B02     	 lsls r3,r3,#8
 738 00e8 1343     	 orrs r3,r3,r2
 739 00ea BB82     	 strh r3,[r7,#20]
 462:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 740              	 .loc 3 462 0
 741 00ec FB68     	 ldr r3,[r7,#12]
 742 00ee 1A78     	 ldrb r2,[r3]
 743 00f0 5B78     	 ldrb r3,[r3,#1]
 744 00f2 1B02     	 lsls r3,r3,#8
 745 00f4 1343     	 orrs r3,r3,r2
 746 00f6 7B82     	 strh r3,[r7,#18]
 463:../SSC/Src/ecatslv.c **** 
 464:../SSC/Src/ecatslv.c **** 
 465:../SSC/Src/ecatslv.c ****     if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
 747              	 .loc 3 465 0
 748 00f8 FB68     	 ldr r3,[r7,#12]
 749 00fa 9B79     	 ldrb r3,[r3,#6]
 750 00fc 03F00103 	 and r3,r3,#1
 751 0100 002B     	 cmp r3,#0
 752 0102 02D1     	 bne .L40
 466:../SSC/Src/ecatslv.c ****     {
 467:../SSC/Src/ecatslv.c ****         /* send mailbox is not enabled */
 468:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 753              	 .loc 3 468 0
 754 0104 1623     	 movs r3,#22
 755 0106 BB75     	 strb r3,[r7,#22]
 756 0108 2AE0     	 b .L39
 757              	.L40:
 469:../SSC/Src/ecatslv.c ****     }
 470:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETT
 758              	 .loc 3 470 0
 759 010a FB68     	 ldr r3,[r7,#12]
 760 010c 1B79     	 ldrb r3,[r3,#4]
 761 010e 03F00C03 	 and r3,r3,#12
 762 0112 002B     	 cmp r3,#0
 763 0114 02D0     	 beq .L41
 471:../SSC/Src/ecatslv.c ****     {
 472:../SSC/Src/ecatslv.c ****         /* receive mailbox is not readable by the master*/
 473:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 764              	 .loc 3 473 0
 765 0116 1623     	 movs r3,#22
 766 0118 BB75     	 strb r3,[r7,#22]
 767 011a 21E0     	 b .L39
 768              	.L41:
 474:../SSC/Src/ecatslv.c ****     }
 475:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_M
 769              	 .loc 3 475 0
 770 011c FB68     	 ldr r3,[r7,#12]
 771 011e 1B79     	 ldrb r3,[r3,#4]
 772 0120 03F00203 	 and r3,r3,#2
 773 0124 002B     	 cmp r3,#0
 774 0126 02D1     	 bne .L42
 476:../SSC/Src/ecatslv.c ****     {
 477:../SSC/Src/ecatslv.c ****         /* receive mailbox is not in one buffer mode */
 478:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 775              	 .loc 3 478 0
 776 0128 1623     	 movs r3,#22
 777 012a BB75     	 strb r3,[r7,#22]
 778 012c 18E0     	 b .L39
 779              	.L42:
 479:../SSC/Src/ecatslv.c ****     }
 480:../SSC/Src/ecatslv.c ****     else if (SMLength < MIN_MBX_SIZE)
 780              	 .loc 3 480 0
 781 012e BB8A     	 ldrh r3,[r7,#20]
 782 0130 232B     	 cmp r3,#35
 783 0132 02D8     	 bhi .L43
 481:../SSC/Src/ecatslv.c ****     {
 482:../SSC/Src/ecatslv.c ****         /* send mailbox size is too small */
 483:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 784              	 .loc 3 483 0
 785 0134 1623     	 movs r3,#22
 786 0136 BB75     	 strb r3,[r7,#22]
 787 0138 12E0     	 b .L39
 788              	.L43:
 484:../SSC/Src/ecatslv.c ****     }
 485:../SSC/Src/ecatslv.c ****     else if (SMLength > MAX_MBX_SIZE)
 789              	 .loc 3 485 0
 790 013a BB8A     	 ldrh r3,[r7,#20]
 791 013c 802B     	 cmp r3,#128
 792 013e 02D9     	 bls .L44
 486:../SSC/Src/ecatslv.c ****     {
 487:../SSC/Src/ecatslv.c ****         /* send mailbox size is too great */
 488:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 793              	 .loc 3 488 0
 794 0140 1623     	 movs r3,#22
 795 0142 BB75     	 strb r3,[r7,#22]
 796 0144 0CE0     	 b .L39
 797              	.L44:
 489:../SSC/Src/ecatslv.c ****     }
 490:../SSC/Src/ecatslv.c ****     else if (SMAddress < MIN_MBX_READ_ADDRESS)
 798              	 .loc 3 490 0
 799 0146 7B8A     	 ldrh r3,[r7,#18]
 800 0148 B3F5805F 	 cmp r3,#4096
 801 014c 02D2     	 bcs .L45
 491:../SSC/Src/ecatslv.c ****     {
 492:../SSC/Src/ecatslv.c ****         /* send mailbox address is too small */
 493:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 802              	 .loc 3 493 0
 803 014e 1623     	 movs r3,#22
 804 0150 BB75     	 strb r3,[r7,#22]
 805 0152 05E0     	 b .L39
 806              	.L45:
 494:../SSC/Src/ecatslv.c ****     }
 495:../SSC/Src/ecatslv.c ****     else if (SMAddress > MAX_MBX_READ_ADDRESS)
 807              	 .loc 3 495 0
 808 0154 7B8A     	 ldrh r3,[r7,#18]
 809 0156 B3F5405F 	 cmp r3,#12288
 810 015a 01D3     	 bcc .L39
 496:../SSC/Src/ecatslv.c ****     {
 497:../SSC/Src/ecatslv.c ****         /* send mailbox address is too great */
 498:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 811              	 .loc 3 498 0
 812 015c 1623     	 movs r3,#22
 813 015e BB75     	 strb r3,[r7,#22]
 814              	.L39:
 499:../SSC/Src/ecatslv.c ****     }
 500:../SSC/Src/ecatslv.c ****     }
 501:../SSC/Src/ecatslv.c **** 
 502:../SSC/Src/ecatslv.c ****     if ( result == 0 && maxChannel > PROCESS_DATA_IN )
 815              	 .loc 3 502 0
 816 0160 BB7D     	 ldrb r3,[r7,#22]
 817 0162 002B     	 cmp r3,#0
 818 0164 71D1     	 bne .L46
 819              	 .loc 3 502 0 is_stmt 0 discriminator 1
 820 0166 FB79     	 ldrb r3,[r7,#7]
 821 0168 032B     	 cmp r3,#3
 822 016a 6ED9     	 bls .L46
 503:../SSC/Src/ecatslv.c ****     {
 504:../SSC/Src/ecatslv.c ****         /* b3BufferMode is only set, if inputs and outputs are running in 3-Buffer-Mode when leavin
 505:../SSC/Src/ecatslv.c ****         b3BufferMode = TRUE;
 823              	 .loc 3 505 0 is_stmt 1
 824 016c 4A4B     	 ldr r3,.L79+4
 825 016e 0122     	 movs r2,#1
 826 0170 1A70     	 strb r2,[r3]
 506:../SSC/Src/ecatslv.c ****         /* check the Sync Manager Parameter for the Inputs (Sync Manager Channel 2 (0 in case if no
 507:../SSC/Src/ecatslv.c ****         pSyncMan = GetSyncMan(PROCESS_DATA_IN);
 827              	 .loc 3 507 0
 828 0172 0320     	 movs r0,#3
 829 0174 FFF7FEFF 	 bl GetSyncMan
 830 0178 F860     	 str r0,[r7,#12]
 508:../SSC/Src/ecatslv.c **** 
 509:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 831              	 .loc 3 509 0
 832 017a FB68     	 ldr r3,[r7,#12]
 833 017c 9A78     	 ldrb r2,[r3,#2]
 834 017e DB78     	 ldrb r3,[r3,#3]
 835 0180 1B02     	 lsls r3,r3,#8
 836 0182 1343     	 orrs r3,r3,r2
 837 0184 BB82     	 strh r3,[r7,#20]
 510:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 838              	 .loc 3 510 0
 839 0186 FB68     	 ldr r3,[r7,#12]
 840 0188 1A78     	 ldrb r2,[r3]
 841 018a 5B78     	 ldrb r3,[r3,#1]
 842 018c 1B02     	 lsls r3,r3,#8
 843 018e 1343     	 orrs r3,r3,r2
 844 0190 7B82     	 strh r3,[r7,#18]
 511:../SSC/Src/ecatslv.c **** 
 512:../SSC/Src/ecatslv.c **** 
 513:../SSC/Src/ecatslv.c **** 
 514:../SSC/Src/ecatslv.c ****     if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength
 845              	 .loc 3 514 0
 846 0192 FB68     	 ldr r3,[r7,#12]
 847 0194 9B79     	 ldrb r3,[r3,#6]
 848 0196 03F00103 	 and r3,r3,#1
 849 019a 002B     	 cmp r3,#0
 850 019c 05D0     	 beq .L47
 851              	 .loc 3 514 0 is_stmt 0 discriminator 1
 852 019e BB8A     	 ldrh r3,[r7,#20]
 853 01a0 002B     	 cmp r3,#0
 854 01a2 02D1     	 bne .L47
 515:../SSC/Src/ecatslv.c ****     {
 516:../SSC/Src/ecatslv.c ****         /* the SM3 size is 0 and the SM3 is active */
 517:../SSC/Src/ecatslv.c ****         result = SYNCMANCHSETTINGS + 1;
 855              	 .loc 3 517 0 is_stmt 1
 856 01a4 0423     	 movs r3,#4
 857 01a6 BB75     	 strb r3,[r7,#22]
 858 01a8 4AE0     	 b .L48
 859              	.L47:
 518:../SSC/Src/ecatslv.c ****     }
 519:../SSC/Src/ecatslv.c ****         else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
 860              	 .loc 3 519 0
 861 01aa FB68     	 ldr r3,[r7,#12]
 862 01ac 9B79     	 ldrb r3,[r3,#6]
 863 01ae 03F00103 	 and r3,r3,#1
 864 01b2 002B     	 cmp r3,#0
 865 01b4 3BD0     	 beq .L49
 520:../SSC/Src/ecatslv.c ****         {
 521:../SSC/Src/ecatslv.c ****             /* Sync Manager Channel 3 is active, input size has to greater 0 */
 522:../SSC/Src/ecatslv.c ****                 if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
 866              	 .loc 3 522 0
 867 01b6 394B     	 ldr r3,.L79+8
 868 01b8 1B88     	 ldrh r3,[r3]
 869 01ba BA8A     	 ldrh r2,[r7,#20]
 870 01bc 9A42     	 cmp r2,r3
 871 01be 06D1     	 bne .L50
 872              	 .loc 3 522 0 is_stmt 0 discriminator 1
 873 01c0 364B     	 ldr r3,.L79+8
 874 01c2 1B88     	 ldrh r3,[r3]
 875 01c4 002B     	 cmp r3,#0
 876 01c6 02D0     	 beq .L50
 877              	 .loc 3 522 0 discriminator 2
 878 01c8 BB8A     	 ldrh r3,[r7,#20]
 879 01ca 442B     	 cmp r3,#68
 880 01cc 02D9     	 bls .L51
 881              	.L50:
 523:../SSC/Src/ecatslv.c ****                 {
 524:../SSC/Src/ecatslv.c ****                     /* sizes don't match */
 525:../SSC/Src/ecatslv.c ****                     result = SYNCMANCHSIZE + 1;
 882              	 .loc 3 525 0 is_stmt 1
 883 01ce 0323     	 movs r3,#3
 884 01d0 BB75     	 strb r3,[r7,#22]
 885 01d2 35E0     	 b .L48
 886              	.L51:
 526:../SSC/Src/ecatslv.c ****                 }
 527:../SSC/Src/ecatslv.c ****                 else
 528:../SSC/Src/ecatslv.c ****                 {
 529:../SSC/Src/ecatslv.c ****                     /* sizes matches */
 530:../SSC/Src/ecatslv.c ****                     if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK)
 887              	 .loc 3 530 0
 888 01d4 FB68     	 ldr r3,[r7,#12]
 889 01d6 1B79     	 ldrb r3,[r3,#4]
 890 01d8 03F00C03 	 and r3,r3,#12
 891 01dc 002B     	 cmp r3,#0
 892 01de 23D1     	 bne .L53
 531:../SSC/Src/ecatslv.c ****                     {
 532:../SSC/Src/ecatslv.c ****                         /* settings match */
 533:../SSC/Src/ecatslv.c ****                         if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (S
 893              	 .loc 3 533 0
 894 01e0 2F4B     	 ldr r3,.L79+12
 895 01e2 1B78     	 ldrb r3,[r3]
 896 01e4 022B     	 cmp r3,#2
 897 01e6 07D1     	 bne .L54
 898              	 .loc 3 533 0 is_stmt 0 discriminator 1
 899 01e8 7B8A     	 ldrh r3,[r7,#18]
 900 01ea B3F5805F 	 cmp r3,#4096
 901 01ee 03D3     	 bcc .L54
 902              	 .loc 3 533 0 discriminator 2
 903 01f0 7B8A     	 ldrh r3,[r7,#18]
 904 01f2 B3F5405F 	 cmp r3,#12288
 905 01f6 08D3     	 bcc .L55
 906              	.L54:
 534:../SSC/Src/ecatslv.c ****                             || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
 907              	 .loc 3 534 0 is_stmt 1
 908 01f8 294B     	 ldr r3,.L79+12
 909 01fa 1B78     	 ldrb r3,[r3]
 910 01fc 022B     	 cmp r3,#2
 911 01fe 0FD0     	 beq .L56
 912              	 .loc 3 534 0 is_stmt 0 discriminator 1
 913 0200 284B     	 ldr r3,.L79+16
 914 0202 1B88     	 ldrh r3,[r3]
 915 0204 7A8A     	 ldrh r2,[r7,#18]
 916 0206 9A42     	 cmp r2,r3
 917 0208 0AD1     	 bne .L56
 918              	.L55:
 535:../SSC/Src/ecatslv.c ****                             )
 536:../SSC/Src/ecatslv.c ****                         {
 537:../SSC/Src/ecatslv.c ****                             /* addresses match */
 538:../SSC/Src/ecatslv.c **** 
 539:../SSC/Src/ecatslv.c ****                                 if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MOD
 919              	 .loc 3 539 0 is_stmt 1
 920 020a FB68     	 ldr r3,[r7,#12]
 921 020c 1B79     	 ldrb r3,[r3,#4]
 922 020e 03F00203 	 and r3,r3,#2
 923 0212 002B     	 cmp r3,#0
 924 0214 03D0     	 beq .L57
 540:../SSC/Src/ecatslv.c ****                                 {
 541:../SSC/Src/ecatslv.c ****                                     /* inputs are running in 1-Buffer-Mode, reset flag b3BufferMode
 542:../SSC/Src/ecatslv.c ****                                     b3BufferMode = FALSE;
 925              	 .loc 3 542 0
 926 0216 204B     	 ldr r3,.L79+4
 927 0218 0022     	 movs r2,#0
 928 021a 1A70     	 strb r2,[r3]
 539:../SSC/Src/ecatslv.c ****                                 {
 929              	 .loc 3 539 0
 930 021c 03E0     	 b .L58
 931              	.L57:
 932 021e 02E0     	 b .L58
 933              	.L56:
 543:../SSC/Src/ecatslv.c ****                                 }
 544:../SSC/Src/ecatslv.c ****                         }
 545:../SSC/Src/ecatslv.c ****                         else
 546:../SSC/Src/ecatslv.c ****                         {
 547:../SSC/Src/ecatslv.c ****                             /* input address is out of the allowed area or has changed in SAFEOP or
 548:../SSC/Src/ecatslv.c ****                             result = SYNCMANCHADDRESS + 1;
 934              	 .loc 3 548 0
 935 0220 0223     	 movs r3,#2
 936 0222 BB75     	 strb r3,[r7,#22]
 937 0224 0CE0     	 b .L48
 938              	.L58:
 939 0226 0BE0     	 b .L48
 940              	.L53:
 549:../SSC/Src/ecatslv.c ****                         }
 550:../SSC/Src/ecatslv.c ****                     }
 551:../SSC/Src/ecatslv.c ****                     else
 552:../SSC/Src/ecatslv.c ****                     {
 553:../SSC/Src/ecatslv.c ****                         /* input settings do not match */
 554:../SSC/Src/ecatslv.c ****                         result = SYNCMANCHSETTINGS + 1;
 941              	 .loc 3 554 0
 942 0228 0423     	 movs r3,#4
 943 022a BB75     	 strb r3,[r7,#22]
 944 022c 08E0     	 b .L48
 945              	.L49:
 555:../SSC/Src/ecatslv.c ****                     }
 556:../SSC/Src/ecatslv.c ****                 }
 557:../SSC/Src/ecatslv.c ****         }
 558:../SSC/Src/ecatslv.c ****         else if (SMLength != 0 || nPdInputSize != 0)
 946              	 .loc 3 558 0
 947 022e BB8A     	 ldrh r3,[r7,#20]
 948 0230 002B     	 cmp r3,#0
 949 0232 03D1     	 bne .L59
 950              	 .loc 3 558 0 is_stmt 0 discriminator 1
 951 0234 194B     	 ldr r3,.L79+8
 952 0236 1B88     	 ldrh r3,[r3]
 953 0238 002B     	 cmp r3,#0
 954 023a 01D0     	 beq .L48
 955              	.L59:
 559:../SSC/Src/ecatslv.c ****         {
 560:../SSC/Src/ecatslv.c ****             /* input size is not zero although the SM3 channel is not enabled */
 561:../SSC/Src/ecatslv.c ****             result = SYNCMANCHSIZE + 1;
 956              	 .loc 3 561 0 is_stmt 1
 957 023c 0323     	 movs r3,#3
 958 023e BB75     	 strb r3,[r7,#22]
 959              	.L48:
 562:../SSC/Src/ecatslv.c ****         }
 563:../SSC/Src/ecatslv.c **** 
 564:../SSC/Src/ecatslv.c **** 
 565:../SSC/Src/ecatslv.c **** 
 566:../SSC/Src/ecatslv.c ****         if ( result != 0 )
 960              	 .loc 3 566 0
 961 0240 BB7D     	 ldrb r3,[r7,#22]
 962 0242 002B     	 cmp r3,#0
 963 0244 01D0     	 beq .L46
 567:../SSC/Src/ecatslv.c ****         {
 568:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_INVALIDSMINCFG;
 964              	 .loc 3 568 0
 965 0246 1E23     	 movs r3,#30
 966 0248 BB75     	 strb r3,[r7,#22]
 967              	.L46:
 569:../SSC/Src/ecatslv.c ****         }
 570:../SSC/Src/ecatslv.c ****     }
 571:../SSC/Src/ecatslv.c **** 
 572:../SSC/Src/ecatslv.c **** 
 573:../SSC/Src/ecatslv.c **** //    else
 574:../SSC/Src/ecatslv.c ****     if (result == 0 && maxChannel > PROCESS_DATA_OUT)
 968              	 .loc 3 574 0
 969 024a BB7D     	 ldrb r3,[r7,#22]
 970 024c 002B     	 cmp r3,#0
 971 024e 40F08A80 	 bne .L60
 972              	 .loc 3 574 0 is_stmt 0 discriminator 1
 973 0252 FB79     	 ldrb r3,[r7,#7]
 974 0254 022B     	 cmp r3,#2
 975 0256 40F28680 	 bls .L60
 575:../SSC/Src/ecatslv.c ****     {
 576:../SSC/Src/ecatslv.c ****         /* check the Sync Manager Parameter for the Outputs (Sync Manager Channel 2) */
 577:../SSC/Src/ecatslv.c ****         pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
 976              	 .loc 3 577 0 is_stmt 1
 977 025a 0220     	 movs r0,#2
 978 025c FFF7FEFF 	 bl GetSyncMan
 979 0260 F860     	 str r0,[r7,#12]
 578:../SSC/Src/ecatslv.c **** 
 579:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 980              	 .loc 3 579 0
 981 0262 FB68     	 ldr r3,[r7,#12]
 982 0264 9A78     	 ldrb r2,[r3,#2]
 983 0266 DB78     	 ldrb r3,[r3,#3]
 984 0268 1B02     	 lsls r3,r3,#8
 985 026a 1343     	 orrs r3,r3,r2
 986 026c BB82     	 strh r3,[r7,#20]
 580:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 987              	 .loc 3 580 0
 988 026e FB68     	 ldr r3,[r7,#12]
 989 0270 1A78     	 ldrb r2,[r3]
 990 0272 5B78     	 ldrb r3,[r3,#1]
 991 0274 1B02     	 lsls r3,r3,#8
 992 0276 1343     	 orrs r3,r3,r2
 993 0278 7B82     	 strh r3,[r7,#18]
 581:../SSC/Src/ecatslv.c **** 
 582:../SSC/Src/ecatslv.c **** 
 583:../SSC/Src/ecatslv.c **** 
 584:../SSC/Src/ecatslv.c ****     if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength
 994              	 .loc 3 584 0
 995 027a FB68     	 ldr r3,[r7,#12]
 996 027c 9B79     	 ldrb r3,[r3,#6]
 997 027e 03F00103 	 and r3,r3,#1
 998 0282 002B     	 cmp r3,#0
 999 0284 10D0     	 beq .L61
 1000              	 .loc 3 584 0 is_stmt 0 discriminator 1
 1001 0286 BB8A     	 ldrh r3,[r7,#20]
 1002 0288 002B     	 cmp r3,#0
 1003 028a 0DD1     	 bne .L61
 585:../SSC/Src/ecatslv.c ****     {
 586:../SSC/Src/ecatslv.c ****         /* the SM2 size is 0 and the SM2 is active */
 587:../SSC/Src/ecatslv.c ****         result = SYNCMANCHSETTINGS + 1;
 1004              	 .loc 3 587 0 is_stmt 1
 1005 028c 0423     	 movs r3,#4
 1006 028e BB75     	 strb r3,[r7,#22]
 1007 0290 64E0     	 b .L62
 1008              	.L80:
 1009 0292 00BF     	 .align 2
 1010              	.L79:
 1011 0294 00000000 	 .word nMaxEscAddress
 1012 0298 00000000 	 .word b3BufferMode
 1013 029c 00000000 	 .word nPdInputSize
 1014 02a0 00000000 	 .word nAlStatus
 1015 02a4 00000000 	 .word nEscAddrInputData
 1016              	.L61:
 588:../SSC/Src/ecatslv.c ****     }
 589:../SSC/Src/ecatslv.c ****         else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
 1017              	 .loc 3 589 0
 1018 02a8 FB68     	 ldr r3,[r7,#12]
 1019 02aa 9B79     	 ldrb r3,[r3,#6]
 1020 02ac 03F00103 	 and r3,r3,#1
 1021 02b0 002B     	 cmp r3,#0
 1022 02b2 4AD0     	 beq .L63
 590:../SSC/Src/ecatslv.c ****         {
 591:../SSC/Src/ecatslv.c ****             /* Sync Manager Channel 2 is active, output size has to greater 0 */
 592:../SSC/Src/ecatslv.c ****             if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUT
 1023              	 .loc 3 592 0
 1024 02b4 3A4B     	 ldr r3,.L81
 1025 02b6 1B88     	 ldrh r3,[r3]
 1026 02b8 BA8A     	 ldrh r2,[r7,#20]
 1027 02ba 9A42     	 cmp r2,r3
 1028 02bc 41D1     	 bne .L64
 1029              	 .loc 3 592 0 is_stmt 0 discriminator 1
 1030 02be 384B     	 ldr r3,.L81
 1031 02c0 1B88     	 ldrh r3,[r3]
 1032 02c2 002B     	 cmp r3,#0
 1033 02c4 3DD0     	 beq .L64
 1034              	 .loc 3 592 0 discriminator 2
 1035 02c6 BB8A     	 ldrh r3,[r7,#20]
 1036 02c8 442B     	 cmp r3,#68
 1037 02ca 3AD8     	 bhi .L64
 593:../SSC/Src/ecatslv.c ****             {
 594:../SSC/Src/ecatslv.c ****                 /* sizes match */
 595:../SSC/Src/ecatslv.c ****                 if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) ==
 1038              	 .loc 3 595 0 is_stmt 1
 1039 02cc FB68     	 ldr r3,[r7,#12]
 1040 02ce 1B79     	 ldrb r3,[r3,#4]
 1041 02d0 03F00C03 	 and r3,r3,#12
 1042 02d4 042B     	 cmp r3,#4
 1043 02d6 30D1     	 bne .L65
 596:../SSC/Src/ecatslv.c ****                 {
 597:../SSC/Src/ecatslv.c ****                     /* settings match */
 598:../SSC/Src/ecatslv.c ****                     if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( S
 1044              	 .loc 3 598 0
 1045 02d8 324B     	 ldr r3,.L81+4
 1046 02da 1B78     	 ldrb r3,[r3]
 1047 02dc 022B     	 cmp r3,#2
 1048 02de 07D1     	 bne .L66
 1049              	 .loc 3 598 0 is_stmt 0 discriminator 1
 1050 02e0 7B8A     	 ldrh r3,[r7,#18]
 1051 02e2 B3F5805F 	 cmp r3,#4096
 1052 02e6 03D3     	 bcc .L66
 1053              	 .loc 3 598 0 discriminator 2
 1054 02e8 7B8A     	 ldrh r3,[r7,#18]
 1055 02ea B3F5405F 	 cmp r3,#12288
 1056 02ee 08D3     	 bcc .L67
 1057              	.L66:
 599:../SSC/Src/ecatslv.c ****                        ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
 1058              	 .loc 3 599 0 is_stmt 1
 1059 02f0 2C4B     	 ldr r3,.L81+4
 1060 02f2 1B78     	 ldrb r3,[r3]
 1061 02f4 022B     	 cmp r3,#2
 1062 02f6 1CD0     	 beq .L68
 1063              	 .loc 3 599 0 is_stmt 0 discriminator 1
 1064 02f8 2B4B     	 ldr r3,.L81+8
 1065 02fa 1B88     	 ldrh r3,[r3]
 1066 02fc 7A8A     	 ldrh r2,[r7,#18]
 1067 02fe 9A42     	 cmp r2,r3
 1068 0300 17D1     	 bne .L68
 1069              	.L67:
 600:../SSC/Src/ecatslv.c ****                         )
 601:../SSC/Src/ecatslv.c ****                     {
 602:../SSC/Src/ecatslv.c ****                         /* addresses match */
 603:../SSC/Src/ecatslv.c ****                         {
 604:../SSC/Src/ecatslv.c ****                             /* check, if watchdog trigger is enabled */
 605:../SSC/Src/ecatslv.c ****                             if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG
 1070              	 .loc 3 605 0 is_stmt 1
 1071 0302 FB68     	 ldr r3,[r7,#12]
 1072 0304 1B79     	 ldrb r3,[r3,#4]
 1073 0306 03F04003 	 and r3,r3,#64
 1074 030a 002B     	 cmp r3,#0
 1075 030c 03D0     	 beq .L69
 606:../SSC/Src/ecatslv.c ****                             {
 607:../SSC/Src/ecatslv.c ****                                 bWdTrigger = TRUE;
 1076              	 .loc 3 607 0
 1077 030e 274B     	 ldr r3,.L81+12
 1078 0310 0122     	 movs r2,#1
 1079 0312 1A70     	 strb r2,[r3]
 1080 0314 02E0     	 b .L70
 1081              	.L69:
 608:../SSC/Src/ecatslv.c ****                             }
 609:../SSC/Src/ecatslv.c ****                             else
 610:../SSC/Src/ecatslv.c ****                             {
 611:../SSC/Src/ecatslv.c ****                                 bWdTrigger = FALSE;
 1082              	 .loc 3 611 0
 1083 0316 254B     	 ldr r3,.L81+12
 1084 0318 0022     	 movs r2,#0
 1085 031a 1A70     	 strb r2,[r3]
 1086              	.L70:
 612:../SSC/Src/ecatslv.c ****                             }
 613:../SSC/Src/ecatslv.c **** 
 614:../SSC/Src/ecatslv.c ****                             if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MA
 1087              	 .loc 3 614 0
 1088 031c FB68     	 ldr r3,[r7,#12]
 1089 031e 1B79     	 ldrb r3,[r3,#4]
 1090 0320 03F00203 	 and r3,r3,#2
 1091 0324 002B     	 cmp r3,#0
 1092 0326 03D0     	 beq .L71
 615:../SSC/Src/ecatslv.c ****                             {
 616:../SSC/Src/ecatslv.c ****                                 /* outputs are running in 1-Buffer-Mode, reset flag b3BufferMode */
 617:../SSC/Src/ecatslv.c ****                                 b3BufferMode = FALSE;
 1093              	 .loc 3 617 0
 1094 0328 214B     	 ldr r3,.L81+16
 1095 032a 0022     	 movs r2,#0
 1096 032c 1A70     	 strb r2,[r3]
 614:../SSC/Src/ecatslv.c ****                             {
 1097              	 .loc 3 614 0
 1098 032e 03E0     	 b .L72
 1099              	.L71:
 1100 0330 02E0     	 b .L72
 1101              	.L68:
 618:../SSC/Src/ecatslv.c ****                                 }
 619:../SSC/Src/ecatslv.c ****                         }
 620:../SSC/Src/ecatslv.c ****                     }
 621:../SSC/Src/ecatslv.c ****                     else
 622:../SSC/Src/ecatslv.c ****                     {
 623:../SSC/Src/ecatslv.c ****                         /* output address is out of the allowed area or has changed in SAFEOP or OP
 624:../SSC/Src/ecatslv.c ****                         result = SYNCMANCHADDRESS + 1;
 1102              	 .loc 3 624 0
 1103 0332 0223     	 movs r3,#2
 1104 0334 BB75     	 strb r3,[r7,#22]
 1105 0336 03E0     	 b .L73
 1106              	.L72:
 1107 0338 02E0     	 b .L73
 1108              	.L65:
 625:../SSC/Src/ecatslv.c ****                     }
 626:../SSC/Src/ecatslv.c ****                 }
 627:../SSC/Src/ecatslv.c ****                 else
 628:../SSC/Src/ecatslv.c ****                 {
 629:../SSC/Src/ecatslv.c ****                     /* output settings do not match */
 630:../SSC/Src/ecatslv.c ****                     result = SYNCMANCHSETTINGS + 1;
 1109              	 .loc 3 630 0
 1110 033a 0423     	 movs r3,#4
 1111 033c BB75     	 strb r3,[r7,#22]
 595:../SSC/Src/ecatslv.c ****                 {
 1112              	 .loc 3 595 0
 1113 033e 03E0     	 b .L74
 1114              	.L73:
 595:../SSC/Src/ecatslv.c ****                 {
 1115              	 .loc 3 595 0 is_stmt 0 discriminator 4
 1116 0340 02E0     	 b .L74
 1117              	.L64:
 631:../SSC/Src/ecatslv.c ****                 }
 632:../SSC/Src/ecatslv.c ****             }
 633:../SSC/Src/ecatslv.c ****             else
 634:../SSC/Src/ecatslv.c ****             {
 635:../SSC/Src/ecatslv.c ****                 /* output sizes don't match */
 636:../SSC/Src/ecatslv.c ****                 result = SYNCMANCHSIZE + 1;
 1118              	 .loc 3 636 0 is_stmt 1
 1119 0342 0323     	 movs r3,#3
 1120 0344 BB75     	 strb r3,[r7,#22]
 1121 0346 09E0     	 b .L62
 1122              	.L74:
 1123 0348 08E0     	 b .L62
 1124              	.L63:
 637:../SSC/Src/ecatslv.c ****             }
 638:../SSC/Src/ecatslv.c ****         }
 639:../SSC/Src/ecatslv.c ****         else if (SMLength != 0 || nPdOutputSize != 0)
 1125              	 .loc 3 639 0
 1126 034a BB8A     	 ldrh r3,[r7,#20]
 1127 034c 002B     	 cmp r3,#0
 1128 034e 03D1     	 bne .L75
 1129              	 .loc 3 639 0 is_stmt 0 discriminator 1
 1130 0350 134B     	 ldr r3,.L81
 1131 0352 1B88     	 ldrh r3,[r3]
 1132 0354 002B     	 cmp r3,#0
 1133 0356 01D0     	 beq .L62
 1134              	.L75:
 640:../SSC/Src/ecatslv.c ****         {
 641:../SSC/Src/ecatslv.c ****             /* output size is not zero although the SM2 channel is not enabled */
 642:../SSC/Src/ecatslv.c ****             result = SYNCMANCHSIZE + 1;
 1135              	 .loc 3 642 0 is_stmt 1
 1136 0358 0323     	 movs r3,#3
 1137 035a BB75     	 strb r3,[r7,#22]
 1138              	.L62:
 643:../SSC/Src/ecatslv.c ****         }
 644:../SSC/Src/ecatslv.c **** 
 645:../SSC/Src/ecatslv.c ****         if ( result != 0 )
 1139              	 .loc 3 645 0
 1140 035c BB7D     	 ldrb r3,[r7,#22]
 1141 035e 002B     	 cmp r3,#0
 1142 0360 01D0     	 beq .L60
 646:../SSC/Src/ecatslv.c ****         {
 647:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_INVALIDSMOUTCFG;
 1143              	 .loc 3 647 0
 1144 0362 1D23     	 movs r3,#29
 1145 0364 BB75     	 strb r3,[r7,#22]
 1146              	.L60:
 648:../SSC/Src/ecatslv.c ****         }
 649:../SSC/Src/ecatslv.c ****     }
 650:../SSC/Src/ecatslv.c **** 
 651:../SSC/Src/ecatslv.c **** 
 652:../SSC/Src/ecatslv.c ****     if ( result == 0 )
 1147              	 .loc 3 652 0
 1148 0366 BB7D     	 ldrb r3,[r7,#22]
 1149 0368 002B     	 cmp r3,#0
 1150 036a 13D1     	 bne .L76
 653:../SSC/Src/ecatslv.c ****     {
 654:../SSC/Src/ecatslv.c ****         /* the Enable-Byte of the rest of the SM channels has to be read to acknowledge the SM-Chan
 655:../SSC/Src/ecatslv.c ****         for (i = maxChannel; i < nMaxSyncMan; i++)
 1151              	 .loc 3 655 0
 1152 036c FB79     	 ldrb r3,[r7,#7]
 1153 036e FB75     	 strb r3,[r7,#23]
 1154 0370 0BE0     	 b .L77
 1155              	.L78:
 656:../SSC/Src/ecatslv.c ****         {
 657:../SSC/Src/ecatslv.c ****             pSyncMan = GetSyncMan(i);
 1156              	 .loc 3 657 0 discriminator 3
 1157 0372 FB7D     	 ldrb r3,[r7,#23]
 1158 0374 1846     	 mov r0,r3
 1159 0376 FFF7FEFF 	 bl GetSyncMan
 1160 037a F860     	 str r0,[r7,#12]
 658:../SSC/Src/ecatslv.c ****             SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
 1161              	 .loc 3 658 0 discriminator 3
 1162 037c FB68     	 ldr r3,[r7,#12]
 1163 037e 9A79     	 ldrb r2,[r3,#6]
 1164 0380 0C4B     	 ldr r3,.L81+20
 1165 0382 1A70     	 strb r2,[r3]
 655:../SSC/Src/ecatslv.c ****         {
 1166              	 .loc 3 655 0 discriminator 3
 1167 0384 FB7D     	 ldrb r3,[r7,#23]
 1168 0386 0133     	 adds r3,r3,#1
 1169 0388 FB75     	 strb r3,[r7,#23]
 1170              	.L77:
 655:../SSC/Src/ecatslv.c ****         {
 1171              	 .loc 3 655 0 is_stmt 0 discriminator 1
 1172 038a 0B4B     	 ldr r3,.L81+24
 1173 038c 1B78     	 ldrb r3,[r3]
 1174 038e FA7D     	 ldrb r2,[r7,#23]
 1175 0390 9A42     	 cmp r2,r3
 1176 0392 EED3     	 bcc .L78
 1177              	.L76:
 659:../SSC/Src/ecatslv.c ****         }
 660:../SSC/Src/ecatslv.c ****     }
 661:../SSC/Src/ecatslv.c ****     return result;
 1178              	 .loc 3 661 0 is_stmt 1
 1179 0394 BB7D     	 ldrb r3,[r7,#22]
 1180              	.L31:
 662:../SSC/Src/ecatslv.c **** }
 1181              	 .loc 3 662 0
 1182 0396 1846     	 mov r0,r3
 1183 0398 1837     	 adds r7,r7,#24
 1184              	.LCFI47:
 1185              	 .cfi_def_cfa_offset 8
 1186 039a BD46     	 mov sp,r7
 1187              	.LCFI48:
 1188              	 .cfi_def_cfa_register 13
 1189              	 
 1190 039c 80BD     	 pop {r7,pc}
 1191              	.L82:
 1192 039e 00BF     	 .align 2
 1193              	.L81:
 1194 03a0 00000000 	 .word nPdOutputSize
 1195 03a4 00000000 	 .word nAlStatus
 1196 03a8 00000000 	 .word nEscAddrOutputData
 1197 03ac 00000000 	 .word bWdTrigger
 1198 03b0 00000000 	 .word b3BufferMode
 1199 03b4 00000000 	 .word SMActivate
 1200 03b8 00000000 	 .word nMaxSyncMan
 1201              	 .cfi_endproc
 1202              	.LFE185:
 1204              	 .section .text.StartInputHandler,"ax",%progbits
 1205              	 .align 2
 1206              	 .global StartInputHandler
 1207              	 .thumb
 1208              	 .thumb_func
 1210              	StartInputHandler:
 1211              	.LFB186:
 663:../SSC/Src/ecatslv.c **** 
 664:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 665:../SSC/Src/ecatslv.c **** /**
 666:../SSC/Src/ecatslv.c ****  \return    AL Status Code (see ecatslv.h ALSTATUSCODE_....)
 667:../SSC/Src/ecatslv.c **** 
 668:../SSC/Src/ecatslv.c ****  \brief    This function is called in case of the state transition from PREOP to SAFEOP.
 669:../SSC/Src/ecatslv.c ****  |brief  the areas of the Sync Managers will be checked for overlapping,
 670:../SSC/Src/ecatslv.c ****  \brief  the synchronization mode (Free Run, Synchron, Distributed Clocks) is selected,
 671:../SSC/Src/ecatslv.c ****  \brief  the requested cycle time will be checked, the watchdog is started
 672:../SSC/Src/ecatslv.c ****  \brief  and the AL Event Mask register will be set
 673:../SSC/Src/ecatslv.c **** 
 674:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 675:../SSC/Src/ecatslv.c **** 
 676:../SSC/Src/ecatslv.c **** UINT16 StartInputHandler(void)
 677:../SSC/Src/ecatslv.c **** {
 1212              	 .loc 3 677 0
 1213              	 .cfi_startproc
 1214              	 
 1215              	 
 1216 0000 80B5     	 push {r7,lr}
 1217              	.LCFI49:
 1218              	 .cfi_def_cfa_offset 8
 1219              	 .cfi_offset 7,-8
 1220              	 .cfi_offset 14,-4
 1221 0002 8EB0     	 sub sp,sp,#56
 1222              	.LCFI50:
 1223              	 .cfi_def_cfa_offset 64
 1224 0004 00AF     	 add r7,sp,#0
 1225              	.LCFI51:
 1226              	 .cfi_def_cfa_register 7
 678:../SSC/Src/ecatslv.c ****     TSYNCMAN ESCMEM * pSyncMan;
 679:../SSC/Src/ecatslv.c ****     UINT8        dcControl;
 680:../SSC/Src/ecatslv.c **** 
 681:../SSC/Src/ecatslv.c ****     UINT16     wdiv = 0;
 1227              	 .loc 3 681 0
 1228 0006 0023     	 movs r3,#0
 1229 0008 BB85     	 strh r3,[r7,#44]
 682:../SSC/Src/ecatslv.c ****     UINT16     wd = 0;
 1230              	 .loc 3 682 0
 1231 000a 0023     	 movs r3,#0
 1232 000c 7B85     	 strh r3,[r7,#42]
 683:../SSC/Src/ecatslv.c ****     UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
 1233              	 .loc 3 683 0
 1234 000e 0023     	 movs r3,#0
 1235 0010 7B62     	 str r3,[r7,#36]
 684:../SSC/Src/ecatslv.c ****     UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle s
 1236              	 .loc 3 684 0
 1237 0012 0023     	 movs r3,#0
 1238 0014 3B62     	 str r3,[r7,#32]
 685:../SSC/Src/ecatslv.c ****     BOOL bSubordinatedCycles = FALSE;
 1239              	 .loc 3 685 0
 1240 0016 0023     	 movs r3,#0
 1241 0018 87F83730 	 strb r3,[r7,#55]
 686:../SSC/Src/ecatslv.c **** 
 687:../SSC/Src/ecatslv.c ****     UINT16    nPdInputBuffer = 3;
 1242              	 .loc 3 687 0
 1243 001c 0323     	 movs r3,#3
 1244 001e BB86     	 strh r3,[r7,#52]
 688:../SSC/Src/ecatslv.c **** 
 689:../SSC/Src/ecatslv.c ****     UINT16    nPdOutputBuffer = 3;
 1245              	 .loc 3 689 0
 1246 0020 0323     	 movs r3,#3
 1247 0022 7B86     	 strh r3,[r7,#50]
 690:../SSC/Src/ecatslv.c **** 
 691:../SSC/Src/ecatslv.c ****     UINT16 SyncType0x1C32 = 0; /* Helper variable for sync type for SM2 (required if no CoE is supp
 1248              	 .loc 3 691 0
 1249 0024 0023     	 movs r3,#0
 1250 0026 3B86     	 strh r3,[r7,#48]
 692:../SSC/Src/ecatslv.c ****     UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supp
 1251              	 .loc 3 692 0
 1252 0028 0023     	 movs r3,#0
 1253 002a FB85     	 strh r3,[r7,#46]
 693:../SSC/Src/ecatslv.c **** 
 694:../SSC/Src/ecatslv.c ****     UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */
 1254              	 .loc 3 694 0
 1255 002c 4FF6FF73 	 movw r3,#65535
 1256 0030 FB83     	 strh r3,[r7,#30]
 695:../SSC/Src/ecatslv.c **** 
 696:../SSC/Src/ecatslv.c ****     u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
 1257              	 .loc 3 696 0
 1258 0032 9E4B     	 ldr r3,.L157
 1259 0034 9A89     	 ldrh r2,[r3,#12]
 1260 0036 FB8B     	 ldrh r3,[r7,#30]
 1261 0038 1340     	 ands r3,r3,r2
 1262 003a FB83     	 strh r3,[r7,#30]
 697:../SSC/Src/ecatslv.c ****     u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
 1263              	 .loc 3 697 0
 1264 003c 9C4B     	 ldr r3,.L157+4
 1265 003e 9A89     	 ldrh r2,[r3,#12]
 1266 0040 FB8B     	 ldrh r3,[r7,#30]
 1267 0042 1340     	 ands r3,r3,r2
 1268 0044 FB83     	 strh r3,[r7,#30]
 698:../SSC/Src/ecatslv.c **** 
 699:../SSC/Src/ecatslv.c ****     u16ALEventMask = 0;
 1269              	 .loc 3 699 0
 1270 0046 9B4B     	 ldr r3,.L157+8
 1271 0048 0022     	 movs r2,#0
 1272 004a 1A80     	 strh r2,[r3]
 700:../SSC/Src/ecatslv.c **** 
 701:../SSC/Src/ecatslv.c **** 
 702:../SSC/Src/ecatslv.c ****     /* 
 703:../SSC/Src/ecatslv.c ****         --- Check if SyncManager areas overlapping --- 
 704:../SSC/Src/ecatslv.c ****     */
 705:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 1273              	 .loc 3 705 0
 1274 004c 9A4B     	 ldr r3,.L157+12
 1275 004e 0022     	 movs r2,#0
 1276 0050 1A70     	 strb r2,[r3]
 706:../SSC/Src/ecatslv.c **** 
 707:../SSC/Src/ecatslv.c ****     /* get a pointer to the Sync Manager Channel 2 (Outputs) */
 708:../SSC/Src/ecatslv.c ****     pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
 1277              	 .loc 3 708 0
 1278 0052 0220     	 movs r0,#2
 1279 0054 FFF7FEFF 	 bl GetSyncMan
 1280 0058 B861     	 str r0,[r7,#24]
 709:../SSC/Src/ecatslv.c ****     /* store the address of the Sync Manager Channel 2 (Outputs) */
 710:../SSC/Src/ecatslv.c ****     nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
 1281              	 .loc 3 710 0
 1282 005a BB69     	 ldr r3,[r7,#24]
 1283 005c 1B88     	 ldrh r3,[r3]
 1284 005e 9AB2     	 uxth r2,r3
 1285 0060 964B     	 ldr r3,.L157+16
 1286 0062 1A80     	 strh r2,[r3]
 711:../SSC/Src/ecatslv.c ****     /* get the number of output buffer used for calculating the address areas */
 712:../SSC/Src/ecatslv.c ****     if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
 1287              	 .loc 3 712 0
 1288 0064 BB69     	 ldr r3,[r7,#24]
 1289 0066 1B79     	 ldrb r3,[r3,#4]
 1290 0068 03F00203 	 and r3,r3,#2
 1291 006c 002B     	 cmp r3,#0
 1292 006e 01D0     	 beq .L84
 713:../SSC/Src/ecatslv.c ****     {
 714:../SSC/Src/ecatslv.c ****        nPdOutputBuffer = 1;
 1293              	 .loc 3 714 0
 1294 0070 0123     	 movs r3,#1
 1295 0072 7B86     	 strh r3,[r7,#50]
 1296              	.L84:
 715:../SSC/Src/ecatslv.c ****     }
 716:../SSC/Src/ecatslv.c **** 
 717:../SSC/Src/ecatslv.c **** 
 718:../SSC/Src/ecatslv.c ****     /* get a pointer to the Sync Manager Channel 3 (Inputs) */
 719:../SSC/Src/ecatslv.c ****     pSyncMan = GetSyncMan(PROCESS_DATA_IN);
 1297              	 .loc 3 719 0
 1298 0074 0320     	 movs r0,#3
 1299 0076 FFF7FEFF 	 bl GetSyncMan
 1300 007a B861     	 str r0,[r7,#24]
 720:../SSC/Src/ecatslv.c ****     /* store the address of the Sync Manager Channel 3 (Inputs)*/
 721:../SSC/Src/ecatslv.c ****     nEscAddrInputData = pSyncMan->PhysicalStartAddress;
 1301              	 .loc 3 721 0
 1302 007c BB69     	 ldr r3,[r7,#24]
 1303 007e 1B88     	 ldrh r3,[r3]
 1304 0080 9AB2     	 uxth r2,r3
 1305 0082 8F4B     	 ldr r3,.L157+20
 1306 0084 1A80     	 strh r2,[r3]
 722:../SSC/Src/ecatslv.c **** 
 723:../SSC/Src/ecatslv.c **** 
 724:../SSC/Src/ecatslv.c ****     /* get the number of input buffer used for calculating the address areas */
 725:../SSC/Src/ecatslv.c ****     if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
 1307              	 .loc 3 725 0
 1308 0086 BB69     	 ldr r3,[r7,#24]
 1309 0088 1B79     	 ldrb r3,[r3,#4]
 1310 008a 03F00203 	 and r3,r3,#2
 1311 008e 002B     	 cmp r3,#0
 1312 0090 01D0     	 beq .L85
 726:../SSC/Src/ecatslv.c ****     {
 727:../SSC/Src/ecatslv.c ****         nPdInputBuffer = 1;
 1313              	 .loc 3 727 0
 1314 0092 0123     	 movs r3,#1
 1315 0094 BB86     	 strh r3,[r7,#52]
 1316              	.L85:
 728:../SSC/Src/ecatslv.c ****     }
 729:../SSC/Src/ecatslv.c ****     /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
 730:../SSC/Src/ecatslv.c ****        the Sync Manager memory areas for the Mailbox */
 731:../SSC/Src/ecatslv.c **** 
 732:../SSC/Src/ecatslv.c ****     if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputD
 1317              	 .loc 3 732 0
 1318 0096 8A4B     	 ldr r3,.L157+20
 1319 0098 1B88     	 ldrh r3,[r3]
 1320 009a 1A46     	 mov r2,r3
 1321 009c 894B     	 ldr r3,.L157+24
 1322 009e 1B88     	 ldrh r3,[r3]
 1323 00a0 1946     	 mov r1,r3
 1324 00a2 BB8E     	 ldrh r3,[r7,#52]
 1325 00a4 03FB01F3 	 mul r3,r3,r1
 1326 00a8 1344     	 add r3,r3,r2
 1327 00aa 874A     	 ldr r2,.L157+28
 1328 00ac 1288     	 ldrh r2,[r2]
 1329 00ae 9342     	 cmp r3,r2
 1330 00b0 0ADD     	 ble .L86
 1331              	 .loc 3 732 0 is_stmt 0 discriminator 1
 1332 00b2 834B     	 ldr r3,.L157+20
 1333 00b4 1B88     	 ldrh r3,[r3]
 1334 00b6 1A46     	 mov r2,r3
 1335 00b8 834B     	 ldr r3,.L157+28
 1336 00ba 1B88     	 ldrh r3,[r3]
 1337 00bc 1946     	 mov r1,r3
 1338 00be 834B     	 ldr r3,.L157+32
 1339 00c0 1B88     	 ldrh r3,[r3]
 1340 00c2 0B44     	 add r3,r3,r1
 1341 00c4 9A42     	 cmp r2,r3
 1342 00c6 18DB     	 blt .L87
 1343              	.L86:
 733:../SSC/Src/ecatslv.c ****        || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrI
 1344              	 .loc 3 733 0 is_stmt 1
 1345 00c8 7D4B     	 ldr r3,.L157+20
 1346 00ca 1B88     	 ldrh r3,[r3]
 1347 00cc 1A46     	 mov r2,r3
 1348 00ce 7D4B     	 ldr r3,.L157+24
 1349 00d0 1B88     	 ldrh r3,[r3]
 1350 00d2 1946     	 mov r1,r3
 1351 00d4 BB8E     	 ldrh r3,[r7,#52]
 1352 00d6 03FB01F3 	 mul r3,r3,r1
 1353 00da 1344     	 add r3,r3,r2
 1354 00dc 7C4A     	 ldr r2,.L157+36
 1355 00de 1288     	 ldrh r2,[r2]
 1356 00e0 9342     	 cmp r3,r2
 1357 00e2 0CDD     	 ble .L88
 1358              	 .loc 3 733 0 is_stmt 0 discriminator 1
 1359 00e4 764B     	 ldr r3,.L157+20
 1360 00e6 1B88     	 ldrh r3,[r3]
 1361 00e8 1A46     	 mov r2,r3
 1362 00ea 794B     	 ldr r3,.L157+36
 1363 00ec 1B88     	 ldrh r3,[r3]
 1364 00ee 1946     	 mov r1,r3
 1365 00f0 784B     	 ldr r3,.L157+40
 1366 00f2 1B88     	 ldrh r3,[r3]
 1367 00f4 0B44     	 add r3,r3,r1
 1368 00f6 9A42     	 cmp r2,r3
 1369 00f8 01DA     	 bge .L88
 1370              	.L87:
 734:../SSC/Src/ecatslv.c ****         )
 735:../SSC/Src/ecatslv.c ****     {
 736:../SSC/Src/ecatslv.c ****         return ALSTATUSCODE_INVALIDSMINCFG;
 1371              	 .loc 3 736 0 is_stmt 1
 1372 00fa 1E23     	 movs r3,#30
 1373 00fc 25E3     	 b .L89
 1374              	.L88:
 737:../SSC/Src/ecatslv.c ****     }
 738:../SSC/Src/ecatslv.c **** 
 739:../SSC/Src/ecatslv.c ****     if (
 740:../SSC/Src/ecatslv.c ****         ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOut
 1375              	 .loc 3 740 0
 1376 00fe 6F4B     	 ldr r3,.L157+16
 1377 0100 1B88     	 ldrh r3,[r3]
 1378 0102 1A46     	 mov r2,r3
 1379 0104 744B     	 ldr r3,.L157+44
 1380 0106 1B88     	 ldrh r3,[r3]
 1381 0108 1946     	 mov r1,r3
 1382 010a 7B8E     	 ldrh r3,[r7,#50]
 1383 010c 03FB01F3 	 mul r3,r3,r1
 1384 0110 1344     	 add r3,r3,r2
 1385 0112 6D4A     	 ldr r2,.L157+28
 1386 0114 1288     	 ldrh r2,[r2]
 739:../SSC/Src/ecatslv.c ****         ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOut
 1387              	 .loc 3 739 0
 1388 0116 9342     	 cmp r3,r2
 1389 0118 0ADD     	 ble .L90
 1390              	 .loc 3 740 0
 1391 011a 684B     	 ldr r3,.L157+16
 1392 011c 1B88     	 ldrh r3,[r3]
 1393 011e 1A46     	 mov r2,r3
 1394 0120 694B     	 ldr r3,.L157+28
 1395 0122 1B88     	 ldrh r3,[r3]
 1396 0124 1946     	 mov r1,r3
 1397 0126 694B     	 ldr r3,.L157+32
 1398 0128 1B88     	 ldrh r3,[r3]
 1399 012a 0B44     	 add r3,r3,r1
 1400 012c 9A42     	 cmp r2,r3
 1401 012e 31DB     	 blt .L91
 1402              	.L90:
 741:../SSC/Src/ecatslv.c ****         ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAd
 1403              	 .loc 3 741 0
 1404 0130 624B     	 ldr r3,.L157+16
 1405 0132 1B88     	 ldrh r3,[r3]
 1406 0134 1A46     	 mov r2,r3
 1407 0136 684B     	 ldr r3,.L157+44
 1408 0138 1B88     	 ldrh r3,[r3]
 1409 013a 1946     	 mov r1,r3
 1410 013c 7B8E     	 ldrh r3,[r7,#50]
 1411 013e 03FB01F3 	 mul r3,r3,r1
 1412 0142 1344     	 add r3,r3,r2
 1413 0144 624A     	 ldr r2,.L157+36
 1414 0146 1288     	 ldrh r2,[r2]
 1415 0148 9342     	 cmp r3,r2
 1416 014a 0ADD     	 ble .L92
 1417              	 .loc 3 741 0 is_stmt 0 discriminator 1
 1418 014c 5B4B     	 ldr r3,.L157+16
 1419 014e 1B88     	 ldrh r3,[r3]
 1420 0150 1A46     	 mov r2,r3
 1421 0152 5F4B     	 ldr r3,.L157+36
 1422 0154 1B88     	 ldrh r3,[r3]
 1423 0156 1946     	 mov r1,r3
 1424 0158 5E4B     	 ldr r3,.L157+40
 1425 015a 1B88     	 ldrh r3,[r3]
 1426 015c 0B44     	 add r3,r3,r1
 1427 015e 9A42     	 cmp r2,r3
 1428 0160 18DB     	 blt .L91
 1429              	.L92:
 742:../SSC/Src/ecatslv.c ****         ||
 743:../SSC/Src/ecatslv.c ****         ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOut
 1430              	 .loc 3 743 0 is_stmt 1
 1431 0162 564B     	 ldr r3,.L157+16
 1432 0164 1B88     	 ldrh r3,[r3]
 1433 0166 1A46     	 mov r2,r3
 1434 0168 5B4B     	 ldr r3,.L157+44
 1435 016a 1B88     	 ldrh r3,[r3]
 1436 016c 1946     	 mov r1,r3
 1437 016e 7B8E     	 ldrh r3,[r7,#50]
 1438 0170 03FB01F3 	 mul r3,r3,r1
 1439 0174 1344     	 add r3,r3,r2
 1440 0176 524A     	 ldr r2,.L157+20
 1441 0178 1288     	 ldrh r2,[r2]
 742:../SSC/Src/ecatslv.c ****         ||
 1442              	 .loc 3 742 0
 1443 017a 9342     	 cmp r3,r2
 1444 017c 0CDD     	 ble .L93
 1445              	 .loc 3 743 0
 1446 017e 4F4B     	 ldr r3,.L157+16
 1447 0180 1B88     	 ldrh r3,[r3]
 1448 0182 1A46     	 mov r2,r3
 1449 0184 4E4B     	 ldr r3,.L157+20
 1450 0186 1B88     	 ldrh r3,[r3]
 1451 0188 1946     	 mov r1,r3
 1452 018a 4E4B     	 ldr r3,.L157+24
 1453 018c 1B88     	 ldrh r3,[r3]
 1454 018e 0B44     	 add r3,r3,r1
 1455 0190 9A42     	 cmp r2,r3
 1456 0192 01DA     	 bge .L93
 1457              	.L91:
 744:../SSC/Src/ecatslv.c ****         )
 745:../SSC/Src/ecatslv.c ****     {
 746:../SSC/Src/ecatslv.c **** 
 747:../SSC/Src/ecatslv.c ****         /* Sync Manager Channel 2 memory area (Outputs) overlaps the Sync Manager memory areas for 
 748:../SSC/Src/ecatslv.c ****            or the Sync Manager Channel 3 memory area (Inputs) */
 749:../SSC/Src/ecatslv.c ****         return ALSTATUSCODE_INVALIDSMOUTCFG;
 1458              	 .loc 3 749 0
 1459 0194 1D23     	 movs r3,#29
 1460 0196 D8E2     	 b .L89
 1461              	.L93:
 750:../SSC/Src/ecatslv.c ****     }
 751:../SSC/Src/ecatslv.c **** 
 752:../SSC/Src/ecatslv.c ****     /* 
 753:../SSC/Src/ecatslv.c ****         --- Check configured synchronisation ---
 754:../SSC/Src/ecatslv.c ****     */
 755:../SSC/Src/ecatslv.c **** 
 756:../SSC/Src/ecatslv.c ****     /* Get the DC Control/Activation register value*/
 757:../SSC/Src/ecatslv.c ****     /*Read register 0x981 (corresponding masks are adapted)*/
 758:../SSC/Src/ecatslv.c ****     HW_EscReadByte(dcControl, ESC_DC_SYNC_ACTIVATION_OFFSET);
 1462              	 .loc 3 758 0
 1463 0198 504B     	 ldr r3,.L157+48
 1464 019a 1B78     	 ldrb r3,[r3]
 1465 019c FB75     	 strb r3,[r7,#23]
 759:../SSC/Src/ecatslv.c **** 
 760:../SSC/Src/ecatslv.c ****     // Cycle time for Sync0
 761:../SSC/Src/ecatslv.c ****         HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
 1466              	 .loc 3 761 0
 1467 019e 504B     	 ldr r3,.L157+52
 1468 01a0 1B68     	 ldr r3,[r3]
 1469 01a2 7B62     	 str r3,[r7,#36]
 762:../SSC/Src/ecatslv.c ****         cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);
 763:../SSC/Src/ecatslv.c **** 
 764:../SSC/Src/ecatslv.c ****     // Cycle time for Sync1
 765:../SSC/Src/ecatslv.c ****         HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
 1470              	 .loc 3 765 0
 1471 01a4 4F4B     	 ldr r3,.L157+56
 1472 01a6 1B68     	 ldr r3,[r3]
 1473 01a8 3B62     	 str r3,[r7,#32]
 766:../SSC/Src/ecatslv.c ****         shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);
 767:../SSC/Src/ecatslv.c **** 
 768:../SSC/Src/ecatslv.c **** 
 769:../SSC/Src/ecatslv.c ****     SyncType0x1C32 = sSyncManOutPar.u16SyncType;
 1474              	 .loc 3 769 0
 1475 01aa 404B     	 ldr r3,.L157
 1476 01ac 5B88     	 ldrh r3,[r3,#2]
 1477 01ae 3B86     	 strh r3,[r7,#48]
 770:../SSC/Src/ecatslv.c ****     SyncType0x1C33 = sSyncManInPar.u16SyncType;
 1478              	 .loc 3 770 0
 1479 01b0 3F4B     	 ldr r3,.L157+4
 1480 01b2 5B88     	 ldrh r3,[r3,#2]
 1481 01b4 FB85     	 strh r3,[r7,#46]
 771:../SSC/Src/ecatslv.c **** 
 772:../SSC/Src/ecatslv.c **** 
 773:../SSC/Src/ecatslv.c **** 
 774:../SSC/Src/ecatslv.c ****     /* check general DC register plausibility and if configuration is supported
 775:../SSC/Src/ecatslv.c ****        - 0x981 DC Active
 776:../SSC/Src/ecatslv.c ****        - 0x9A0:0x9A3 Sync0 Cycle
 777:../SSC/Src/ecatslv.c ****        - 0x9A4:0x9A7 Sync1 Cycle
 778:../SSC/Src/ecatslv.c ****     */
 779:../SSC/Src/ecatslv.c ****     if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
 1482              	 .loc 3 779 0
 1483 01b6 FB7D     	 ldrb r3,[r7,#23]
 1484 01b8 03F00903 	 and r3,r3,#9
 1485 01bc 002B     	 cmp r3,#0
 1486 01be 5CD0     	 beq .L94
 780:../SSC/Src/ecatslv.c ****     {
 781:../SSC/Src/ecatslv.c ****         /* DC unit is active at least one Sync signal shall be generated */
 782:../SSC/Src/ecatslv.c ****         if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
 1487              	 .loc 3 782 0
 1488 01c0 FB7D     	 ldrb r3,[r7,#23]
 1489 01c2 03F00603 	 and r3,r3,#6
 1490 01c6 002B     	 cmp r3,#0
 1491 01c8 01D1     	 bne .L95
 783:../SSC/Src/ecatslv.c ****         {
 784:../SSC/Src/ecatslv.c ****             return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1492              	 .loc 3 784 0
 1493 01ca 3023     	 movs r3,#48
 1494 01cc BDE2     	 b .L89
 1495              	.L95:
 785:../SSC/Src/ecatslv.c ****         }
 786:../SSC/Src/ecatslv.c **** 
 787:../SSC/Src/ecatslv.c ****         /* If Sync1 shall only be active if also Sync0 will be generated*/
 788:../SSC/Src/ecatslv.c ****         if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 1496              	 .loc 3 788 0
 1497 01ce FB7D     	 ldrb r3,[r7,#23]
 1498 01d0 03F00203 	 and r3,r3,#2
 1499 01d4 002B     	 cmp r3,#0
 1500 01d6 06D1     	 bne .L96
 789:../SSC/Src/ecatslv.c ****             && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
 1501              	 .loc 3 789 0
 1502 01d8 FB7D     	 ldrb r3,[r7,#23]
 1503 01da 03F00403 	 and r3,r3,#4
 1504 01de 002B     	 cmp r3,#0
 1505 01e0 01D0     	 beq .L96
 790:../SSC/Src/ecatslv.c ****         {
 791:../SSC/Src/ecatslv.c ****             return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1506              	 .loc 3 791 0
 1507 01e2 3023     	 movs r3,#48
 1508 01e4 B1E2     	 b .L89
 1509              	.L96:
 792:../SSC/Src/ecatslv.c ****         }
 793:../SSC/Src/ecatslv.c **** 
 794:../SSC/Src/ecatslv.c ****         if(u16MinSuppSyncType != 0)
 1510              	 .loc 3 794 0
 1511 01e6 FB8B     	 ldrh r3,[r7,#30]
 1512 01e8 002B     	 cmp r3,#0
 1513 01ea 15D0     	 beq .L97
 795:../SSC/Src/ecatslv.c ****         {
 796:../SSC/Src/ecatslv.c ****             if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_AC
 1514              	 .loc 3 796 0
 1515 01ec FB8B     	 ldrh r3,[r7,#30]
 1516 01ee 03F00403 	 and r3,r3,#4
 1517 01f2 002B     	 cmp r3,#0
 1518 01f4 04D1     	 bne .L98
 1519              	 .loc 3 796 0 is_stmt 0 discriminator 1
 1520 01f6 FB7D     	 ldrb r3,[r7,#23]
 1521 01f8 03F00203 	 and r3,r3,#2
 1522 01fc 002B     	 cmp r3,#0
 1523 01fe 09D1     	 bne .L99
 1524              	.L98:
 797:../SSC/Src/ecatslv.c ****                 ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1
 1525              	 .loc 3 797 0 is_stmt 1
 1526 0200 FB8B     	 ldrh r3,[r7,#30]
 1527 0202 03F00803 	 and r3,r3,#8
 1528 0206 002B     	 cmp r3,#0
 1529 0208 06D1     	 bne .L97
 1530              	 .loc 3 797 0 is_stmt 0 discriminator 1
 1531 020a FB7D     	 ldrb r3,[r7,#23]
 1532 020c 03F00403 	 and r3,r3,#4
 1533 0210 002B     	 cmp r3,#0
 1534 0212 01D0     	 beq .L97
 1535              	.L99:
 798:../SSC/Src/ecatslv.c ****             {
 799:../SSC/Src/ecatslv.c ****                 /* Sync0 is not supported but will be generated*/
 800:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_DCINVALIDSYNCCFG;                   
 1536              	 .loc 3 800 0 is_stmt 1
 1537 0214 3023     	 movs r3,#48
 1538 0216 98E2     	 b .L89
 1539              	.L97:
 1540              	.LBB2:
 801:../SSC/Src/ecatslv.c ****     }
 802:../SSC/Src/ecatslv.c ****         }
 803:../SSC/Src/ecatslv.c **** 
 804:../SSC/Src/ecatslv.c ****         {
 805:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT1*/
 806:../SSC/Src/ecatslv.c ****             UINT32 curMinCycleTime = MIN_PD_CYCLE_TIME;
 1541              	 .loc 3 806 0
 1542 0218 334B     	 ldr r3,.L157+60
 1543 021a 3B61     	 str r3,[r7,#16]
 807:../SSC/Src/ecatslv.c ****             curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
 1544              	 .loc 3 807 0
 1545 021c 234B     	 ldr r3,.L157
 1546 021e 1B69     	 ldr r3,[r3,#16]
 1547 0220 3B61     	 str r3,[r7,#16]
 808:../SSC/Src/ecatslv.c **** 
 809:../SSC/Src/ecatslv.c ****             /*Check if Sync0 cycle time is supported*/
 810:../SSC/Src/ecatslv.c ****             if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD
 1548              	 .loc 3 810 0
 1549 0222 7B6A     	 ldr r3,[r7,#36]
 1550 0224 002B     	 cmp r3,#0
 1551 0226 09D0     	 beq .L100
 1552              	 .loc 3 810 0 is_stmt 0 discriminator 1
 1553 0228 7A6A     	 ldr r2,[r7,#36]
 1554 022a 3B69     	 ldr r3,[r7,#16]
 1555 022c 9A42     	 cmp r2,r3
 1556 022e 03D3     	 bcc .L101
 1557              	 .loc 3 810 0 discriminator 2
 1558 0230 7B6A     	 ldr r3,[r7,#36]
 1559 0232 2E4A     	 ldr r2,.L157+64
 1560 0234 9342     	 cmp r3,r2
 1561 0236 01D9     	 bls .L100
 1562              	.L101:
 811:../SSC/Src/ecatslv.c ****             {
 812:../SSC/Src/ecatslv.c ****                     return ALSTATUSCODE_DCSYNC0CYCLETIME;
 1563              	 .loc 3 812 0 is_stmt 1
 1564 0238 3623     	 movs r3,#54
 1565 023a 86E2     	 b .L89
 1566              	.L100:
 1567              	.LBE2:
 813:../SSC/Src/ecatslv.c ****             }
 814:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT1*/
 815:../SSC/Src/ecatslv.c ****         }
 816:../SSC/Src/ecatslv.c **** 
 817:../SSC/Src/ecatslv.c **** 
 818:../SSC/Src/ecatslv.c ****         /* Check if Subordinated cycles are configured */
 819:../SSC/Src/ecatslv.c ****         if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK)
 1568              	 .loc 3 819 0
 1569 023c FB7D     	 ldrb r3,[r7,#23]
 1570 023e 03F00203 	 and r3,r3,#2
 1571 0242 002B     	 cmp r3,#0
 1572 0244 0ED0     	 beq .L102
 1573              	 .loc 3 819 0 is_stmt 0 discriminator 1
 1574 0246 FB7D     	 ldrb r3,[r7,#23]
 1575 0248 03F00403 	 and r3,r3,#4
 1576 024c 002B     	 cmp r3,#0
 1577 024e 09D0     	 beq .L102
 820:../SSC/Src/ecatslv.c ****         {
 821:../SSC/Src/ecatslv.c ****             /* For Subordinated cycles both Sync signals shall be active and Sync0 is not configure
 822:../SSC/Src/ecatslv.c ****             if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
 1578              	 .loc 3 822 0 is_stmt 1
 1579 0250 3B6A     	 ldr r3,[r7,#32]
 1580 0252 002B     	 cmp r3,#0
 1581 0254 06D0     	 beq .L102
 1582              	 .loc 3 822 0 is_stmt 0 discriminator 1
 1583 0256 3A6A     	 ldr r2,[r7,#32]
 1584 0258 7B6A     	 ldr r3,[r7,#36]
 1585 025a 9A42     	 cmp r2,r3
 1586 025c 02D3     	 bcc .L102
 823:../SSC/Src/ecatslv.c ****             {
 824:../SSC/Src/ecatslv.c ****                 bSubordinatedCycles = TRUE;
 1587              	 .loc 3 824 0 is_stmt 1
 1588 025e 0123     	 movs r3,#1
 1589 0260 87F83730 	 strb r3,[r7,#55]
 1590              	.L102:
 825:../SSC/Src/ecatslv.c ****             }
 826:../SSC/Src/ecatslv.c ****         }
 827:../SSC/Src/ecatslv.c **** 
 828:../SSC/Src/ecatslv.c ****         /* Dump an error if subordinated cycles are configured but not supported */
 829:../SSC/Src/ecatslv.c ****         if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
 1591              	 .loc 3 829 0
 1592 0264 97F83730 	 ldrb r3,[r7,#55]
 1593 0268 002B     	 cmp r3,#0
 1594 026a 06D0     	 beq .L94
 1595              	 .loc 3 829 0 is_stmt 0 discriminator 1
 1596 026c FB8B     	 ldrh r3,[r7,#30]
 1597 026e 03F01003 	 and r3,r3,#16
 1598 0272 002B     	 cmp r3,#0
 1599 0274 01D1     	 bne .L94
 830:../SSC/Src/ecatslv.c ****         {
 831:../SSC/Src/ecatslv.c ****              return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1600              	 .loc 3 831 0 is_stmt 1
 1601 0276 3023     	 movs r3,#48
 1602 0278 67E2     	 b .L89
 1603              	.L94:
 832:../SSC/Src/ecatslv.c ****         }
 833:../SSC/Src/ecatslv.c ****     }
 834:../SSC/Src/ecatslv.c **** 
 835:../SSC/Src/ecatslv.c **** 
 836:../SSC/Src/ecatslv.c ****     /*
 837:../SSC/Src/ecatslv.c ****         Check if the user configured Sync Type matches the DC register values (if the Sync Type is 
 838:../SSC/Src/ecatslv.c ****     */
 839:../SSC/Src/ecatslv.c ****     if(bSyncSetByUser)
 1604              	 .loc 3 839 0
 1605 027a 1D4B     	 ldr r3,.L157+68
 1606 027c 1B78     	 ldrb r3,[r3]
 1607 027e 002B     	 cmp r3,#0
 1608 0280 52D0     	 beq .L103
 840:../SSC/Src/ecatslv.c ****     {
 841:../SSC/Src/ecatslv.c ****         if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
 1609              	 .loc 3 841 0
 1610 0282 FB7D     	 ldrb r3,[r7,#23]
 1611 0284 03F00903 	 and r3,r3,#9
 1612 0288 002B     	 cmp r3,#0
 1613 028a 33D1     	 bne .L104
 842:../SSC/Src/ecatslv.c ****         {
 843:../SSC/Src/ecatslv.c ****             /* DC out unit not enabled => no DC mode shall be set */
 844:../SSC/Src/ecatslv.c ****             if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 1614              	 .loc 3 844 0
 1615 028c 3B8E     	 ldrh r3,[r7,#48]
 1616 028e 022B     	 cmp r3,#2
 1617 0290 09D0     	 beq .L105
 1618              	 .loc 3 844 0 is_stmt 0 discriminator 1
 1619 0292 3B8E     	 ldrh r3,[r7,#48]
 1620 0294 032B     	 cmp r3,#3
 1621 0296 06D0     	 beq .L105
 845:../SSC/Src/ecatslv.c ****                 ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
 1622              	 .loc 3 845 0 is_stmt 1
 1623 0298 FB8D     	 ldrh r3,[r7,#46]
 1624 029a 022B     	 cmp r3,#2
 1625 029c 03D0     	 beq .L105
 1626              	 .loc 3 845 0 is_stmt 0 discriminator 1
 1627 029e FB8D     	 ldrh r3,[r7,#46]
 1628 02a0 032B     	 cmp r3,#3
 1629 02a2 40F08580 	 bne .L106
 1630              	.L105:
 846:../SSC/Src/ecatslv.c ****             {
 847:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1631              	 .loc 3 847 0 is_stmt 1
 1632 02a6 3023     	 movs r3,#48
 1633 02a8 4FE2     	 b .L89
 1634              	.L158:
 1635 02aa 00BF     	 .align 2
 1636              	.L157:
 1637 02ac 00000000 	 .word sSyncManOutPar
 1638 02b0 00000000 	 .word sSyncManInPar
 1639 02b4 00000000 	 .word u16ALEventMask
 1640 02b8 00000000 	 .word bEcatFirstOutputsReceived
 1641 02bc 00000000 	 .word nEscAddrOutputData
 1642 02c0 00000000 	 .word nEscAddrInputData
 1643 02c4 00000000 	 .word nPdInputSize
 1644 02c8 00000000 	 .word u16EscAddrSendMbx
 1645 02cc 00000000 	 .word u16SendMbxSize
 1646 02d0 00000000 	 .word u16EscAddrReceiveMbx
 1647 02d4 00000000 	 .word u16ReceiveMbxSize
 1648 02d8 00000000 	 .word nPdOutputSize
 1649 02dc 81090154 	 .word 1409354113
 1650 02e0 A0090154 	 .word 1409354144
 1651 02e4 A4090154 	 .word 1409354148
 1652 02e8 48E80100 	 .word 125000
 1653 02ec 000050C3 	 .word -1018167296
 1654 02f0 00000000 	 .word bSyncSetByUser
 1655              	.L104:
 848:../SSC/Src/ecatslv.c ****             }
 849:../SSC/Src/ecatslv.c ****         } //if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 
 850:../SSC/Src/ecatslv.c ****     else
 851:../SSC/Src/ecatslv.c ****     {
 852:../SSC/Src/ecatslv.c ****             if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
 1656              	 .loc 3 852 0
 1657 02f4 FB7D     	 ldrb r3,[r7,#23]
 1658 02f6 03F00403 	 and r3,r3,#4
 1659 02fa 002B     	 cmp r3,#0
 1660 02fc 07D1     	 bne .L107
 853:../SSC/Src/ecatslv.c ****             {
 854:../SSC/Src/ecatslv.c ****                 /* No Sync 1 is generated => No Sync1 Sync Type shall configured*/
 855:../SSC/Src/ecatslv.c ****                 if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
 1661              	 .loc 3 855 0
 1662 02fe 3B8E     	 ldrh r3,[r7,#48]
 1663 0300 032B     	 cmp r3,#3
 1664 0302 02D0     	 beq .L108
 856:../SSC/Src/ecatslv.c ****                     ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
 1665              	 .loc 3 856 0
 1666 0304 FB8D     	 ldrh r3,[r7,#46]
 1667 0306 032B     	 cmp r3,#3
 1668 0308 01D1     	 bne .L107
 1669              	.L108:
 857:../SSC/Src/ecatslv.c ****                 {
 858:../SSC/Src/ecatslv.c ****                     return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1670              	 .loc 3 858 0
 1671 030a 3023     	 movs r3,#48
 1672 030c 1DE2     	 b .L89
 1673              	.L107:
 859:../SSC/Src/ecatslv.c ****                 }
 860:../SSC/Src/ecatslv.c ****             } //if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
 861:../SSC/Src/ecatslv.c **** 
 862:../SSC/Src/ecatslv.c ****             if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 1674              	 .loc 3 862 0
 1675 030e FB7D     	 ldrb r3,[r7,#23]
 1676 0310 03F00203 	 and r3,r3,#2
 1677 0314 002B     	 cmp r3,#0
 1678 0316 4BD1     	 bne .L106
 863:../SSC/Src/ecatslv.c ****             {
 864:../SSC/Src/ecatslv.c ****                 /* No Sync 0 is generated => No Sync0 Sync Type shall configured*/
 865:../SSC/Src/ecatslv.c ****                 if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC0)
 1679              	 .loc 3 865 0
 1680 0318 3B8E     	 ldrh r3,[r7,#48]
 1681 031a 022B     	 cmp r3,#2
 1682 031c 02D0     	 beq .L109
 866:../SSC/Src/ecatslv.c ****                     ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC0))
 1683              	 .loc 3 866 0
 1684 031e FB8D     	 ldrh r3,[r7,#46]
 1685 0320 022B     	 cmp r3,#2
 1686 0322 45D1     	 bne .L106
 1687              	.L109:
 867:../SSC/Src/ecatslv.c ****                 {
 868:../SSC/Src/ecatslv.c ****                     return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1688              	 .loc 3 868 0
 1689 0324 3023     	 movs r3,#48
 1690 0326 10E2     	 b .L89
 1691              	.L103:
 869:../SSC/Src/ecatslv.c ****                 }
 870:../SSC/Src/ecatslv.c ****             } //if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 871:../SSC/Src/ecatslv.c **** 
 872:../SSC/Src/ecatslv.c ****         }
 873:../SSC/Src/ecatslv.c ****     } //if(bSyncSetByUser)
 874:../SSC/Src/ecatslv.c ****     else
 875:../SSC/Src/ecatslv.c ****     {
 876:../SSC/Src/ecatslv.c ****         /* No Sync Type selected by user => Configure Sync Type based on DC register values*/
 877:../SSC/Src/ecatslv.c ****         if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
 1692              	 .loc 3 877 0
 1693 0328 FB7D     	 ldrb r3,[r7,#23]
 1694 032a 03F00903 	 and r3,r3,#9
 1695 032e 002B     	 cmp r3,#0
 1696 0330 1DD1     	 bne .L110
 878:../SSC/Src/ecatslv.c ****         {
 879:../SSC/Src/ecatslv.c ****             /* Activation or auto activation of the Sync Out Unit is disabled => Free Run or SM Syn
 880:../SSC/Src/ecatslv.c **** 
 881:../SSC/Src/ecatslv.c ****             /* AL Event enabled => Configure SM Sync*/
 882:../SSC/Src/ecatslv.c ****             if (nPdOutputSize > 0)
 1697              	 .loc 3 882 0
 1698 0332 954B     	 ldr r3,.L159
 1699 0334 1B88     	 ldrh r3,[r3]
 1700 0336 002B     	 cmp r3,#0
 1701 0338 0BD0     	 beq .L111
 883:../SSC/Src/ecatslv.c ****             {
 884:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
 1702              	 .loc 3 884 0
 1703 033a 0123     	 movs r3,#1
 1704 033c 3B86     	 strh r3,[r7,#48]
 885:../SSC/Src/ecatslv.c ****                 
 886:../SSC/Src/ecatslv.c ****                 if (nPdInputSize > 0)
 1705              	 .loc 3 886 0
 1706 033e 934B     	 ldr r3,.L159+4
 1707 0340 1B88     	 ldrh r3,[r3]
 1708 0342 002B     	 cmp r3,#0
 1709 0344 02D0     	 beq .L112
 887:../SSC/Src/ecatslv.c ****                 {
 888:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
 1710              	 .loc 3 888 0
 1711 0346 2223     	 movs r3,#34
 1712 0348 FB85     	 strh r3,[r7,#46]
 1713 034a 31E0     	 b .L106
 1714              	.L112:
 889:../SSC/Src/ecatslv.c ****                 }
 890:../SSC/Src/ecatslv.c ****                 else
 891:../SSC/Src/ecatslv.c ****                 {
 892:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_FREERUN;
 1715              	 .loc 3 892 0
 1716 034c 0023     	 movs r3,#0
 1717 034e FB85     	 strh r3,[r7,#46]
 1718 0350 2EE0     	 b .L106
 1719              	.L111:
 893:../SSC/Src/ecatslv.c ****                 }
 894:../SSC/Src/ecatslv.c ****             }
 895:../SSC/Src/ecatslv.c ****             else if (nPdInputSize > 0)
 1720              	 .loc 3 895 0
 1721 0352 8E4B     	 ldr r3,.L159+4
 1722 0354 1B88     	 ldrh r3,[r3]
 1723 0356 002B     	 cmp r3,#0
 1724 0358 04D0     	 beq .L115
 896:../SSC/Src/ecatslv.c ****             {
 897:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_FREERUN;
 1725              	 .loc 3 897 0
 1726 035a 0023     	 movs r3,#0
 1727 035c 3B86     	 strh r3,[r7,#48]
 898:../SSC/Src/ecatslv.c ****                 SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
 1728              	 .loc 3 898 0
 1729 035e 0123     	 movs r3,#1
 1730 0360 FB85     	 strh r3,[r7,#46]
 1731 0362 25E0     	 b .L106
 1732              	.L115:
 899:../SSC/Src/ecatslv.c ****             }
 900:../SSC/Src/ecatslv.c ****             else
 901:../SSC/Src/ecatslv.c ****             {
 902:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_FREERUN;
 1733              	 .loc 3 902 0
 1734 0364 0023     	 movs r3,#0
 1735 0366 3B86     	 strh r3,[r7,#48]
 903:../SSC/Src/ecatslv.c ****                 SyncType0x1C33 = SYNCTYPE_FREERUN;
 1736              	 .loc 3 903 0
 1737 0368 0023     	 movs r3,#0
 1738 036a FB85     	 strh r3,[r7,#46]
 1739 036c 20E0     	 b .L106
 1740              	.L110:
 904:../SSC/Src/ecatslv.c ****             }
 905:../SSC/Src/ecatslv.c **** 
 906:../SSC/Src/ecatslv.c ****         }
 907:../SSC/Src/ecatslv.c ****         else
 908:../SSC/Src/ecatslv.c ****         {
 909:../SSC/Src/ecatslv.c ****             if (nPdOutputSize > 0)
 1741              	 .loc 3 909 0
 1742 036e 864B     	 ldr r3,.L159
 1743 0370 1B88     	 ldrh r3,[r3]
 1744 0372 002B     	 cmp r3,#0
 1745 0374 09D0     	 beq .L116
 910:../SSC/Src/ecatslv.c ****             {
 911:../SSC/Src/ecatslv.c ****                 /* Sync Signal generation is active*/
 912:../SSC/Src/ecatslv.c ****                 if (bSubordinatedCycles)
 1746              	 .loc 3 912 0
 1747 0376 97F83730 	 ldrb r3,[r7,#55]
 1748 037a 002B     	 cmp r3,#0
 1749 037c 02D0     	 beq .L117
 913:../SSC/Src/ecatslv.c ****                 {
 914:../SSC/Src/ecatslv.c ****                     SyncType0x1C32 = SYNCTYPE_DCSYNC1;
 1750              	 .loc 3 914 0
 1751 037e 0323     	 movs r3,#3
 1752 0380 3B86     	 strh r3,[r7,#48]
 1753 0382 04E0     	 b .L119
 1754              	.L117:
 915:../SSC/Src/ecatslv.c ****                 }
 916:../SSC/Src/ecatslv.c ****                 else
 917:../SSC/Src/ecatslv.c ****                 {
 918:../SSC/Src/ecatslv.c ****                     SyncType0x1C32 = SYNCTYPE_DCSYNC0;
 1755              	 .loc 3 918 0
 1756 0384 0223     	 movs r3,#2
 1757 0386 3B86     	 strh r3,[r7,#48]
 1758 0388 01E0     	 b .L119
 1759              	.L116:
 919:../SSC/Src/ecatslv.c ****                 }
 920:../SSC/Src/ecatslv.c ****             }
 921:../SSC/Src/ecatslv.c ****             else
 922:../SSC/Src/ecatslv.c ****             {
 923:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_FREERUN;
 1760              	 .loc 3 923 0
 1761 038a 0023     	 movs r3,#0
 1762 038c 3B86     	 strh r3,[r7,#48]
 1763              	.L119:
 924:../SSC/Src/ecatslv.c ****             }
 925:../SSC/Src/ecatslv.c **** 
 926:../SSC/Src/ecatslv.c **** 
 927:../SSC/Src/ecatslv.c ****             if (nPdInputSize > 0)
 1764              	 .loc 3 927 0
 1765 038e 7F4B     	 ldr r3,.L159+4
 1766 0390 1B88     	 ldrh r3,[r3]
 1767 0392 002B     	 cmp r3,#0
 1768 0394 0AD0     	 beq .L120
 928:../SSC/Src/ecatslv.c ****             {
 929:../SSC/Src/ecatslv.c ****                 if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
 1769              	 .loc 3 929 0
 1770 0396 FB7D     	 ldrb r3,[r7,#23]
 1771 0398 03F00403 	 and r3,r3,#4
 1772 039c 002B     	 cmp r3,#0
 1773 039e 02D0     	 beq .L121
 930:../SSC/Src/ecatslv.c ****                 {
 931:../SSC/Src/ecatslv.c ****                     /* If Sync1 is available the inputs will always be mapped with Sync1 */
 932:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_DCSYNC1;
 1774              	 .loc 3 932 0
 1775 03a0 0323     	 movs r3,#3
 1776 03a2 FB85     	 strh r3,[r7,#46]
 1777 03a4 04E0     	 b .L106
 1778              	.L121:
 933:../SSC/Src/ecatslv.c ****                 }
 934:../SSC/Src/ecatslv.c ****                 else
 935:../SSC/Src/ecatslv.c ****                 {
 936:../SSC/Src/ecatslv.c ****                     /* Map Inputs based on Sync0*/
 937:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_DCSYNC0;
 1779              	 .loc 3 937 0
 1780 03a6 0223     	 movs r3,#2
 1781 03a8 FB85     	 strh r3,[r7,#46]
 1782 03aa 01E0     	 b .L106
 1783              	.L120:
 938:../SSC/Src/ecatslv.c ****                 }
 939:../SSC/Src/ecatslv.c ****             }
 940:../SSC/Src/ecatslv.c ****             else
 941:../SSC/Src/ecatslv.c ****             {
 942:../SSC/Src/ecatslv.c ****                 SyncType0x1C33 = SYNCTYPE_FREERUN;
 1784              	 .loc 3 942 0
 1785 03ac 0023     	 movs r3,#0
 1786 03ae FB85     	 strh r3,[r7,#46]
 1787              	.L106:
 943:../SSC/Src/ecatslv.c ****             }
 944:../SSC/Src/ecatslv.c ****         }
 945:../SSC/Src/ecatslv.c ****     }
 946:../SSC/Src/ecatslv.c **** 
 947:../SSC/Src/ecatslv.c ****     /* Update Cycle time entries if DC Sync Mode enabled */
 948:../SSC/Src/ecatslv.c ****     if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 1788              	 .loc 3 948 0
 1789 03b0 3B8E     	 ldrh r3,[r7,#48]
 1790 03b2 032B     	 cmp r3,#3
 1791 03b4 0CD1     	 bne .L123
 949:../SSC/Src/ecatslv.c ****     {
 950:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT1*/
 951:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1792              	 .loc 3 951 0
 1793 03b6 764A     	 ldr r2,.L159+8
 1794 03b8 7B6A     	 ldr r3,[r7,#36]
 1795 03ba 5362     	 str r3,[r2,#36]
 952:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1796              	 .loc 3 952 0
 1797 03bc 744A     	 ldr r2,.L159+8
 1798 03be 7B6A     	 ldr r3,[r7,#36]
 1799 03c0 5360     	 str r3,[r2,#4]
 953:../SSC/Src/ecatslv.c **** 
 954:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1800              	 .loc 3 954 0
 1801 03c2 744A     	 ldr r2,.L159+12
 1802 03c4 7B6A     	 ldr r3,[r7,#36]
 1803 03c6 5362     	 str r3,[r2,#36]
 955:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1804              	 .loc 3 955 0
 1805 03c8 724A     	 ldr r2,.L159+12
 1806 03ca 7B6A     	 ldr r3,[r7,#36]
 1807 03cc 5360     	 str r3,[r2,#4]
 1808 03ce 0EE0     	 b .L124
 1809              	.L123:
 956:../SSC/Src/ecatslv.c ****     }
 957:../SSC/Src/ecatslv.c ****     else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
 1810              	 .loc 3 957 0
 1811 03d0 3B8E     	 ldrh r3,[r7,#48]
 1812 03d2 022B     	 cmp r3,#2
 1813 03d4 0BD1     	 bne .L124
 958:../SSC/Src/ecatslv.c ****     {
 959:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1814              	 .loc 3 959 0
 1815 03d6 6E4A     	 ldr r2,.L159+8
 1816 03d8 7B6A     	 ldr r3,[r7,#36]
 1817 03da 5362     	 str r3,[r2,#36]
 960:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1818              	 .loc 3 960 0
 1819 03dc 6C4A     	 ldr r2,.L159+8
 1820 03de 7B6A     	 ldr r3,[r7,#36]
 1821 03e0 5360     	 str r3,[r2,#4]
 961:../SSC/Src/ecatslv.c **** 
 962:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1822              	 .loc 3 962 0
 1823 03e2 6C4A     	 ldr r2,.L159+12
 1824 03e4 7B6A     	 ldr r3,[r7,#36]
 1825 03e6 5362     	 str r3,[r2,#36]
 963:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1826              	 .loc 3 963 0
 1827 03e8 6A4A     	 ldr r2,.L159+12
 1828 03ea 7B6A     	 ldr r3,[r7,#36]
 1829 03ec 5360     	 str r3,[r2,#4]
 1830              	.L124:
 964:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT1*/
 965:../SSC/Src/ecatslv.c ****     }
 966:../SSC/Src/ecatslv.c **** 
 967:../SSC/Src/ecatslv.c ****     /* Set global flags based on Sync Type */
 968:../SSC/Src/ecatslv.c ****     if ( !b3BufferMode )
 1831              	 .loc 3 968 0
 1832 03ee 6A4B     	 ldr r3,.L159+16
 1833 03f0 1B78     	 ldrb r3,[r3]
 1834 03f2 83F00103 	 eor r3,r3,#1
 1835 03f6 DBB2     	 uxtb r3,r3
 1836 03f8 002B     	 cmp r3,#0
 1837 03fa 07D0     	 beq .L125
 969:../SSC/Src/ecatslv.c ****     {
 970:../SSC/Src/ecatslv.c ****         /* 1-Buffer-Mode configured => For free run it shall be 3Buffer mode*/
 971:../SSC/Src/ecatslv.c ****         if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
 1838              	 .loc 3 971 0
 1839 03fc 3B8E     	 ldrh r3,[r7,#48]
 1840 03fe 002B     	 cmp r3,#0
 1841 0400 02D0     	 beq .L126
 1842              	 .loc 3 971 0 is_stmt 0 discriminator 1
 1843 0402 FB8D     	 ldrh r3,[r7,#46]
 1844 0404 002B     	 cmp r3,#0
 1845 0406 01D1     	 bne .L125
 1846              	.L126:
 972:../SSC/Src/ecatslv.c ****         {
 973:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
 1847              	 .loc 3 973 0 is_stmt 1
 1848 0408 2923     	 movs r3,#41
 1849 040a 9EE1     	 b .L89
 1850              	.L125:
 974:../SSC/Src/ecatslv.c ****         }
 975:../SSC/Src/ecatslv.c ****     }
 976:../SSC/Src/ecatslv.c **** 
 977:../SSC/Src/ecatslv.c ****     /* If no free run is supported the EscInt is always enabled*/
 978:../SSC/Src/ecatslv.c ****         if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
 1851              	 .loc 3 978 0
 1852 040c 3B8E     	 ldrh r3,[r7,#48]
 1853 040e 002B     	 cmp r3,#0
 1854 0410 02D1     	 bne .L127
 1855              	 .loc 3 978 0 is_stmt 0 discriminator 1
 1856 0412 FB8D     	 ldrh r3,[r7,#46]
 1857 0414 002B     	 cmp r3,#0
 1858 0416 02D0     	 beq .L128
 1859              	.L127:
 979:../SSC/Src/ecatslv.c ****         {
 980:../SSC/Src/ecatslv.c ****         /* ECAT Synchron Mode, the ESC interrupt is enabled */
 981:../SSC/Src/ecatslv.c ****         bEscIntEnabled = TRUE;
 1860              	 .loc 3 981 0 is_stmt 1
 1861 0418 604B     	 ldr r3,.L159+20
 1862 041a 0122     	 movs r2,#1
 1863 041c 1A70     	 strb r2,[r3]
 1864              	.L128:
 982:../SSC/Src/ecatslv.c ****     }
 983:../SSC/Src/ecatslv.c **** 
 984:../SSC/Src/ecatslv.c ****         /* Update value for AL Event Mask register (0x204) */
 985:../SSC/Src/ecatslv.c ****         if(bEscIntEnabled)
 1865              	 .loc 3 985 0
 1866 041e 5F4B     	 ldr r3,.L159+20
 1867 0420 1B78     	 ldrb r3,[r3]
 1868 0422 002B     	 cmp r3,#0
 1869 0424 10D0     	 beq .L129
 986:../SSC/Src/ecatslv.c ****         {
 987:../SSC/Src/ecatslv.c ****             if(nPdOutputSize > 0)
 1870              	 .loc 3 987 0
 1871 0426 584B     	 ldr r3,.L159
 1872 0428 1B88     	 ldrh r3,[r3]
 1873 042a 002B     	 cmp r3,#0
 1874 042c 04D0     	 beq .L130
 988:../SSC/Src/ecatslv.c ****             {
 989:../SSC/Src/ecatslv.c ****                 u16ALEventMask = PROCESS_OUTPUT_EVENT;
 1875              	 .loc 3 989 0
 1876 042e 5C4B     	 ldr r3,.L159+24
 1877 0430 4FF48062 	 mov r2,#1024
 1878 0434 1A80     	 strh r2,[r3]
 1879 0436 07E0     	 b .L129
 1880              	.L130:
 990:../SSC/Src/ecatslv.c ****             }
 991:../SSC/Src/ecatslv.c ****             else if(nPdInputSize > 0)
 1881              	 .loc 3 991 0
 1882 0438 544B     	 ldr r3,.L159+4
 1883 043a 1B88     	 ldrh r3,[r3]
 1884 043c 002B     	 cmp r3,#0
 1885 043e 03D0     	 beq .L129
 992:../SSC/Src/ecatslv.c ****             {
 993:../SSC/Src/ecatslv.c ****                 u16ALEventMask = PROCESS_INPUT_EVENT;
 1886              	 .loc 3 993 0
 1887 0440 574B     	 ldr r3,.L159+24
 1888 0442 4FF40062 	 mov r2,#2048
 1889 0446 1A80     	 strh r2,[r3]
 1890              	.L129:
 994:../SSC/Src/ecatslv.c ****             }
 995:../SSC/Src/ecatslv.c **** 
 996:../SSC/Src/ecatslv.c ****         }
 997:../SSC/Src/ecatslv.c **** 
 998:../SSC/Src/ecatslv.c ****         if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 1891              	 .loc 3 998 0
 1892 0448 3B8E     	 ldrh r3,[r7,#48]
 1893 044a 022B     	 cmp r3,#2
 1894 044c 08D0     	 beq .L131
 1895              	 .loc 3 998 0 is_stmt 0 discriminator 1
 1896 044e 3B8E     	 ldrh r3,[r7,#48]
 1897 0450 032B     	 cmp r3,#3
 1898 0452 05D0     	 beq .L131
 999:../SSC/Src/ecatslv.c ****             || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync
 1899              	 .loc 3 999 0 is_stmt 1
 1900 0454 FB8D     	 ldrh r3,[r7,#46]
 1901 0456 022B     	 cmp r3,#2
 1902 0458 02D0     	 beq .L131
 1903              	 .loc 3 999 0 is_stmt 0 discriminator 1
 1904 045a FB8D     	 ldrh r3,[r7,#46]
 1905 045c 032B     	 cmp r3,#3
 1906 045e 09D1     	 bne .L132
 1907              	.L131:
1000:../SSC/Src/ecatslv.c ****         {
1001:../SSC/Src/ecatslv.c ****             /* slave is running in DC-mode */
1002:../SSC/Src/ecatslv.c ****             bDcSyncActive = TRUE;
 1908              	 .loc 3 1002 0 is_stmt 1
 1909 0460 504B     	 ldr r3,.L159+28
 1910 0462 0122     	 movs r2,#1
 1911 0464 1A70     	 strb r2,[r3]
1003:../SSC/Src/ecatslv.c **** 
1004:../SSC/Src/ecatslv.c ****             /*In case of an Input only application with DC no PDI Isr handling is required*/
1005:../SSC/Src/ecatslv.c ****             if (nPdOutputSize == 0)
 1912              	 .loc 3 1005 0
 1913 0466 484B     	 ldr r3,.L159
 1914 0468 1B88     	 ldrh r3,[r3]
 1915 046a 002B     	 cmp r3,#0
 1916 046c 02D1     	 bne .L132
1006:../SSC/Src/ecatslv.c ****             {
1007:../SSC/Src/ecatslv.c ****                u16ALEventMask = 0;
 1917              	 .loc 3 1007 0
 1918 046e 4C4B     	 ldr r3,.L159+24
 1919 0470 0022     	 movs r2,#0
 1920 0472 1A80     	 strh r2,[r3]
 1921              	.L132:
1008:../SSC/Src/ecatslv.c ****             }
1009:../SSC/Src/ecatslv.c ****         }
1010:../SSC/Src/ecatslv.c **** 
1011:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SyncType = SyncType0x1C32;
 1922              	 .loc 3 1011 0
 1923 0474 464A     	 ldr r2,.L159+8
 1924 0476 3B8E     	 ldrh r3,[r7,#48]
 1925 0478 5380     	 strh r3,[r2,#2]
1012:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SyncType = SyncType0x1C33;
 1926              	 .loc 3 1012 0
 1927 047a 464A     	 ldr r2,.L159+12
 1928 047c FB8D     	 ldrh r3,[r7,#46]
 1929 047e 5380     	 strh r3,[r2,#2]
1013:../SSC/Src/ecatslv.c **** 
1014:../SSC/Src/ecatslv.c ****     /* Calculate number of Sync0 events within one SM cycle and the Sync0 events on which the input
1015:../SSC/Src/ecatslv.c ****     LatchInputSync0Value = 0;
 1930              	 .loc 3 1015 0
 1931 0480 494B     	 ldr r3,.L159+32
 1932 0482 0022     	 movs r2,#0
 1933 0484 1A80     	 strh r2,[r3]
1016:../SSC/Src/ecatslv.c ****     LatchInputSync0Counter = 0;
 1934              	 .loc 3 1016 0
 1935 0486 494B     	 ldr r3,.L159+36
 1936 0488 0022     	 movs r2,#0
 1937 048a 1A80     	 strh r2,[r3]
1017:../SSC/Src/ecatslv.c ****     u16SmSync0Value = 0;
 1938              	 .loc 3 1017 0
 1939 048c 484B     	 ldr r3,.L159+40
 1940 048e 0022     	 movs r2,#0
 1941 0490 1A80     	 strh r2,[r3]
1018:../SSC/Src/ecatslv.c ****     u16SmSync0Counter = 0;
 1942              	 .loc 3 1018 0
 1943 0492 484B     	 ldr r3,.L159+44
 1944 0494 0022     	 movs r2,#0
 1945 0496 1A80     	 strh r2,[r3]
1019:../SSC/Src/ecatslv.c **** 
1020:../SSC/Src/ecatslv.c **** 
1021:../SSC/Src/ecatslv.c ****     if(bSubordinatedCycles == TRUE)
 1946              	 .loc 3 1021 0
 1947 0498 97F83730 	 ldrb r3,[r7,#55]
 1948 049c 002B     	 cmp r3,#0
 1949 049e 3BD0     	 beq .L133
 1950              	.LBB3:
1022:../SSC/Src/ecatslv.c ****     {
1023:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT4*/
1024:../SSC/Src/ecatslv.c ****         UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
 1951              	 .loc 3 1024 0
 1952 04a0 3A6A     	 ldr r2,[r7,#32]
 1953 04a2 7B6A     	 ldr r3,[r7,#36]
 1954 04a4 1344     	 add r3,r3,r2
 1955 04a6 FB60     	 str r3,[r7,#12]
1025:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT4*/
1026:../SSC/Src/ecatslv.c **** 
1027:../SSC/Src/ecatslv.c ****         /* get the number of Sync0 event within on SM cycle */
1028:../SSC/Src/ecatslv.c ****         if(shiftTimeSync1 >= cycleTimeSync0)
 1956              	 .loc 3 1028 0
 1957 04a8 3A6A     	 ldr r2,[r7,#32]
 1958 04aa 7B6A     	 ldr r3,[r7,#36]
 1959 04ac 9A42     	 cmp r2,r3
 1960 04ae 17D3     	 bcc .L134
1029:../SSC/Src/ecatslv.c ****         {
1030:../SSC/Src/ecatslv.c **** 
1031:../SSC/Src/ecatslv.c ****             u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
 1961              	 .loc 3 1031 0
 1962 04b0 FA68     	 ldr r2,[r7,#12]
 1963 04b2 7B6A     	 ldr r3,[r7,#36]
 1964 04b4 B2FBF3F3 	 udiv r3,r2,r3
 1965 04b8 9AB2     	 uxth r2,r3
 1966 04ba 3D4B     	 ldr r3,.L159+40
 1967 04bc 1A80     	 strh r2,[r3]
1032:../SSC/Src/ecatslv.c ****             
1033:../SSC/Src/ecatslv.c ****             if((cycleTimeSync1 % cycleTimeSync0) == 0)
 1968              	 .loc 3 1033 0
 1969 04be FB68     	 ldr r3,[r7,#12]
 1970 04c0 7A6A     	 ldr r2,[r7,#36]
 1971 04c2 B3FBF2F2 	 udiv r2,r3,r2
 1972 04c6 796A     	 ldr r1,[r7,#36]
 1973 04c8 01FB02F2 	 mul r2,r1,r2
 1974 04cc 9B1A     	 subs r3,r3,r2
 1975 04ce 002B     	 cmp r3,#0
 1976 04d0 09D1     	 bne .L136
1034:../SSC/Src/ecatslv.c ****             {
1035:../SSC/Src/ecatslv.c ****                 /* if the Sync1cycletime/Sync0cycletime ratio is even one additional tick */
1036:../SSC/Src/ecatslv.c ****                 u16SmSync0Value ++;
 1977              	 .loc 3 1036 0
 1978 04d2 374B     	 ldr r3,.L159+40
 1979 04d4 1B88     	 ldrh r3,[r3]
 1980 04d6 0133     	 adds r3,r3,#1
 1981 04d8 9AB2     	 uxth r2,r3
 1982 04da 354B     	 ldr r3,.L159+40
 1983 04dc 1A80     	 strh r2,[r3]
 1984 04de 02E0     	 b .L136
 1985              	.L134:
1037:../SSC/Src/ecatslv.c ****             }
1038:../SSC/Src/ecatslv.c ****         }
1039:../SSC/Src/ecatslv.c ****         else
1040:../SSC/Src/ecatslv.c ****         {
1041:../SSC/Src/ecatslv.c ****             u16SmSync0Value = 1;
 1986              	 .loc 3 1041 0
 1987 04e0 334B     	 ldr r3,.L159+40
 1988 04e2 0122     	 movs r2,#1
 1989 04e4 1A80     	 strh r2,[r3]
 1990              	.L136:
1042:../SSC/Src/ecatslv.c ****         }
1043:../SSC/Src/ecatslv.c **** 
1044:../SSC/Src/ecatslv.c ****         /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the nex
1045:../SSC/Src/ecatslv.c ****         LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);
 1991              	 .loc 3 1045 0
 1992 04e6 FA68     	 ldr r2,[r7,#12]
 1993 04e8 7B6A     	 ldr r3,[r7,#36]
 1994 04ea B2FBF3F3 	 udiv r3,r2,r3
 1995 04ee 9AB2     	 uxth r2,r3
 1996 04f0 2D4B     	 ldr r3,.L159+32
 1997 04f2 1A80     	 strh r2,[r3]
1046:../SSC/Src/ecatslv.c **** 
1047:../SSC/Src/ecatslv.c ****         if ((cycleTimeSync1 % cycleTimeSync0) > 0)
 1998              	 .loc 3 1047 0
 1999 04f4 FB68     	 ldr r3,[r7,#12]
 2000 04f6 7A6A     	 ldr r2,[r7,#36]
 2001 04f8 B3FBF2F2 	 udiv r2,r3,r2
 2002 04fc 796A     	 ldr r1,[r7,#36]
 2003 04fe 01FB02F2 	 mul r2,r1,r2
 2004 0502 9B1A     	 subs r3,r3,r2
 2005 0504 002B     	 cmp r3,#0
 2006 0506 06D0     	 beq .L137
1048:../SSC/Src/ecatslv.c ****         {
1049:../SSC/Src/ecatslv.c ****             LatchInputSync0Value++;
 2007              	 .loc 3 1049 0
 2008 0508 274B     	 ldr r3,.L159+32
 2009 050a 1B88     	 ldrh r3,[r3]
 2010 050c 0133     	 adds r3,r3,#1
 2011 050e 9AB2     	 uxth r2,r3
 2012 0510 254B     	 ldr r3,.L159+32
 2013 0512 1A80     	 strh r2,[r3]
 2014              	.LBE3:
 2015 0514 0CE0     	 b .L138
 2016              	.L137:
 2017 0516 0BE0     	 b .L138
 2018              	.L133:
1050:../SSC/Src/ecatslv.c ****         }
1051:../SSC/Src/ecatslv.c **** 
1052:../SSC/Src/ecatslv.c ****     }
1053:../SSC/Src/ecatslv.c ****     else 
1054:../SSC/Src/ecatslv.c ****     {
1055:../SSC/Src/ecatslv.c ****         if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
 2019              	 .loc 3 1055 0
 2020 0518 3B8E     	 ldrh r3,[r7,#48]
 2021 051a 022B     	 cmp r3,#2
 2022 051c 02D1     	 bne .L139
1056:../SSC/Src/ecatslv.c ****         {
1057:../SSC/Src/ecatslv.c ****             /* if SyncType of 0x1C32 is 2 the Sync0 event is trigger once during a SM cycle */
1058:../SSC/Src/ecatslv.c ****             u16SmSync0Value = 1;
 2023              	 .loc 3 1058 0
 2024 051e 244B     	 ldr r3,.L159+40
 2025 0520 0122     	 movs r2,#1
 2026 0522 1A80     	 strh r2,[r3]
 2027              	.L139:
1059:../SSC/Src/ecatslv.c ****         }   
1060:../SSC/Src/ecatslv.c **** 
1061:../SSC/Src/ecatslv.c ****         if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
 2028              	 .loc 3 1061 0
 2029 0524 FB8D     	 ldrh r3,[r7,#46]
 2030 0526 032B     	 cmp r3,#3
 2031 0528 02D0     	 beq .L138
1062:../SSC/Src/ecatslv.c ****         {
1063:../SSC/Src/ecatslv.c ****             LatchInputSync0Value = 1;
 2032              	 .loc 3 1063 0
 2033 052a 1F4B     	 ldr r3,.L159+32
 2034 052c 0122     	 movs r2,#1
 2035 052e 1A80     	 strh r2,[r3]
 2036              	.L138:
1064:../SSC/Src/ecatslv.c ****         }
1065:../SSC/Src/ecatslv.c ****     }
1066:../SSC/Src/ecatslv.c **** 
1067:../SSC/Src/ecatslv.c **** 
1068:../SSC/Src/ecatslv.c **** 
1069:../SSC/Src/ecatslv.c ****     /* reset the error counter indicating synchronization problems */
1070:../SSC/Src/ecatslv.c ****     sCycleDiag.syncFailedCounter = 0;
 2037              	 .loc 3 1070 0
 2038 0530 214B     	 ldr r3,.L159+48
 2039 0532 0022     	 movs r2,#0
 2040 0534 1A80     	 strh r2,[r3]
1071:../SSC/Src/ecatslv.c **** 
1072:../SSC/Src/ecatslv.c **** 
1073:../SSC/Src/ecatslv.c ****     /*
1074:../SSC/Src/ecatslv.c ****         --- Check watchdog settings ---
1075:../SSC/Src/ecatslv.c ****     */
1076:../SSC/Src/ecatslv.c **** 
1077:../SSC/Src/ecatslv.c ****     /*get the watchdog time (register 0x420). if value is > 0 watchdog is active*/
1078:../SSC/Src/ecatslv.c ****     HW_EscReadWord(wd, ESC_PD_WD_TIME);
 2041              	 .loc 3 1078 0
 2042 0536 214B     	 ldr r3,.L159+52
 2043 0538 1B88     	 ldrh r3,[r3]
 2044 053a 7B85     	 strh r3,[r7,#42]
1079:../SSC/Src/ecatslv.c ****     wd = SWAPWORD(wd);
1080:../SSC/Src/ecatslv.c **** 
1081:../SSC/Src/ecatslv.c ****     if (nPdOutputSize > 0 &&  wd != 0 )
 2045              	 .loc 3 1081 0
 2046 053c 124B     	 ldr r3,.L159
 2047 053e 1B88     	 ldrh r3,[r3]
 2048 0540 002B     	 cmp r3,#0
 2049 0542 49D0     	 beq .L140
 2050              	 .loc 3 1081 0 is_stmt 0 discriminator 1
 2051 0544 7B8D     	 ldrh r3,[r7,#42]
 2052 0546 002B     	 cmp r3,#0
 2053 0548 46D0     	 beq .L140
1082:../SSC/Src/ecatslv.c ****     {
1083:../SSC/Src/ecatslv.c ****     /*get watchdog divider (register 0x400)*/
1084:../SSC/Src/ecatslv.c ****     HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
 2054              	 .loc 3 1084 0 is_stmt 1
 2055 054a 1D4B     	 ldr r3,.L159+56
 2056 054c 1B88     	 ldrh r3,[r3]
 2057 054e BB85     	 strh r3,[r7,#44]
1085:../SSC/Src/ecatslv.c ****     wdiv = SWAPWORD(wdiv);
1086:../SSC/Src/ecatslv.c ****         if ( wdiv != 0 )
 2058              	 .loc 3 1086 0
 2059 0550 BB8D     	 ldrh r3,[r7,#44]
 2060 0552 002B     	 cmp r3,#0
 2061 0554 3AD0     	 beq .L141
 2062              	.LBB4:
1087:../SSC/Src/ecatslv.c ****         {
1088:../SSC/Src/ecatslv.c ****             /* the ESC subtracts 2 in register 0x400 so it has to be added here */
1089:../SSC/Src/ecatslv.c ****             UINT32 d = wdiv+2;
 2063              	 .loc 3 1089 0
 2064 0556 BB8D     	 ldrh r3,[r7,#44]
 2065 0558 0233     	 adds r3,r3,#2
 2066 055a BB60     	 str r3,[r7,#8]
1090:../SSC/Src/ecatslv.c **** 
1091:../SSC/Src/ecatslv.c **** 
1092:../SSC/Src/ecatslv.c ****             d *= wd;
 2067              	 .loc 3 1092 0
 2068 055c 7A8D     	 ldrh r2,[r7,#42]
 2069 055e BB68     	 ldr r3,[r7,#8]
 2070 0560 02FB03F3 	 mul r3,r2,r3
 2071 0564 BB60     	 str r3,[r7,#8]
1093:../SSC/Src/ecatslv.c ****             /* store watchdog in ms in variable u16WdValue */
1094:../SSC/Src/ecatslv.c ****             /* watchdog value has to be rounded up */
1095:../SSC/Src/ecatslv.c ****             d += 24999;
 2072              	 .loc 3 1095 0
 2073 0566 BB68     	 ldr r3,[r7,#8]
 2074 0568 03F5C343 	 add r3,r3,#24960
 2075 056c 2733     	 adds r3,r3,#39
 2076 056e BB60     	 str r3,[r7,#8]
1096:../SSC/Src/ecatslv.c ****             d /= 25000;
 2077              	 .loc 3 1096 0
 2078 0570 BB68     	 ldr r3,[r7,#8]
 2079 0572 DB08     	 lsrs r3,r3,#3
 2080 0574 134A     	 ldr r2,.L159+60
 2081 0576 A2FB0323 	 umull r2,r3,r2,r3
 2082 057a 1B0A     	 lsrs r3,r3,#8
 2083 057c BB60     	 str r3,[r7,#8]
1097:../SSC/Src/ecatslv.c ****             EcatWdValue = (UINT16) d;
 2084              	 .loc 3 1097 0
 2085 057e BB68     	 ldr r3,[r7,#8]
 2086 0580 9AB2     	 uxth r2,r3
 2087 0582 114B     	 ldr r3,.L159+64
 2088 0584 1A80     	 strh r2,[r3]
 2089              	.LBE4:
1086:../SSC/Src/ecatslv.c ****         {
 2090              	 .loc 3 1086 0
 2091 0586 2CE0     	 b .L143
 2092              	.L160:
 2093              	 .align 2
 2094              	.L159:
 2095 0588 00000000 	 .word nPdOutputSize
 2096 058c 00000000 	 .word nPdInputSize
 2097 0590 00000000 	 .word sSyncManOutPar
 2098 0594 00000000 	 .word sSyncManInPar
 2099 0598 00000000 	 .word b3BufferMode
 2100 059c 00000000 	 .word bEscIntEnabled
 2101 05a0 00000000 	 .word u16ALEventMask
 2102 05a4 00000000 	 .word bDcSyncActive
 2103 05a8 00000000 	 .word LatchInputSync0Value
 2104 05ac 00000000 	 .word LatchInputSync0Counter
 2105 05b0 00000000 	 .word u16SmSync0Value
 2106 05b4 00000000 	 .word u16SmSync0Counter
 2107 05b8 00000000 	 .word sCycleDiag
 2108 05bc 20040154 	 .word 1409352736
 2109 05c0 00040154 	 .word 1409352704
 2110 05c4 89B5F814 	 .word 351843721
 2111 05c8 00000000 	 .word EcatWdValue
 2112              	.L141:
1098:../SSC/Src/ecatslv.c ****         }
1099:../SSC/Src/ecatslv.c ****         else
1100:../SSC/Src/ecatslv.c ****         {
1101:../SSC/Src/ecatslv.c ****             wd = 0;
 2113              	 .loc 3 1101 0
 2114 05cc 0023     	 movs r3,#0
 2115 05ce 7B85     	 strh r3,[r7,#42]
1102:../SSC/Src/ecatslv.c ****             /* wd value has to be set to zero, if the wd is 0 */
1103:../SSC/Src/ecatslv.c ****             EcatWdValue = 0;
 2116              	 .loc 3 1103 0
 2117 05d0 604B     	 ldr r3,.L161
 2118 05d2 0022     	 movs r2,#0
 2119 05d4 1A80     	 strh r2,[r3]
1086:../SSC/Src/ecatslv.c ****         {
 2120              	 .loc 3 1086 0
 2121 05d6 04E0     	 b .L143
 2122              	.L140:
1104:../SSC/Src/ecatslv.c ****         }
1105:../SSC/Src/ecatslv.c ****     }
1106:../SSC/Src/ecatslv.c ****     else
1107:../SSC/Src/ecatslv.c ****     {
1108:../SSC/Src/ecatslv.c ****         /* the watchdog is deactivated or slave has no output process data*/
1109:../SSC/Src/ecatslv.c ****         wdiv = 0;
 2123              	 .loc 3 1109 0
 2124 05d8 0023     	 movs r3,#0
 2125 05da BB85     	 strh r3,[r7,#44]
1110:../SSC/Src/ecatslv.c ****         EcatWdValue = 0;
 2126              	 .loc 3 1110 0
 2127 05dc 5D4B     	 ldr r3,.L161
 2128 05de 0022     	 movs r2,#0
 2129 05e0 1A80     	 strh r2,[r3]
 2130              	.L143:
1111:../SSC/Src/ecatslv.c ****     }
1112:../SSC/Src/ecatslv.c **** 
1113:../SSC/Src/ecatslv.c ****     if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
 2131              	 .loc 3 1113 0
 2132 05e2 5C4B     	 ldr r3,.L161
 2133 05e4 1B88     	 ldrh r3,[r3]
 2134 05e6 002B     	 cmp r3,#0
 2135 05e8 03D1     	 bne .L144
 2136              	 .loc 3 1113 0 is_stmt 0 discriminator 1
 2137 05ea 5B4B     	 ldr r3,.L161+4
 2138 05ec 1B78     	 ldrb r3,[r3]
 2139 05ee 002B     	 cmp r3,#0
 2140 05f0 0AD1     	 bne .L145
 2141              	.L144:
 2142              	 .loc 3 1113 0 discriminator 3
 2143 05f2 584B     	 ldr r3,.L161
 2144 05f4 1B88     	 ldrh r3,[r3]
 2145 05f6 002B     	 cmp r3,#0
 2146 05f8 08D0     	 beq .L146
 2147              	 .loc 3 1113 0 discriminator 4
 2148 05fa 574B     	 ldr r3,.L161+4
 2149 05fc 1B78     	 ldrb r3,[r3]
 2150 05fe 83F00103 	 eor r3,r3,#1
 2151 0602 DBB2     	 uxtb r3,r3
 2152 0604 002B     	 cmp r3,#0
 2153 0606 01D0     	 beq .L146
 2154              	.L145:
1114:../SSC/Src/ecatslv.c ****     {
1115:../SSC/Src/ecatslv.c ****         /* if the WD-Trigger in the Sync Manager Channel 2 Control-Byte is set (Bit 6 of Register 0
1116:../SSC/Src/ecatslv.c ****             an error has to be returned */
1117:../SSC/Src/ecatslv.c ****         return ALSTATUSCODE_INVALIDWDCFG;
 2155              	 .loc 3 1117 0 is_stmt 1
 2156 0608 1F23     	 movs r3,#31
 2157 060a 9EE0     	 b .L89
 2158              	.L146:
1118:../SSC/Src/ecatslv.c ****     }
1119:../SSC/Src/ecatslv.c **** 
1120:../SSC/Src/ecatslv.c ****     if ( bEscIntEnabled && nPdOutputSize != 0 )
 2159              	 .loc 3 1120 0
 2160 060c 534B     	 ldr r3,.L161+8
 2161 060e 1B78     	 ldrb r3,[r3]
 2162 0610 002B     	 cmp r3,#0
 2163 0612 0AD0     	 beq .L147
 2164              	 .loc 3 1120 0 is_stmt 0 discriminator 1
 2165 0614 524B     	 ldr r3,.L161+12
 2166 0616 1B88     	 ldrh r3,[r3]
 2167 0618 002B     	 cmp r3,#0
 2168 061a 06D0     	 beq .L147
1121:../SSC/Src/ecatslv.c ****     {
1122:../SSC/Src/ecatslv.c ****         /* ECAT synchron Mode is active, the Sync Manager Channel 2 event
1123:../SSC/Src/ecatslv.c ****            has to activated in the AL-Event mask register */
1124:../SSC/Src/ecatslv.c ****         u16ALEventMask |= PROCESS_OUTPUT_EVENT;
 2169              	 .loc 3 1124 0 is_stmt 1
 2170 061c 514B     	 ldr r3,.L161+16
 2171 061e 1B88     	 ldrh r3,[r3]
 2172 0620 43F48063 	 orr r3,r3,#1024
 2173 0624 9AB2     	 uxth r2,r3
 2174 0626 4F4B     	 ldr r3,.L161+16
 2175 0628 1A80     	 strh r2,[r3]
 2176              	.L147:
1125:../SSC/Src/ecatslv.c ****     }
1126:../SSC/Src/ecatslv.c **** /*The application ESM function is separated from this function to handle pending transitions*/
1127:../SSC/Src/ecatslv.c **** 
1128:../SSC/Src/ecatslv.c ****     Sync0WdValue = 0;
 2177              	 .loc 3 1128 0
 2178 062a 4F4B     	 ldr r3,.L161+20
 2179 062c 0022     	 movs r2,#0
 2180 062e 1A80     	 strh r2,[r3]
1129:../SSC/Src/ecatslv.c ****     Sync0WdCounter = 0;
 2181              	 .loc 3 1129 0
 2182 0630 4E4B     	 ldr r3,.L161+24
 2183 0632 0022     	 movs r2,#0
 2184 0634 1A80     	 strh r2,[r3]
1130:../SSC/Src/ecatslv.c ****     Sync1WdCounter = 0;
 2185              	 .loc 3 1130 0
 2186 0636 4E4B     	 ldr r3,.L161+28
 2187 0638 0022     	 movs r2,#0
 2188 063a 1A80     	 strh r2,[r3]
1131:../SSC/Src/ecatslv.c ****     Sync1WdValue = 0;
 2189              	 .loc 3 1131 0
 2190 063c 4D4B     	 ldr r3,.L161+32
 2191 063e 0022     	 movs r2,#0
 2192 0640 1A80     	 strh r2,[r3]
1132:../SSC/Src/ecatslv.c ****     bDcRunning = FALSE;
 2193              	 .loc 3 1132 0
 2194 0642 4D4B     	 ldr r3,.L161+36
 2195 0644 0022     	 movs r2,#0
 2196 0646 1A70     	 strb r2,[r3]
1133:../SSC/Src/ecatslv.c ****     bSmSyncSequenceValid = FALSE;
 2197              	 .loc 3 1133 0
 2198 0648 4C4B     	 ldr r3,.L161+40
 2199 064a 0022     	 movs r2,#0
 2200 064c 1A70     	 strb r2,[r3]
1134:../SSC/Src/ecatslv.c ****     i16WaitForPllRunningTimeout = 0;
 2201              	 .loc 3 1134 0
 2202 064e 4C4B     	 ldr r3,.L161+44
 2203 0650 0022     	 movs r2,#0
 2204 0652 1A80     	 strh r2,[r3]
1135:../SSC/Src/ecatslv.c **** 
1136:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT5*/
1137:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SmEventMissedCounter = 0;
 2205              	 .loc 3 1137 0
 2206 0654 4B4B     	 ldr r3,.L161+48
 2207 0656 0022     	 movs r2,#0
 2208 0658 1A85     	 strh r2,[r3,#40]
1138:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16CycleExceededCounter = 0;
 2209              	 .loc 3 1138 0
 2210 065a 4A4B     	 ldr r3,.L161+48
 2211 065c 0022     	 movs r2,#0
 2212 065e 5A85     	 strh r2,[r3,#42]
1139:../SSC/Src/ecatslv.c ****     sSyncManInPar.u8SyncError = 0;
 2213              	 .loc 3 1139 0
 2214 0660 484B     	 ldr r3,.L161+48
 2215 0662 0022     	 movs r2,#0
 2216 0664 83F84020 	 strb r2,[r3,#64]
1140:../SSC/Src/ecatslv.c **** 
1141:../SSC/Src/ecatslv.c **** 
1142:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SmEventMissedCounter = 0;
 2217              	 .loc 3 1142 0
 2218 0668 474B     	 ldr r3,.L161+52
 2219 066a 0022     	 movs r2,#0
 2220 066c 1A85     	 strh r2,[r3,#40]
1143:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16CycleExceededCounter = 0;
 2221              	 .loc 3 1143 0
 2222 066e 464B     	 ldr r3,.L161+52
 2223 0670 0022     	 movs r2,#0
 2224 0672 5A85     	 strh r2,[r3,#42]
1144:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u8SyncError = 0;
 2225              	 .loc 3 1144 0
 2226 0674 444B     	 ldr r3,.L161+52
 2227 0676 0022     	 movs r2,#0
 2228 0678 83F84020 	 strb r2,[r3,#64]
1145:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT5*/
1146:../SSC/Src/ecatslv.c **** 
1147:../SSC/Src/ecatslv.c ****     /* calculate the Sync0/Sync1 watchdog timeouts */
1148:../SSC/Src/ecatslv.c ****     if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
 2229              	 .loc 3 1148 0
 2230 067c FB7D     	 ldrb r3,[r7,#23]
 2231 067e 03F00203 	 and r3,r3,#2
 2232 0682 002B     	 cmp r3,#0
 2233 0684 50D0     	 beq .L148
1149:../SSC/Src/ecatslv.c ****     {
1150:../SSC/Src/ecatslv.c ****         /*calculate the Sync0 Watchdog counter value the minimum value is 1 ms
1151:../SSC/Src/ecatslv.c ****             if the sync0 cycle is greater 500us the Sync0 Wd value is 2*Sycn0 cycle */
1152:../SSC/Src/ecatslv.c ****         if(cycleTimeSync0 == 0)
 2234              	 .loc 3 1152 0
 2235 0686 7B6A     	 ldr r3,[r7,#36]
 2236 0688 002B     	 cmp r3,#0
 2237 068a 03D1     	 bne .L149
1153:../SSC/Src/ecatslv.c ****         {
1154:../SSC/Src/ecatslv.c ****             Sync0WdValue = 0;
 2238              	 .loc 3 1154 0
 2239 068c 364B     	 ldr r3,.L161+20
 2240 068e 0022     	 movs r2,#0
 2241 0690 1A80     	 strh r2,[r3]
 2242 0692 18E0     	 b .L150
 2243              	.L149:
 2244              	.LBB5:
1155:../SSC/Src/ecatslv.c ****         }
1156:../SSC/Src/ecatslv.c ****         else
1157:../SSC/Src/ecatslv.c ****         {
1158:../SSC/Src/ecatslv.c ****             UINT32 Sync0Cycle = cycleTimeSync0/100000;
 2245              	 .loc 3 1158 0
 2246 0694 7B6A     	 ldr r3,[r7,#36]
 2247 0696 5B09     	 lsrs r3,r3,#5
 2248 0698 3C4A     	 ldr r2,.L161+56
 2249 069a A2FB0323 	 umull r2,r3,r2,r3
 2250 069e DB09     	 lsrs r3,r3,#7
 2251 06a0 7B60     	 str r3,[r7,#4]
1159:../SSC/Src/ecatslv.c **** 
1160:../SSC/Src/ecatslv.c ****             if(Sync0Cycle < 5)
 2252              	 .loc 3 1160 0
 2253 06a2 7B68     	 ldr r3,[r7,#4]
 2254 06a4 042B     	 cmp r3,#4
 2255 06a6 03D8     	 bhi .L151
1161:../SSC/Src/ecatslv.c ****             {
1162:../SSC/Src/ecatslv.c ****                 /*Sync0 cycle less than 500us*/
1163:../SSC/Src/ecatslv.c ****                 Sync0WdValue = 1;
 2256              	 .loc 3 1163 0
 2257 06a8 2F4B     	 ldr r3,.L161+20
 2258 06aa 0122     	 movs r2,#1
 2259 06ac 1A80     	 strh r2,[r3]
 2260 06ae 0AE0     	 b .L150
 2261              	.L151:
1164:../SSC/Src/ecatslv.c ****             }
1165:../SSC/Src/ecatslv.c ****             else
1166:../SSC/Src/ecatslv.c ****             {
1167:../SSC/Src/ecatslv.c ****                 Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
 2262              	 .loc 3 1167 0
 2263 06b0 7B68     	 ldr r3,[r7,#4]
 2264 06b2 9BB2     	 uxth r3,r3
 2265 06b4 5B00     	 lsls r3,r3,#1
 2266 06b6 9BB2     	 uxth r3,r3
 2267 06b8 354A     	 ldr r2,.L161+60
 2268 06ba A2FB0323 	 umull r2,r3,r2,r3
 2269 06be DB08     	 lsrs r3,r3,#3
 2270 06c0 9AB2     	 uxth r2,r3
 2271 06c2 294B     	 ldr r3,.L161+20
 2272 06c4 1A80     	 strh r2,[r3]
 2273              	.L150:
 2274              	.LBE5:
1168:../SSC/Src/ecatslv.c ****             }
1169:../SSC/Src/ecatslv.c ****         }
1170:../SSC/Src/ecatslv.c **** 
1171:../SSC/Src/ecatslv.c ****         /* Calculate also the watchdog time for Sync1*/
1172:../SSC/Src/ecatslv.c ****         if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
 2275              	 .loc 3 1172 0
 2276 06c6 FB7D     	 ldrb r3,[r7,#23]
 2277 06c8 03F00403 	 and r3,r3,#4
 2278 06cc 002B     	 cmp r3,#0
 2279 06ce 2BD0     	 beq .L148
1173:../SSC/Src/ecatslv.c ****         {
1174:../SSC/Src/ecatslv.c ****             if(shiftTimeSync1 < cycleTimeSync0)
 2280              	 .loc 3 1174 0
 2281 06d0 3A6A     	 ldr r2,[r7,#32]
 2282 06d2 7B6A     	 ldr r3,[r7,#36]
 2283 06d4 9A42     	 cmp r2,r3
 2284 06d6 04D2     	 bcs .L152
1175:../SSC/Src/ecatslv.c ****         {
1176:../SSC/Src/ecatslv.c ****                 /* Sync 1 has the same cycle time than Sync0 (maybe with a shift (shiftTimeSync1 > 
1177:../SSC/Src/ecatslv.c ****                 Sync1WdValue = Sync0WdValue;
 2285              	 .loc 3 1177 0
 2286 06d8 234B     	 ldr r3,.L161+20
 2287 06da 1A88     	 ldrh r2,[r3]
 2288 06dc 254B     	 ldr r3,.L161+32
 2289 06de 1A80     	 strh r2,[r3]
 2290 06e0 22E0     	 b .L148
 2291              	.L152:
 2292              	.LBB6:
1178:../SSC/Src/ecatslv.c ****         }
1179:../SSC/Src/ecatslv.c ****         else
1180:../SSC/Src/ecatslv.c ****         {
1181:../SSC/Src/ecatslv.c ****                 /* Sync1 cycle is larger than Sync0 (e.g. subordinated Sync0 cycles) */
1182:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT4*/
1183:../SSC/Src/ecatslv.c ****                 UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
 2293              	 .loc 3 1183 0
 2294 06e2 3A6A     	 ldr r2,[r7,#32]
 2295 06e4 7B6A     	 ldr r3,[r7,#36]
 2296 06e6 1344     	 add r3,r3,r2
 2297 06e8 5B09     	 lsrs r3,r3,#5
 2298 06ea 284A     	 ldr r2,.L161+56
 2299 06ec A2FB0323 	 umull r2,r3,r2,r3
 2300 06f0 DB09     	 lsrs r3,r3,#7
 2301 06f2 3B60     	 str r3,[r7]
1184:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT4*/
1185:../SSC/Src/ecatslv.c ****                 if(Sync1Cycle < 5)
 2302              	 .loc 3 1185 0
 2303 06f4 3B68     	 ldr r3,[r7]
 2304 06f6 042B     	 cmp r3,#4
 2305 06f8 03D8     	 bhi .L153
1186:../SSC/Src/ecatslv.c ****                 {
1187:../SSC/Src/ecatslv.c ****                     /*Sync0 cycle less than 500us*/
1188:../SSC/Src/ecatslv.c ****                     Sync1WdValue = 1;
 2306              	 .loc 3 1188 0
 2307 06fa 1E4B     	 ldr r3,.L161+32
 2308 06fc 0122     	 movs r2,#1
 2309 06fe 1A80     	 strh r2,[r3]
 2310 0700 08E0     	 b .L154
 2311              	.L153:
1189:../SSC/Src/ecatslv.c ****                 }
1190:../SSC/Src/ecatslv.c ****                 else
1191:../SSC/Src/ecatslv.c ****                 {
1192:../SSC/Src/ecatslv.c ****                     /*ECATCHANGE_START(V5.12)*/
1193:../SSC/Src/ecatslv.c ****                     Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
 2312              	 .loc 3 1193 0
 2313 0702 3B68     	 ldr r3,[r7]
 2314 0704 5B00     	 lsls r3,r3,#1
 2315 0706 224A     	 ldr r2,.L161+60
 2316 0708 A2FB0323 	 umull r2,r3,r2,r3
 2317 070c DB08     	 lsrs r3,r3,#3
 2318 070e 9AB2     	 uxth r2,r3
 2319 0710 184B     	 ldr r3,.L161+32
 2320 0712 1A80     	 strh r2,[r3]
 2321              	.L154:
1194:../SSC/Src/ecatslv.c ****                     /*ECATCHANGE_END(V5.12)*/
1195:../SSC/Src/ecatslv.c ****                 }
1196:../SSC/Src/ecatslv.c **** 
1197:../SSC/Src/ecatslv.c ****                 /* add one Sync0 cycle because the Sync1 cycle starts on the next Sync0 after the S
1198:../SSC/Src/ecatslv.c ****                 Sync1WdValue += Sync0WdValue/2;
 2322              	 .loc 3 1198 0
 2323 0714 144B     	 ldr r3,.L161+20
 2324 0716 1B88     	 ldrh r3,[r3]
 2325 0718 5B08     	 lsrs r3,r3,#1
 2326 071a 9AB2     	 uxth r2,r3
 2327 071c 154B     	 ldr r3,.L161+32
 2328 071e 1B88     	 ldrh r3,[r3]
 2329 0720 1344     	 add r3,r3,r2
 2330 0722 9AB2     	 uxth r2,r3
 2331 0724 134B     	 ldr r3,.L161+32
 2332 0726 1A80     	 strh r2,[r3]
 2333              	.L148:
 2334              	.LBE6:
1199:../SSC/Src/ecatslv.c ****             }
1200:../SSC/Src/ecatslv.c ****     }
1201:../SSC/Src/ecatslv.c ****     }
1202:../SSC/Src/ecatslv.c **** 
1203:../SSC/Src/ecatslv.c ****     if(nPdOutputSize > 0)
 2335              	 .loc 3 1203 0
 2336 0728 0D4B     	 ldr r3,.L161+12
 2337 072a 1B88     	 ldrh r3,[r3]
 2338 072c 002B     	 cmp r3,#0
 2339 072e 02D0     	 beq .L155
1204:../SSC/Src/ecatslv.c ****     {
1205:../SSC/Src/ecatslv.c ****         EnableSyncManChannel(PROCESS_DATA_OUT);
 2340              	 .loc 3 1205 0
 2341 0730 0220     	 movs r0,#2
 2342 0732 FFF7FEFF 	 bl EnableSyncManChannel
 2343              	.L155:
1206:../SSC/Src/ecatslv.c ****     }
1207:../SSC/Src/ecatslv.c **** 
1208:../SSC/Src/ecatslv.c ****     if(nPdInputSize > 0)
 2344              	 .loc 3 1208 0
 2345 0736 174B     	 ldr r3,.L161+64
 2346 0738 1B88     	 ldrh r3,[r3]
 2347 073a 002B     	 cmp r3,#0
 2348 073c 02D0     	 beq .L156
1209:../SSC/Src/ecatslv.c ****     {
1210:../SSC/Src/ecatslv.c ****         EnableSyncManChannel(PROCESS_DATA_IN);
 2349              	 .loc 3 1210 0
 2350 073e 0320     	 movs r0,#3
 2351 0740 FFF7FEFF 	 bl EnableSyncManChannel
 2352              	.L156:
1211:../SSC/Src/ecatslv.c ****     }
1212:../SSC/Src/ecatslv.c **** 
1213:../SSC/Src/ecatslv.c ****     /*write initial input data*/
1214:../SSC/Src/ecatslv.c ****     PDO_InputMapping();
 2353              	 .loc 3 1214 0
 2354 0744 FFF7FEFF 	 bl PDO_InputMapping
1215:../SSC/Src/ecatslv.c **** 
1216:../SSC/Src/ecatslv.c ****     return ALSTATUSCODE_NOERROR;
 2355              	 .loc 3 1216 0
 2356 0748 0023     	 movs r3,#0
 2357              	.L89:
1217:../SSC/Src/ecatslv.c **** }
 2358              	 .loc 3 1217 0
 2359 074a 1846     	 mov r0,r3
 2360 074c 3837     	 adds r7,r7,#56
 2361              	.LCFI52:
 2362              	 .cfi_def_cfa_offset 8
 2363 074e BD46     	 mov sp,r7
 2364              	.LCFI53:
 2365              	 .cfi_def_cfa_register 13
 2366              	 
 2367 0750 80BD     	 pop {r7,pc}
 2368              	.L162:
 2369 0752 00BF     	 .align 2
 2370              	.L161:
 2371 0754 00000000 	 .word EcatWdValue
 2372 0758 00000000 	 .word bWdTrigger
 2373 075c 00000000 	 .word bEscIntEnabled
 2374 0760 00000000 	 .word nPdOutputSize
 2375 0764 00000000 	 .word u16ALEventMask
 2376 0768 00000000 	 .word Sync0WdValue
 2377 076c 00000000 	 .word Sync0WdCounter
 2378 0770 00000000 	 .word Sync1WdCounter
 2379 0774 00000000 	 .word Sync1WdValue
 2380 0778 00000000 	 .word bDcRunning
 2381 077c 00000000 	 .word bSmSyncSequenceValid
 2382 0780 00000000 	 .word i16WaitForPllRunningTimeout
 2383 0784 00000000 	 .word sSyncManInPar
 2384 0788 00000000 	 .word sSyncManOutPar
 2385 078c C55A7C0A 	 .word 175921861
 2386 0790 CDCCCCCC 	 .word -858993459
 2387 0794 00000000 	 .word nPdInputSize
 2388              	 .cfi_endproc
 2389              	.LFE186:
 2391              	 .section .text.StartOutputHandler,"ax",%progbits
 2392              	 .align 2
 2393              	 .global StartOutputHandler
 2394              	 .thumb
 2395              	 .thumb_func
 2397              	StartOutputHandler:
 2398              	.LFB187:
1218:../SSC/Src/ecatslv.c **** 
1219:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1220:../SSC/Src/ecatslv.c **** /**
1221:../SSC/Src/ecatslv.c ****  \return    AL Status Code (see ecatslv.h ALSTATUSCODE_....)
1222:../SSC/Src/ecatslv.c **** 
1223:../SSC/Src/ecatslv.c ****  \brief    This function is called in case of the state transition from SAFEOP to OP.
1224:../SSC/Src/ecatslv.c ****  \brief  It will be checked if outputs had to be received before switching to OP
1225:../SSC/Src/ecatslv.c ****  \brief  and the state transition would be refused if outputs are missing
1226:../SSC/Src/ecatslv.c **** 
1227:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1228:../SSC/Src/ecatslv.c **** 
1229:../SSC/Src/ecatslv.c **** UINT16 StartOutputHandler(void)
1230:../SSC/Src/ecatslv.c **** {
 2399              	 .loc 3 1230 0
 2400              	 .cfi_startproc
 2401              	 
 2402              	 
 2403              	 
 2404 0000 80B4     	 push {r7}
 2405              	.LCFI54:
 2406              	 .cfi_def_cfa_offset 4
 2407              	 .cfi_offset 7,-4
 2408 0002 83B0     	 sub sp,sp,#12
 2409              	.LCFI55:
 2410              	 .cfi_def_cfa_offset 16
 2411 0004 00AF     	 add r7,sp,#0
 2412              	.LCFI56:
 2413              	 .cfi_def_cfa_register 7
1231:../SSC/Src/ecatslv.c ****     /* by default the SO transition should be completed in AlControlRes().
1232:../SSC/Src/ecatslv.c ****        required to support also masters which starts to send process data after the SO transition w
1233:../SSC/Src/ecatslv.c ****        (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)
1234:../SSC/Src/ecatslv.c ****     UINT16 result = NOERROR_INWORK;
 2414              	 .loc 3 1234 0
 2415 0006 FF23     	 movs r3,#255
 2416 0008 FB80     	 strh r3,[r7,#6]
1235:../SSC/Src/ecatslv.c ****     if(bLocalErrorFlag)
 2417              	 .loc 3 1235 0
 2418 000a 134B     	 ldr r3,.L167
 2419 000c 1B78     	 ldrb r3,[r3]
 2420 000e 002B     	 cmp r3,#0
 2421 0010 02D0     	 beq .L164
1236:../SSC/Src/ecatslv.c ****     {
1237:../SSC/Src/ecatslv.c ****         /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode
1238:../SSC/Src/ecatslv.c ****         return u16LocalErrorCode;
 2422              	 .loc 3 1238 0
 2423 0012 124B     	 ldr r3,.L167+4
 2424 0014 1B88     	 ldrh r3,[r3]
 2425 0016 18E0     	 b .L165
 2426              	.L164:
1239:../SSC/Src/ecatslv.c ****     }
1240:../SSC/Src/ecatslv.c **** /*The application ESM function is separated from this function to handle pending transitions*/
1241:../SSC/Src/ecatslv.c **** 
1242:../SSC/Src/ecatslv.c **** 
1243:../SSC/Src/ecatslv.c ****     /*DC synchronisation is active wait until pll is valid*/
1244:../SSC/Src/ecatslv.c ****     if(bDcSyncActive)
 2427              	 .loc 3 1244 0
 2428 0018 114B     	 ldr r3,.L167+8
 2429 001a 1B78     	 ldrb r3,[r3]
 2430 001c 002B     	 cmp r3,#0
 2431 001e 05D0     	 beq .L166
1245:../SSC/Src/ecatslv.c ****     {
1246:../SSC/Src/ecatslv.c ****         i16WaitForPllRunningTimeout = 200;
 2432              	 .loc 3 1246 0
 2433 0020 104B     	 ldr r3,.L167+12
 2434 0022 C822     	 movs r2,#200
 2435 0024 1A80     	 strh r2,[r3]
1247:../SSC/Src/ecatslv.c **** 
1248:../SSC/Src/ecatslv.c ****         i16WaitForPllRunningCnt = 0;
 2436              	 .loc 3 1248 0
 2437 0026 104B     	 ldr r3,.L167+16
 2438 0028 0022     	 movs r2,#0
 2439 002a 1A80     	 strh r2,[r3]
 2440              	.L166:
1249:../SSC/Src/ecatslv.c ****     }
1250:../SSC/Src/ecatslv.c **** 
1251:../SSC/Src/ecatslv.c **** 
1252:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT5*/
1253:../SSC/Src/ecatslv.c **** 
1254:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SmEventMissedCounter = 0;
 2441              	 .loc 3 1254 0
 2442 002c 0F4B     	 ldr r3,.L167+20
 2443 002e 0022     	 movs r2,#0
 2444 0030 1A85     	 strh r2,[r3,#40]
1255:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u8SyncError = 0;
 2445              	 .loc 3 1255 0
 2446 0032 0E4B     	 ldr r3,.L167+20
 2447 0034 0022     	 movs r2,#0
 2448 0036 83F84020 	 strb r2,[r3,#64]
1256:../SSC/Src/ecatslv.c **** 
1257:../SSC/Src/ecatslv.c **** 
1258:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SmEventMissedCounter = 0;
 2449              	 .loc 3 1258 0
 2450 003a 0D4B     	 ldr r3,.L167+24
 2451 003c 0022     	 movs r2,#0
 2452 003e 1A85     	 strh r2,[r3,#40]
1259:../SSC/Src/ecatslv.c ****     sSyncManInPar.u8SyncError = 0;
 2453              	 .loc 3 1259 0
 2454 0040 0B4B     	 ldr r3,.L167+24
 2455 0042 0022     	 movs r2,#0
 2456 0044 83F84020 	 strb r2,[r3,#64]
1260:../SSC/Src/ecatslv.c **** 
1261:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT5*/
1262:../SSC/Src/ecatslv.c **** 
1263:../SSC/Src/ecatslv.c ****     return result;
 2457              	 .loc 3 1263 0
 2458 0048 FB88     	 ldrh r3,[r7,#6]
 2459              	.L165:
1264:../SSC/Src/ecatslv.c **** }
 2460              	 .loc 3 1264 0
 2461 004a 1846     	 mov r0,r3
 2462 004c 0C37     	 adds r7,r7,#12
 2463              	.LCFI57:
 2464              	 .cfi_def_cfa_offset 4
 2465 004e BD46     	 mov sp,r7
 2466              	.LCFI58:
 2467              	 .cfi_def_cfa_register 13
 2468              	 
 2469 0050 5DF8047B 	 ldr r7,[sp],#4
 2470              	.LCFI59:
 2471              	 .cfi_restore 7
 2472              	 .cfi_def_cfa_offset 0
 2473 0054 7047     	 bx lr
 2474              	.L168:
 2475 0056 00BF     	 .align 2
 2476              	.L167:
 2477 0058 00000000 	 .word bLocalErrorFlag
 2478 005c 00000000 	 .word u16LocalErrorCode
 2479 0060 00000000 	 .word bDcSyncActive
 2480 0064 00000000 	 .word i16WaitForPllRunningTimeout
 2481 0068 00000000 	 .word i16WaitForPllRunningCnt
 2482 006c 00000000 	 .word sSyncManOutPar
 2483 0070 00000000 	 .word sSyncManInPar
 2484              	 .cfi_endproc
 2485              	.LFE187:
 2487              	 .section .text.StopOutputHandler,"ax",%progbits
 2488              	 .align 2
 2489              	 .global StopOutputHandler
 2490              	 .thumb
 2491              	 .thumb_func
 2493              	StopOutputHandler:
 2494              	.LFB188:
1265:../SSC/Src/ecatslv.c **** 
1266:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1267:../SSC/Src/ecatslv.c **** /**
1268:../SSC/Src/ecatslv.c ****  \brief    This function is called in case of the state transition from OP to SAFEOP
1269:../SSC/Src/ecatslv.c ****  \brief  the outputs can be set to an application specific safe state,
1270:../SSC/Src/ecatslv.c ****  \brief  the state transition can be delayed by returning NOERROR_INWORK
1271:../SSC/Src/ecatslv.c **** 
1272:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1273:../SSC/Src/ecatslv.c **** 
1274:../SSC/Src/ecatslv.c **** void StopOutputHandler(void)
1275:../SSC/Src/ecatslv.c **** {
 2495              	 .loc 3 1275 0
 2496              	 .cfi_startproc
 2497              	 
 2498              	 
 2499              	 
 2500 0000 80B4     	 push {r7}
 2501              	.LCFI60:
 2502              	 .cfi_def_cfa_offset 4
 2503              	 .cfi_offset 7,-4
 2504 0002 00AF     	 add r7,sp,#0
 2505              	.LCFI61:
 2506              	 .cfi_def_cfa_register 7
1276:../SSC/Src/ecatslv.c ****     /* reset the flags that outputs were received and that the slave is in OP */
1277:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 2507              	 .loc 3 1277 0
 2508 0004 044B     	 ldr r3,.L170
 2509 0006 0022     	 movs r2,#0
 2510 0008 1A70     	 strb r2,[r3]
1278:../SSC/Src/ecatslv.c ****     bEcatOutputUpdateRunning = FALSE;
 2511              	 .loc 3 1278 0
 2512 000a 044B     	 ldr r3,.L170+4
 2513 000c 0022     	 movs r2,#0
 2514 000e 1A70     	 strb r2,[r3]
1279:../SSC/Src/ecatslv.c **** }
 2515              	 .loc 3 1279 0
 2516 0010 BD46     	 mov sp,r7
 2517              	.LCFI62:
 2518              	 .cfi_def_cfa_register 13
 2519              	 
 2520 0012 5DF8047B 	 ldr r7,[sp],#4
 2521              	.LCFI63:
 2522              	 .cfi_restore 7
 2523              	 .cfi_def_cfa_offset 0
 2524 0016 7047     	 bx lr
 2525              	.L171:
 2526              	 .align 2
 2527              	.L170:
 2528 0018 00000000 	 .word bEcatFirstOutputsReceived
 2529 001c 00000000 	 .word bEcatOutputUpdateRunning
 2530              	 .cfi_endproc
 2531              	.LFE188:
 2533              	 .section .text.StopInputHandler,"ax",%progbits
 2534              	 .align 2
 2535              	 .global StopInputHandler
 2536              	 .thumb
 2537              	 .thumb_func
 2539              	StopInputHandler:
 2540              	.LFB189:
1280:../SSC/Src/ecatslv.c **** 
1281:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1282:../SSC/Src/ecatslv.c **** /**
1283:../SSC/Src/ecatslv.c ****   \brief    This function is called in case of the state transition from SAFEOP to PREOP
1284:../SSC/Src/ecatslv.c **** 
1285:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1286:../SSC/Src/ecatslv.c **** 
1287:../SSC/Src/ecatslv.c **** void StopInputHandler(void)
1288:../SSC/Src/ecatslv.c **** {
 2541              	 .loc 3 1288 0
 2542              	 .cfi_startproc
 2543              	 
 2544              	 
 2545 0000 80B5     	 push {r7,lr}
 2546              	.LCFI64:
 2547              	 .cfi_def_cfa_offset 8
 2548              	 .cfi_offset 7,-8
 2549              	 .cfi_offset 14,-4
 2550 0002 82B0     	 sub sp,sp,#8
 2551              	.LCFI65:
 2552              	 .cfi_def_cfa_offset 16
 2553 0004 00AF     	 add r7,sp,#0
 2554              	.LCFI66:
 2555              	 .cfi_def_cfa_register 7
1289:../SSC/Src/ecatslv.c ****     if(nPdOutputSize > 0)
 2556              	 .loc 3 1289 0
 2557 0006 344B     	 ldr r3,.L175
 2558 0008 1B88     	 ldrh r3,[r3]
 2559 000a 002B     	 cmp r3,#0
 2560 000c 02D0     	 beq .L173
1290:../SSC/Src/ecatslv.c ****     {
1291:../SSC/Src/ecatslv.c ****         /* disable the Sync Manager Channel 2 (outputs) */
1292:../SSC/Src/ecatslv.c ****         DisableSyncManChannel(PROCESS_DATA_OUT);
 2561              	 .loc 3 1292 0
 2562 000e 0220     	 movs r0,#2
 2563 0010 FFF7FEFF 	 bl DisableSyncManChannel
 2564              	.L173:
1293:../SSC/Src/ecatslv.c ****     }
1294:../SSC/Src/ecatslv.c **** 
1295:../SSC/Src/ecatslv.c ****     if(nPdInputSize > 0)
 2565              	 .loc 3 1295 0
 2566 0014 314B     	 ldr r3,.L175+4
 2567 0016 1B88     	 ldrh r3,[r3]
 2568 0018 002B     	 cmp r3,#0
 2569 001a 02D0     	 beq .L174
1296:../SSC/Src/ecatslv.c ****     {
1297:../SSC/Src/ecatslv.c ****         /*disable Sync Manager 3 (inputs) if no outputs available*/
1298:../SSC/Src/ecatslv.c ****         DisableSyncManChannel(PROCESS_DATA_IN);
 2570              	 .loc 3 1298 0
 2571 001c 0320     	 movs r0,#3
 2572 001e FFF7FEFF 	 bl DisableSyncManChannel
 2573              	.L174:
 2574              	.LBB7:
1299:../SSC/Src/ecatslv.c ****     }
1300:../SSC/Src/ecatslv.c **** 
1301:../SSC/Src/ecatslv.c ****     /* reset the events in the AL Event mask register (0x204) */
1302:../SSC/Src/ecatslv.c ****     {
1303:../SSC/Src/ecatslv.c ****         UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
 2575              	 .loc 3 1303 0
 2576 0022 0C23     	 movs r3,#12
 2577 0024 FB80     	 strh r3,[r7,#6]
1304:../SSC/Src/ecatslv.c ****         ResetMask |= PROCESS_OUTPUT_EVENT;
 2578              	 .loc 3 1304 0
 2579 0026 FB88     	 ldrh r3,[r7,#6]
 2580 0028 43F48063 	 orr r3,r3,#1024
 2581 002c FB80     	 strh r3,[r7,#6]
1305:../SSC/Src/ecatslv.c ****         ResetMask |= PROCESS_INPUT_EVENT;
 2582              	 .loc 3 1305 0
 2583 002e FB88     	 ldrh r3,[r7,#6]
 2584 0030 43F40063 	 orr r3,r3,#2048
 2585 0034 FB80     	 strh r3,[r7,#6]
1306:../SSC/Src/ecatslv.c **** 
1307:../SSC/Src/ecatslv.c ****     ResetALEventMask( ~(ResetMask) );
 2586              	 .loc 3 1307 0
 2587 0036 FB88     	 ldrh r3,[r7,#6]
 2588 0038 DB43     	 mvns r3,r3
 2589 003a 9BB2     	 uxth r3,r3
 2590 003c 1846     	 mov r0,r3
 2591 003e FFF7FEFF 	 bl ResetALEventMask
 2592              	.LBE7:
1308:../SSC/Src/ecatslv.c ****     }
1309:../SSC/Src/ecatslv.c ****     /* reset the flags */
1310:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 2593              	 .loc 3 1310 0
 2594 0042 274B     	 ldr r3,.L175+8
 2595 0044 0022     	 movs r2,#0
 2596 0046 1A70     	 strb r2,[r3]
1311:../SSC/Src/ecatslv.c ****     bEscIntEnabled = FALSE;
 2597              	 .loc 3 1311 0
 2598 0048 264B     	 ldr r3,.L175+12
 2599 004a 0022     	 movs r2,#0
 2600 004c 1A70     	 strb r2,[r3]
1312:../SSC/Src/ecatslv.c **** /*The application ESM function is separated from this function to handle pending transitions*/
1313:../SSC/Src/ecatslv.c **** 
1314:../SSC/Src/ecatslv.c ****     bDcSyncActive = FALSE;
 2601              	 .loc 3 1314 0
 2602 004e 264B     	 ldr r3,.L175+16
 2603 0050 0022     	 movs r2,#0
 2604 0052 1A70     	 strb r2,[r3]
1315:../SSC/Src/ecatslv.c ****     bDcRunning = FALSE;
 2605              	 .loc 3 1315 0
 2606 0054 254B     	 ldr r3,.L175+20
 2607 0056 0022     	 movs r2,#0
 2608 0058 1A70     	 strb r2,[r3]
1316:../SSC/Src/ecatslv.c ****     bSmSyncSequenceValid = FALSE;
 2609              	 .loc 3 1316 0
 2610 005a 254B     	 ldr r3,.L175+24
 2611 005c 0022     	 movs r2,#0
 2612 005e 1A70     	 strb r2,[r3]
1317:../SSC/Src/ecatslv.c ****     u16SmSync0Value = 0;
 2613              	 .loc 3 1317 0
 2614 0060 244B     	 ldr r3,.L175+28
 2615 0062 0022     	 movs r2,#0
 2616 0064 1A80     	 strh r2,[r3]
1318:../SSC/Src/ecatslv.c ****     u16SmSync0Counter = 0;
 2617              	 .loc 3 1318 0
 2618 0066 244B     	 ldr r3,.L175+32
 2619 0068 0022     	 movs r2,#0
 2620 006a 1A80     	 strh r2,[r3]
1319:../SSC/Src/ecatslv.c **** 
1320:../SSC/Src/ecatslv.c ****     Sync0WdValue = 0;
 2621              	 .loc 3 1320 0
 2622 006c 234B     	 ldr r3,.L175+36
 2623 006e 0022     	 movs r2,#0
 2624 0070 1A80     	 strh r2,[r3]
1321:../SSC/Src/ecatslv.c ****     Sync0WdCounter = 0;
 2625              	 .loc 3 1321 0
 2626 0072 234B     	 ldr r3,.L175+40
 2627 0074 0022     	 movs r2,#0
 2628 0076 1A80     	 strh r2,[r3]
1322:../SSC/Src/ecatslv.c ****     Sync1WdCounter = 0;
 2629              	 .loc 3 1322 0
 2630 0078 224B     	 ldr r3,.L175+44
 2631 007a 0022     	 movs r2,#0
 2632 007c 1A80     	 strh r2,[r3]
1323:../SSC/Src/ecatslv.c ****     Sync1WdValue = 0;
 2633              	 .loc 3 1323 0
 2634 007e 224B     	 ldr r3,.L175+48
 2635 0080 0022     	 movs r2,#0
 2636 0082 1A80     	 strh r2,[r3]
1324:../SSC/Src/ecatslv.c ****     LatchInputSync0Value = 0;
 2637              	 .loc 3 1324 0
 2638 0084 214B     	 ldr r3,.L175+52
 2639 0086 0022     	 movs r2,#0
 2640 0088 1A80     	 strh r2,[r3]
1325:../SSC/Src/ecatslv.c ****     LatchInputSync0Counter = 0;
 2641              	 .loc 3 1325 0
 2642 008a 214B     	 ldr r3,.L175+56
 2643 008c 0022     	 movs r2,#0
 2644 008e 1A80     	 strh r2,[r3]
1326:../SSC/Src/ecatslv.c **** 
1327:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_START(V5.12) ECAT5*/
1328:../SSC/Src/ecatslv.c **** 
1329:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SmEventMissedCounter = 0;
 2645              	 .loc 3 1329 0
 2646 0090 204B     	 ldr r3,.L175+60
 2647 0092 0022     	 movs r2,#0
 2648 0094 1A85     	 strh r2,[r3,#40]
1330:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16CycleExceededCounter = 0;
 2649              	 .loc 3 1330 0
 2650 0096 1F4B     	 ldr r3,.L175+60
 2651 0098 0022     	 movs r2,#0
 2652 009a 5A85     	 strh r2,[r3,#42]
1331:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u8SyncError = 0;
 2653              	 .loc 3 1331 0
 2654 009c 1D4B     	 ldr r3,.L175+60
 2655 009e 0022     	 movs r2,#0
 2656 00a0 83F84020 	 strb r2,[r3,#64]
1332:../SSC/Src/ecatslv.c **** 
1333:../SSC/Src/ecatslv.c **** 
1334:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SmEventMissedCounter = 0;
 2657              	 .loc 3 1334 0
 2658 00a4 1C4B     	 ldr r3,.L175+64
 2659 00a6 0022     	 movs r2,#0
 2660 00a8 1A85     	 strh r2,[r3,#40]
1335:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16CycleExceededCounter = 0;
 2661              	 .loc 3 1335 0
 2662 00aa 1B4B     	 ldr r3,.L175+64
 2663 00ac 0022     	 movs r2,#0
 2664 00ae 5A85     	 strh r2,[r3,#42]
1336:../SSC/Src/ecatslv.c ****     sSyncManInPar.u8SyncError = 0;
 2665              	 .loc 3 1336 0
 2666 00b0 194B     	 ldr r3,.L175+64
 2667 00b2 0022     	 movs r2,#0
 2668 00b4 83F84020 	 strb r2,[r3,#64]
1337:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT5*/
1338:../SSC/Src/ecatslv.c **** 
1339:../SSC/Src/ecatslv.c ****     i16WaitForPllRunningTimeout = 0;
 2669              	 .loc 3 1339 0
 2670 00b8 184B     	 ldr r3,.L175+68
 2671 00ba 0022     	 movs r2,#0
 2672 00bc 1A80     	 strh r2,[r3]
1340:../SSC/Src/ecatslv.c **** 
1341:../SSC/Src/ecatslv.c ****     bWdTrigger = FALSE;
 2673              	 .loc 3 1341 0
 2674 00be 184B     	 ldr r3,.L175+72
 2675 00c0 0022     	 movs r2,#0
 2676 00c2 1A70     	 strb r2,[r3]
1342:../SSC/Src/ecatslv.c ****     bEcatInputUpdateRunning = FALSE;
 2677              	 .loc 3 1342 0
 2678 00c4 174B     	 ldr r3,.L175+76
 2679 00c6 0022     	 movs r2,#0
 2680 00c8 1A70     	 strb r2,[r3]
1343:../SSC/Src/ecatslv.c **** 
1344:../SSC/Src/ecatslv.c ****     /*Indicate no user specified Sync mode*/
1345:../SSC/Src/ecatslv.c ****     bSyncSetByUser = FALSE;
 2681              	 .loc 3 1345 0
 2682 00ca 174B     	 ldr r3,.L175+80
 2683 00cc 0022     	 movs r2,#0
 2684 00ce 1A70     	 strb r2,[r3]
1346:../SSC/Src/ecatslv.c **** }
 2685              	 .loc 3 1346 0
 2686 00d0 0837     	 adds r7,r7,#8
 2687              	.LCFI67:
 2688              	 .cfi_def_cfa_offset 8
 2689 00d2 BD46     	 mov sp,r7
 2690              	.LCFI68:
 2691              	 .cfi_def_cfa_register 13
 2692              	 
 2693 00d4 80BD     	 pop {r7,pc}
 2694              	.L176:
 2695 00d6 00BF     	 .align 2
 2696              	.L175:
 2697 00d8 00000000 	 .word nPdOutputSize
 2698 00dc 00000000 	 .word nPdInputSize
 2699 00e0 00000000 	 .word bEcatFirstOutputsReceived
 2700 00e4 00000000 	 .word bEscIntEnabled
 2701 00e8 00000000 	 .word bDcSyncActive
 2702 00ec 00000000 	 .word bDcRunning
 2703 00f0 00000000 	 .word bSmSyncSequenceValid
 2704 00f4 00000000 	 .word u16SmSync0Value
 2705 00f8 00000000 	 .word u16SmSync0Counter
 2706 00fc 00000000 	 .word Sync0WdValue
 2707 0100 00000000 	 .word Sync0WdCounter
 2708 0104 00000000 	 .word Sync1WdCounter
 2709 0108 00000000 	 .word Sync1WdValue
 2710 010c 00000000 	 .word LatchInputSync0Value
 2711 0110 00000000 	 .word LatchInputSync0Counter
 2712 0114 00000000 	 .word sSyncManOutPar
 2713 0118 00000000 	 .word sSyncManInPar
 2714 011c 00000000 	 .word i16WaitForPllRunningTimeout
 2715 0120 00000000 	 .word bWdTrigger
 2716 0124 00000000 	 .word bEcatInputUpdateRunning
 2717 0128 00000000 	 .word bSyncSetByUser
 2718              	 .cfi_endproc
 2719              	.LFE189:
 2721              	 .section .text.BackToInitTransition,"ax",%progbits
 2722              	 .align 2
 2723              	 .global BackToInitTransition
 2724              	 .thumb
 2725              	 .thumb_func
 2727              	BackToInitTransition:
 2728              	.LFB190:
1347:../SSC/Src/ecatslv.c **** 
1348:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1349:../SSC/Src/ecatslv.c **** /**
1350:../SSC/Src/ecatslv.c **** \brief    This function is called when a X to Init transition is completed
1351:../SSC/Src/ecatslv.c **** 
1352:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1353:../SSC/Src/ecatslv.c **** 
1354:../SSC/Src/ecatslv.c **** void BackToInitTransition(void)
1355:../SSC/Src/ecatslv.c **** {
 2729              	 .loc 3 1355 0
 2730              	 .cfi_startproc
 2731              	 
 2732              	 
 2733              	 
 2734 0000 80B4     	 push {r7}
 2735              	.LCFI69:
 2736              	 .cfi_def_cfa_offset 4
 2737              	 .cfi_offset 7,-4
 2738 0002 00AF     	 add r7,sp,#0
 2739              	.LCFI70:
 2740              	 .cfi_def_cfa_register 7
1356:../SSC/Src/ecatslv.c ****     /* Reset indication that the user has written a sync mode*/
1357:../SSC/Src/ecatslv.c ****     bSyncSetByUser = FALSE;
 2741              	 .loc 3 1357 0
 2742 0004 034B     	 ldr r3,.L178
 2743 0006 0022     	 movs r2,#0
 2744 0008 1A70     	 strb r2,[r3]
1358:../SSC/Src/ecatslv.c **** }
 2745              	 .loc 3 1358 0
 2746 000a BD46     	 mov sp,r7
 2747              	.LCFI71:
 2748              	 .cfi_def_cfa_register 13
 2749              	 
 2750 000c 5DF8047B 	 ldr r7,[sp],#4
 2751              	.LCFI72:
 2752              	 .cfi_restore 7
 2753              	 .cfi_def_cfa_offset 0
 2754 0010 7047     	 bx lr
 2755              	.L179:
 2756 0012 00BF     	 .align 2
 2757              	.L178:
 2758 0014 00000000 	 .word bSyncSetByUser
 2759              	 .cfi_endproc
 2760              	.LFE190:
 2762              	 .section .text.SetALStatus,"ax",%progbits
 2763              	 .align 2
 2764              	 .global SetALStatus
 2765              	 .thumb
 2766              	 .thumb_func
 2768              	SetALStatus:
 2769              	.LFB191:
1359:../SSC/Src/ecatslv.c **** 
1360:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1361:../SSC/Src/ecatslv.c **** /**
1362:../SSC/Src/ecatslv.c ****  \param alStatus        New AL Status (written to register 0x130)
1363:../SSC/Src/ecatslv.c ****  \param alStatusCode    New AL Status Code (written to register 0x134)
1364:../SSC/Src/ecatslv.c **** 
1365:../SSC/Src/ecatslv.c ****   \brief  The function changes the state of the EtherCAT ASIC to the requested.
1366:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1367:../SSC/Src/ecatslv.c **** void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
1368:../SSC/Src/ecatslv.c **** {
 2770              	 .loc 3 1368 0
 2771              	 .cfi_startproc
 2772              	 
 2773              	 
 2774              	 
 2775 0000 80B4     	 push {r7}
 2776              	.LCFI73:
 2777              	 .cfi_def_cfa_offset 4
 2778              	 .cfi_offset 7,-4
 2779 0002 85B0     	 sub sp,sp,#20
 2780              	.LCFI74:
 2781              	 .cfi_def_cfa_offset 24
 2782 0004 00AF     	 add r7,sp,#0
 2783              	.LCFI75:
 2784              	 .cfi_def_cfa_register 7
 2785 0006 0346     	 mov r3,r0
 2786 0008 0A46     	 mov r2,r1
 2787 000a FB71     	 strb r3,[r7,#7]
 2788 000c 1346     	 mov r3,r2
 2789 000e BB80     	 strh r3,[r7,#4]
1369:../SSC/Src/ecatslv.c ****     UINT16 Value = alStatusCode;
 2790              	 .loc 3 1369 0
 2791 0010 BB88     	 ldrh r3,[r7,#4]
 2792 0012 FB81     	 strh r3,[r7,#14]
1370:../SSC/Src/ecatslv.c **** 
1371:../SSC/Src/ecatslv.c ****     /*update global status variable if required*/
1372:../SSC/Src/ecatslv.c ****     if(nAlStatus != alStatus)
 2793              	 .loc 3 1372 0
 2794 0014 264B     	 ldr r3,.L189
 2795 0016 1B78     	 ldrb r3,[r3]
 2796 0018 FA79     	 ldrb r2,[r7,#7]
 2797 001a 9A42     	 cmp r2,r3
 2798 001c 02D0     	 beq .L181
1373:../SSC/Src/ecatslv.c ****     {
1374:../SSC/Src/ecatslv.c ****         nAlStatus = alStatus;
 2799              	 .loc 3 1374 0
 2800 001e 244A     	 ldr r2,.L189
 2801 0020 FB79     	 ldrb r3,[r7,#7]
 2802 0022 1370     	 strb r3,[r2]
 2803              	.L181:
1375:../SSC/Src/ecatslv.c ****     }
1376:../SSC/Src/ecatslv.c **** 
1377:../SSC/Src/ecatslv.c **** 
1378:../SSC/Src/ecatslv.c ****     if (alStatusCode != 0xFFFF)
 2804              	 .loc 3 1378 0
 2805 0024 BB88     	 ldrh r3,[r7,#4]
 2806 0026 4FF6FF72 	 movw r2,#65535
 2807 002a 9342     	 cmp r3,r2
 2808 002c 02D0     	 beq .L182
1379:../SSC/Src/ecatslv.c ****     {
1380:../SSC/Src/ecatslv.c ****         Value = SWAPWORD(Value);
1381:../SSC/Src/ecatslv.c **** 
1382:../SSC/Src/ecatslv.c ****         HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
 2809              	 .loc 3 1382 0
 2810 002e 214A     	 ldr r2,.L189+4
 2811 0030 FB89     	 ldrh r3,[r7,#14]
 2812 0032 1380     	 strh r3,[r2]
 2813              	.L182:
1383:../SSC/Src/ecatslv.c ****     }
1384:../SSC/Src/ecatslv.c **** 
1385:../SSC/Src/ecatslv.c ****     Value = nAlStatus;
 2814              	 .loc 3 1385 0
 2815 0034 1E4B     	 ldr r3,.L189
 2816 0036 1B78     	 ldrb r3,[r3]
 2817 0038 FB81     	 strh r3,[r7,#14]
1386:../SSC/Src/ecatslv.c ****     Value = SWAPWORD(Value);
1387:../SSC/Src/ecatslv.c ****     HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
 2818              	 .loc 3 1387 0
 2819 003a 1F4A     	 ldr r2,.L189+8
 2820 003c FB89     	 ldrh r3,[r7,#14]
 2821 003e 1380     	 strh r3,[r2]
1388:../SSC/Src/ecatslv.c **** 
1389:../SSC/Src/ecatslv.c ****     /*The Run LED state is set in Set LED Indication, only the Error LED blink code is set here*/
1390:../SSC/Src/ecatslv.c **** 
1391:../SSC/Src/ecatslv.c ****     /*set Error blink code*/
1392:../SSC/Src/ecatslv.c ****     if(alStatusCode == 0x00 || !(alStatus & STATE_CHANGE))
 2822              	 .loc 3 1392 0
 2823 0040 BB88     	 ldrh r3,[r7,#4]
 2824 0042 002B     	 cmp r3,#0
 2825 0044 04D0     	 beq .L183
 2826              	 .loc 3 1392 0 is_stmt 0 discriminator 1
 2827 0046 FB79     	 ldrb r3,[r7,#7]
 2828 0048 03F01003 	 and r3,r3,#16
 2829 004c 002B     	 cmp r3,#0
 2830 004e 03D1     	 bne .L184
 2831              	.L183:
1393:../SSC/Src/ecatslv.c ****     {
1394:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_OFF;
 2832              	 .loc 3 1394 0 is_stmt 1
 2833 0050 1A4B     	 ldr r3,.L189+12
 2834 0052 0022     	 movs r2,#0
 2835 0054 1A70     	 strb r2,[r3]
 2836 0056 1AE0     	 b .L185
 2837              	.L184:
1395:../SSC/Src/ecatslv.c ****     }
1396:../SSC/Src/ecatslv.c ****     else if((alStatusCode == ALSTATUSCODE_NOSYNCERROR) ||
 2838              	 .loc 3 1396 0
 2839 0058 BB88     	 ldrh r3,[r7,#4]
 2840 005a 2D2B     	 cmp r3,#45
 2841 005c 09D0     	 beq .L186
 2842              	 .loc 3 1396 0 is_stmt 0 discriminator 1
 2843 005e BB88     	 ldrh r3,[r7,#4]
 2844 0060 1A2B     	 cmp r3,#26
 2845 0062 06D0     	 beq .L186
1397:../SSC/Src/ecatslv.c ****         (alStatusCode == ALSTATUSCODE_SYNCERROR) ||
 2846              	 .loc 3 1397 0 is_stmt 1
 2847 0064 BB88     	 ldrh r3,[r7,#4]
 2848 0066 322B     	 cmp r3,#50
 2849 0068 03D0     	 beq .L186
1398:../SSC/Src/ecatslv.c ****         (alStatusCode == ALSTATUSCODE_DCPLLSYNCERROR)
1399:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT7*/
1400:../SSC/Src/ecatslv.c ****         || (bLocalErrorFlag == TRUE))
 2850              	 .loc 3 1400 0
 2851 006a 154B     	 ldr r3,.L189+16
 2852 006c 1B78     	 ldrb r3,[r3]
 2853 006e 002B     	 cmp r3,#0
 2854 0070 03D0     	 beq .L187
 2855              	.L186:
1401:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT7*/
1402:../SSC/Src/ecatslv.c ****     {
1403:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_SINGLEFLASH;
 2856              	 .loc 3 1403 0
 2857 0072 124B     	 ldr r3,.L189+12
 2858 0074 0122     	 movs r2,#1
 2859 0076 1A70     	 strb r2,[r3]
 2860 0078 09E0     	 b .L185
 2861              	.L187:
1404:../SSC/Src/ecatslv.c ****     }
1405:../SSC/Src/ecatslv.c ****     else if((alStatusCode == ALSTATUSCODE_SMWATCHDOG))
 2862              	 .loc 3 1405 0
 2863 007a BB88     	 ldrh r3,[r7,#4]
 2864 007c 1B2B     	 cmp r3,#27
 2865 007e 03D1     	 bne .L188
1406:../SSC/Src/ecatslv.c ****     {
1407:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_DOUBLEFLASH;
 2866              	 .loc 3 1407 0
 2867 0080 0E4B     	 ldr r3,.L189+12
 2868 0082 0222     	 movs r2,#2
 2869 0084 1A70     	 strb r2,[r3]
 2870 0086 02E0     	 b .L185
 2871              	.L188:
1408:../SSC/Src/ecatslv.c ****     }
1409:../SSC/Src/ecatslv.c ****     else
1410:../SSC/Src/ecatslv.c ****     {
1411:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_BLINKING;
 2872              	 .loc 3 1411 0
 2873 0088 0C4B     	 ldr r3,.L189+12
 2874 008a 0D22     	 movs r2,#13
 2875 008c 1A70     	 strb r2,[r3]
 2876              	.L185:
1412:../SSC/Src/ecatslv.c ****     }
1413:../SSC/Src/ecatslv.c ****     u8EcatErrorLed |= LED_OVERRIDE;
 2877              	 .loc 3 1413 0
 2878 008e 0B4B     	 ldr r3,.L189+12
 2879 0090 1B78     	 ldrb r3,[r3]
 2880 0092 43F01003 	 orr r3,r3,#16
 2881 0096 DAB2     	 uxtb r2,r3
 2882 0098 084B     	 ldr r3,.L189+12
 2883 009a 1A70     	 strb r2,[r3]
1414:../SSC/Src/ecatslv.c **** 
1415:../SSC/Src/ecatslv.c ****     HW_EscWriteByte(u8EcatErrorLed,ESC_ERROR_LED_OVERRIDE);
 2884              	 .loc 3 1415 0
 2885 009c 094B     	 ldr r3,.L189+20
 2886 009e 074A     	 ldr r2,.L189+12
 2887 00a0 1278     	 ldrb r2,[r2]
 2888 00a2 1A70     	 strb r2,[r3]
1416:../SSC/Src/ecatslv.c **** }
 2889              	 .loc 3 1416 0
 2890 00a4 1437     	 adds r7,r7,#20
 2891              	.LCFI76:
 2892              	 .cfi_def_cfa_offset 4
 2893 00a6 BD46     	 mov sp,r7
 2894              	.LCFI77:
 2895              	 .cfi_def_cfa_register 13
 2896              	 
 2897 00a8 5DF8047B 	 ldr r7,[sp],#4
 2898              	.LCFI78:
 2899              	 .cfi_restore 7
 2900              	 .cfi_def_cfa_offset 0
 2901 00ac 7047     	 bx lr
 2902              	.L190:
 2903 00ae 00BF     	 .align 2
 2904              	.L189:
 2905 00b0 00000000 	 .word nAlStatus
 2906 00b4 34010154 	 .word 1409351988
 2907 00b8 30010154 	 .word 1409351984
 2908 00bc 00000000 	 .word u8EcatErrorLed
 2909 00c0 00000000 	 .word bLocalErrorFlag
 2910 00c4 39010154 	 .word 1409351993
 2911              	 .cfi_endproc
 2912              	.LFE191:
 2914              	 .section .text.AL_ControlInd,"ax",%progbits
 2915              	 .align 2
 2916              	 .global AL_ControlInd
 2917              	 .thumb
 2918              	 .thumb_func
 2920              	AL_ControlInd:
 2921              	.LFB192:
1417:../SSC/Src/ecatslv.c **** 
1418:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1419:../SSC/Src/ecatslv.c **** /**
1420:../SSC/Src/ecatslv.c ****  \param    alControl        requested new state
1421:../SSC/Src/ecatslv.c ****  \param alStatusCode    requested status code
1422:../SSC/Src/ecatslv.c **** 
1423:../SSC/Src/ecatslv.c ****  \brief    This function handles the EtherCAT State Machine. It is called
1424:../SSC/Src/ecatslv.c ****             * in case of an AL Control event (Bit 0 of AL-Event (Reg 0x220),
1425:../SSC/Src/ecatslv.c ****                when the Master has written the AL Control Register (from ECAT_Main),
1426:../SSC/Src/ecatslv.c ****               alControl contains the content of the AL Control (Reg 0x120)
1427:../SSC/Src/ecatslv.c ****             * in case of a SM-Change event (Bit 4 of AL-Event (Reg 0x220)),
1428:../SSC/Src/ecatslv.c ****               when an Activate SYNCM y register is written by the master (from ECAT_Main),
1429:../SSC/Src/ecatslv.c ****               alControl contains the actual state (Bit 0-3 of AL Status (Reg 0x130))
1430:../SSC/Src/ecatslv.c ****             * in case of a locally expired watchdog (from ECAT_Main),
1431:../SSC/Src/ecatslv.c ****               alControl contains the requested new state (SAFE_OP)
1432:../SSC/Src/ecatslv.c ****             * in case of an application specific event to change the EtherCAT state (from applicati
1433:../SSC/Src/ecatslv.c ****               alControl contains the requested new state (INIT, PRE_OP or SAFE_OP)
1434:../SSC/Src/ecatslv.c **** 
1435:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1436:../SSC/Src/ecatslv.c **** 
1437:../SSC/Src/ecatslv.c **** void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
1438:../SSC/Src/ecatslv.c **** {
 2922              	 .loc 3 1438 0
 2923              	 .cfi_startproc
 2924              	 
 2925              	 
 2926 0000 80B5     	 push {r7,lr}
 2927              	.LCFI79:
 2928              	 .cfi_def_cfa_offset 8
 2929              	 .cfi_offset 7,-8
 2930              	 .cfi_offset 14,-4
 2931 0002 84B0     	 sub sp,sp,#16
 2932              	.LCFI80:
 2933              	 .cfi_def_cfa_offset 24
 2934 0004 00AF     	 add r7,sp,#0
 2935              	.LCFI81:
 2936              	 .cfi_def_cfa_register 7
 2937 0006 0346     	 mov r3,r0
 2938 0008 0A46     	 mov r2,r1
 2939 000a FB71     	 strb r3,[r7,#7]
 2940 000c 1346     	 mov r3,r2
 2941 000e BB80     	 strh r3,[r7,#4]
1439:../SSC/Src/ecatslv.c ****     UINT16        result = 0;
 2942              	 .loc 3 1439 0
 2943 0010 0023     	 movs r3,#0
 2944 0012 FB81     	 strh r3,[r7,#14]
1440:../SSC/Src/ecatslv.c ****     UINT8            bErrAck = 0;
 2945              	 .loc 3 1440 0
 2946 0014 0023     	 movs r3,#0
 2947 0016 7B73     	 strb r3,[r7,#13]
1441:../SSC/Src/ecatslv.c ****     UINT8         stateTrans;
1442:../SSC/Src/ecatslv.c ****     /*deactivate ESM timeout counter*/
1443:../SSC/Src/ecatslv.c ****     EsmTimeoutCounter = -1;
 2948              	 .loc 3 1443 0
 2949 0018 D34B     	 ldr r3,.L258
 2950 001a 4FF6FF72 	 movw r2,#65535
 2951 001e 1A80     	 strh r2,[r3]
1444:../SSC/Src/ecatslv.c ****     bApplEsmPending = TRUE;
 2952              	 .loc 3 1444 0
 2953 0020 D24B     	 ldr r3,.L258+4
 2954 0022 0122     	 movs r2,#1
 2955 0024 1A70     	 strb r2,[r3]
1445:../SSC/Src/ecatslv.c **** 
1446:../SSC/Src/ecatslv.c ****     /* reset the Error Flag in case of acknowledge by the Master */
1447:../SSC/Src/ecatslv.c ****     if ( alControl & STATE_CHANGE )
 2956              	 .loc 3 1447 0
 2957 0026 FB79     	 ldrb r3,[r7,#7]
 2958 0028 03F01003 	 and r3,r3,#16
 2959 002c 002B     	 cmp r3,#0
 2960 002e 09D0     	 beq .L192
1448:../SSC/Src/ecatslv.c ****     {
1449:../SSC/Src/ecatslv.c ****         bErrAck = 1;
 2961              	 .loc 3 1449 0
 2962 0030 0123     	 movs r3,#1
 2963 0032 7B73     	 strb r3,[r7,#13]
1450:../SSC/Src/ecatslv.c ****         nAlStatus &= ~STATE_CHANGE;
 2964              	 .loc 3 1450 0
 2965 0034 CE4B     	 ldr r3,.L258+8
 2966 0036 1B78     	 ldrb r3,[r3]
 2967 0038 23F01003 	 bic r3,r3,#16
 2968 003c DAB2     	 uxtb r2,r3
 2969 003e CC4B     	 ldr r3,.L258+8
 2970 0040 1A70     	 strb r2,[r3]
 2971 0042 12E0     	 b .L193
 2972              	.L192:
1451:../SSC/Src/ecatslv.c ****         /*enable SM2 is moved to state transition block. First check SM Settings.*/
1452:../SSC/Src/ecatslv.c ****     }
1453:../SSC/Src/ecatslv.c ****     else if ((nAlStatus & STATE_CHANGE)
 2973              	 .loc 3 1453 0
 2974 0044 CA4B     	 ldr r3,.L258+8
 2975 0046 1B78     	 ldrb r3,[r3]
 2976 0048 03F01003 	 and r3,r3,#16
 2977 004c 002B     	 cmp r3,#0
 2978 004e 05D0     	 beq .L194
1454:../SSC/Src/ecatslv.c ****         // HBu 17.04.08: the error has to be acknowledged before when sending the same (or a higher
1455:../SSC/Src/ecatslv.c ****         //               (the error was acknowledged with the same state before independent of the 
1456:../SSC/Src/ecatslv.c ****         /*Error Acknowledge with 0xX1 is allowed*/
1457:../SSC/Src/ecatslv.c ****         && (alControl & STATE_MASK) != STATE_INIT)
 2979              	 .loc 3 1457 0
 2980 0050 FB79     	 ldrb r3,[r7,#7]
 2981 0052 03F00F03 	 and r3,r3,#15
 2982 0056 012B     	 cmp r3,#1
 2983 0058 00D0     	 beq .L194
1458:../SSC/Src/ecatslv.c ****     {
1459:../SSC/Src/ecatslv.c ****         /* the error flag (Bit 4) is set in the AL-Status and the ErrAck bit (Bit 4)
1460:../SSC/Src/ecatslv.c ****            is not set in the AL-Control, so the state cannot be set to a higher state
1461:../SSC/Src/ecatslv.c ****            and the new state request will be ignored */
1462:../SSC/Src/ecatslv.c ****         return;
 2984              	 .loc 3 1462 0
 2985 005a 2FE3     	 b .L191
 2986              	.L194:
1463:../SSC/Src/ecatslv.c ****     }
1464:../SSC/Src/ecatslv.c ****     else
1465:../SSC/Src/ecatslv.c ****     {
1466:../SSC/Src/ecatslv.c ****         nAlStatus &= STATE_MASK;
 2987              	 .loc 3 1466 0
 2988 005c C44B     	 ldr r3,.L258+8
 2989 005e 1B78     	 ldrb r3,[r3]
 2990 0060 03F00F03 	 and r3,r3,#15
 2991 0064 DAB2     	 uxtb r2,r3
 2992 0066 C24B     	 ldr r3,.L258+8
 2993 0068 1A70     	 strb r2,[r3]
 2994              	.L193:
1467:../SSC/Src/ecatslv.c ****     }
1468:../SSC/Src/ecatslv.c **** 
1469:../SSC/Src/ecatslv.c ****     /* generate a variable for the state transition
1470:../SSC/Src/ecatslv.c ****       (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
1471:../SSC/Src/ecatslv.c ****     alControl &= STATE_MASK;
 2995              	 .loc 3 1471 0
 2996 006a FB79     	 ldrb r3,[r7,#7]
 2997 006c 03F00F03 	 and r3,r3,#15
 2998 0070 FB71     	 strb r3,[r7,#7]
1472:../SSC/Src/ecatslv.c ****     stateTrans = nAlStatus;
 2999              	 .loc 3 1472 0
 3000 0072 BF4B     	 ldr r3,.L258+8
 3001 0074 1B78     	 ldrb r3,[r3]
 3002 0076 3B73     	 strb r3,[r7,#12]
1473:../SSC/Src/ecatslv.c ****     stateTrans <<= 4;
 3003              	 .loc 3 1473 0
 3004 0078 3B7B     	 ldrb r3,[r7,#12]
 3005 007a 1B01     	 lsls r3,r3,#4
 3006 007c 3B73     	 strb r3,[r7,#12]
1474:../SSC/Src/ecatslv.c ****     stateTrans += alControl;
 3007              	 .loc 3 1474 0
 3008 007e 3A7B     	 ldrb r2,[r7,#12]
 3009 0080 FB79     	 ldrb r3,[r7,#7]
 3010 0082 1344     	 add r3,r3,r2
 3011 0084 3B73     	 strb r3,[r7,#12]
1475:../SSC/Src/ecatslv.c **** 
1476:../SSC/Src/ecatslv.c ****     /* check the SYNCM settings depending on the state transition */
1477:../SSC/Src/ecatslv.c ****     switch ( stateTrans )
 3012              	 .loc 3 1477 0
 3013 0086 3B7B     	 ldrb r3,[r7,#12]
 3014 0088 442B     	 cmp r3,#68
 3015 008a 29D0     	 beq .L197
 3016 008c 442B     	 cmp r3,#68
 3017 008e 0BDC     	 bgt .L198
 3018 0090 222B     	 cmp r3,#34
 3019 0092 15D0     	 beq .L199
 3020 0094 222B     	 cmp r3,#34
 3021 0096 02DC     	 bgt .L200
 3022 0098 122B     	 cmp r3,#18
 3023 009a 11D0     	 beq .L199
 3024 009c 28E0     	 b .L196
 3025              	.L200:
 3026 009e 242B     	 cmp r3,#36
 3027 00a0 14D0     	 beq .L201
 3028 00a2 422B     	 cmp r3,#66
 3029 00a4 0CD0     	 beq .L199
 3030 00a6 23E0     	 b .L196
 3031              	.L198:
 3032 00a8 822B     	 cmp r3,#130
 3033 00aa 09D0     	 beq .L199
 3034 00ac 822B     	 cmp r3,#130
 3035 00ae 02DC     	 bgt .L202
 3036 00b0 482B     	 cmp r3,#72
 3037 00b2 15D0     	 beq .L197
 3038 00b4 1CE0     	 b .L196
 3039              	.L202:
 3040 00b6 842B     	 cmp r3,#132
 3041 00b8 12D0     	 beq .L197
 3042 00ba 882B     	 cmp r3,#136
 3043 00bc 10D0     	 beq .L197
 3044 00be 17E0     	 b .L196
 3045              	.L199:
1478:../SSC/Src/ecatslv.c ****     {
1479:../SSC/Src/ecatslv.c ****     case INIT_2_PREOP:
1480:../SSC/Src/ecatslv.c ****     case OP_2_PREOP:
1481:../SSC/Src/ecatslv.c ****     case SAFEOP_2_PREOP:
1482:../SSC/Src/ecatslv.c ****     case PREOP_2_PREOP:
1483:../SSC/Src/ecatslv.c ****         /* in PREOP only the SYNCM settings for SYNCM0 and SYNCM1 (mailbox)
1484:../SSC/Src/ecatslv.c ****            are checked, if result is unequal 0, the slave will stay in or
1485:../SSC/Src/ecatslv.c ****            switch to INIT and set the ErrorInd Bit (bit 4) of the AL-Status */
1486:../SSC/Src/ecatslv.c ****         result = CheckSmSettings(MAILBOX_READ+1);
 3046              	 .loc 3 1486 0
 3047 00c0 0220     	 movs r0,#2
 3048 00c2 FFF7FEFF 	 bl CheckSmSettings
 3049 00c6 0346     	 mov r3,r0
 3050 00c8 FB81     	 strh r3,[r7,#14]
1487:../SSC/Src/ecatslv.c ****         break;
 3051              	 .loc 3 1487 0
 3052 00ca 11E0     	 b .L196
 3053              	.L201:
1488:../SSC/Src/ecatslv.c ****     case PREOP_2_SAFEOP:
1489:../SSC/Src/ecatslv.c ****         {
1490:../SSC/Src/ecatslv.c ****         /* before checking the SYNCM settings for SYNCM2 and SYNCM3 (process data)
1491:../SSC/Src/ecatslv.c ****            the expected length of input data (nPdInputSize) and output data (nPdOutputSize)
1492:../SSC/Src/ecatslv.c ****             could be adapted (changed by PDO-Assign and/or PDO-Mapping)
1493:../SSC/Src/ecatslv.c ****             if result is unequal 0, the slave will stay in PREOP and set
1494:../SSC/Src/ecatslv.c ****             the ErrorInd Bit (bit 4) of the AL-Status */
1495:../SSC/Src/ecatslv.c ****         result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
 3054              	 .loc 3 1495 0
 3055 00cc A948     	 ldr r0,.L258+12
 3056 00ce AA49     	 ldr r1,.L258+16
 3057 00d0 FFF7FEFF 	 bl APPL_GenerateMapping
 3058 00d4 0346     	 mov r3,r0
 3059 00d6 FB81     	 strh r3,[r7,#14]
1496:../SSC/Src/ecatslv.c **** 
1497:../SSC/Src/ecatslv.c ****             if (result != 0)
 3060              	 .loc 3 1497 0
 3061 00d8 FB89     	 ldrh r3,[r7,#14]
 3062 00da 002B     	 cmp r3,#0
 3063 00dc 00D0     	 beq .L197
1498:../SSC/Src/ecatslv.c ****             {
1499:../SSC/Src/ecatslv.c ****                 break;
 3064              	 .loc 3 1499 0
 3065 00de 07E0     	 b .L196
 3066              	.L197:
1500:../SSC/Src/ecatslv.c ****             }
1501:../SSC/Src/ecatslv.c ****         }
1502:../SSC/Src/ecatslv.c ****     case SAFEOP_2_OP:
1503:../SSC/Src/ecatslv.c ****     case OP_2_SAFEOP:
1504:../SSC/Src/ecatslv.c ****     case SAFEOP_2_SAFEOP:
1505:../SSC/Src/ecatslv.c ****     case OP_2_OP:
1506:../SSC/Src/ecatslv.c ****         /* in SAFEOP or OP the SYNCM settings for all SYNCM are checked
1507:../SSC/Src/ecatslv.c ****            if result is unequal 0, the slave will stay in or
1508:../SSC/Src/ecatslv.c ****            switch to PREOP and set the ErrorInd Bit (bit 4) of the AL-Status */
1509:../SSC/Src/ecatslv.c ****         result = CheckSmSettings(nMaxSyncMan);
 3067              	 .loc 3 1509 0
 3068 00e0 A64B     	 ldr r3,.L258+20
 3069 00e2 1B78     	 ldrb r3,[r3]
 3070 00e4 1846     	 mov r0,r3
 3071 00e6 FFF7FEFF 	 bl CheckSmSettings
 3072 00ea 0346     	 mov r3,r0
 3073 00ec FB81     	 strh r3,[r7,#14]
1510:../SSC/Src/ecatslv.c ****         break;
 3074              	 .loc 3 1510 0
 3075 00ee 00BF     	 nop
 3076              	.L196:
1511:../SSC/Src/ecatslv.c **** 
1512:../SSC/Src/ecatslv.c ****     }
1513:../SSC/Src/ecatslv.c **** 
1514:../SSC/Src/ecatslv.c ****     if ( result == 0 )
 3077              	 .loc 3 1514 0
 3078 00f0 FB89     	 ldrh r3,[r7,#14]
 3079 00f2 002B     	 cmp r3,#0
 3080 00f4 40F00E82 	 bne .L203
1515:../SSC/Src/ecatslv.c ****     {
1516:../SSC/Src/ecatslv.c ****         /* execute the corresponding local management service(s) depending on the state transition 
1517:../SSC/Src/ecatslv.c ****         nEcatStateTrans = 0;
 3081              	 .loc 3 1517 0
 3082 00f8 A14B     	 ldr r3,.L258+24
 3083 00fa 0022     	 movs r2,#0
 3084 00fc 1A80     	 strh r2,[r3]
1518:../SSC/Src/ecatslv.c ****         switch ( stateTrans )
 3085              	 .loc 3 1518 0
 3086 00fe 3B7B     	 ldrb r3,[r7,#12]
 3087 0100 113B     	 subs r3,r3,#17
 3088 0102 772B     	 cmp r3,#119
 3089 0104 00F20282 	 bhi .L204
 3090 0108 01A2     	 adr r2,.L206
 3091 010a 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 3092 010e 00BF     	 .p2align 2
 3093              	.L206:
 3094 0110 C3040000 	 .word .L205+1
 3095 0114 01030000 	 .word .L207+1
 3096 0118 F1020000 	 .word .L208+1
 3097 011c 07050000 	 .word .L209+1
 3098 0120 0D050000 	 .word .L204+1
 3099 0124 0D050000 	 .word .L204+1
 3100 0128 0D050000 	 .word .L204+1
 3101 012c 07050000 	 .word .L209+1
 3102 0130 0D050000 	 .word .L204+1
 3103 0134 0D050000 	 .word .L204+1
 3104 0138 0D050000 	 .word .L204+1
 3105 013c 0D050000 	 .word .L204+1
 3106 0140 0D050000 	 .word .L204+1
 3107 0144 0D050000 	 .word .L204+1
 3108 0148 0D050000 	 .word .L204+1
 3109 014c 0D050000 	 .word .L204+1
 3110 0150 B1040000 	 .word .L210+1
 3111 0154 C7040000 	 .word .L211+1
 3112 0158 07050000 	 .word .L209+1
 3113 015c 8F030000 	 .word .L212+1
 3114 0160 0D050000 	 .word .L204+1
 3115 0164 0D050000 	 .word .L204+1
 3116 0168 0D050000 	 .word .L204+1
 3117 016c 07050000 	 .word .L209+1
 3118 0170 0D050000 	 .word .L204+1
 3119 0174 0D050000 	 .word .L204+1
 3120 0178 0D050000 	 .word .L204+1
 3121 017c 0D050000 	 .word .L204+1
 3122 0180 0D050000 	 .word .L204+1
 3123 0184 0D050000 	 .word .L204+1
 3124 0188 0D050000 	 .word .L204+1
 3125 018c 0D050000 	 .word .L204+1
 3126 0190 F7020000 	 .word .L213+1
 3127 0194 07050000 	 .word .L209+1
 3128 0198 0D050000 	 .word .L204+1
 3129 019c 07050000 	 .word .L209+1
 3130 01a0 0D050000 	 .word .L204+1
 3131 01a4 0D050000 	 .word .L204+1
 3132 01a8 0D050000 	 .word .L204+1
 3133 01ac 07050000 	 .word .L209+1
 3134 01b0 0D050000 	 .word .L204+1
 3135 01b4 0D050000 	 .word .L204+1
 3136 01b8 0D050000 	 .word .L204+1
 3137 01bc 0D050000 	 .word .L204+1
 3138 01c0 0D050000 	 .word .L204+1
 3139 01c4 0D050000 	 .word .L204+1
 3140 01c8 0D050000 	 .word .L204+1
 3141 01cc 0D050000 	 .word .L204+1
 3142 01d0 93040000 	 .word .L214+1
 3143 01d4 65040000 	 .word .L215+1
 3144 01d8 07050000 	 .word .L209+1
 3145 01dc C7040000 	 .word .L211+1
 3146 01e0 0D050000 	 .word .L204+1
 3147 01e4 0D050000 	 .word .L204+1
 3148 01e8 0D050000 	 .word .L204+1
 3149 01ec E9030000 	 .word .L216+1
 3150 01f0 0D050000 	 .word .L204+1
 3151 01f4 0D050000 	 .word .L204+1
 3152 01f8 0D050000 	 .word .L204+1
 3153 01fc 0D050000 	 .word .L204+1
 3154 0200 0D050000 	 .word .L204+1
 3155 0204 0D050000 	 .word .L204+1
 3156 0208 0D050000 	 .word .L204+1
 3157 020c 0D050000 	 .word .L204+1
 3158 0210 0D050000 	 .word .L204+1
 3159 0214 0D050000 	 .word .L204+1
 3160 0218 0D050000 	 .word .L204+1
 3161 021c 0D050000 	 .word .L204+1
 3162 0220 0D050000 	 .word .L204+1
 3163 0224 0D050000 	 .word .L204+1
 3164 0228 0D050000 	 .word .L204+1
 3165 022c 0D050000 	 .word .L204+1
 3166 0230 0D050000 	 .word .L204+1
 3167 0234 0D050000 	 .word .L204+1
 3168 0238 0D050000 	 .word .L204+1
 3169 023c 0D050000 	 .word .L204+1
 3170 0240 0D050000 	 .word .L204+1
 3171 0244 0D050000 	 .word .L204+1
 3172 0248 0D050000 	 .word .L204+1
 3173 024c 0D050000 	 .word .L204+1
 3174 0250 0D050000 	 .word .L204+1
 3175 0254 0D050000 	 .word .L204+1
 3176 0258 0D050000 	 .word .L204+1
 3177 025c 0D050000 	 .word .L204+1
 3178 0260 0D050000 	 .word .L204+1
 3179 0264 0D050000 	 .word .L204+1
 3180 0268 0D050000 	 .word .L204+1
 3181 026c 0D050000 	 .word .L204+1
 3182 0270 0D050000 	 .word .L204+1
 3183 0274 0D050000 	 .word .L204+1
 3184 0278 0D050000 	 .word .L204+1
 3185 027c 0D050000 	 .word .L204+1
 3186 0280 0D050000 	 .word .L204+1
 3187 0284 0D050000 	 .word .L204+1
 3188 0288 0D050000 	 .word .L204+1
 3189 028c 0D050000 	 .word .L204+1
 3190 0290 0D050000 	 .word .L204+1
 3191 0294 0D050000 	 .word .L204+1
 3192 0298 0D050000 	 .word .L204+1
 3193 029c 0D050000 	 .word .L204+1
 3194 02a0 0D050000 	 .word .L204+1
 3195 02a4 0D050000 	 .word .L204+1
 3196 02a8 0D050000 	 .word .L204+1
 3197 02ac 0D050000 	 .word .L204+1
 3198 02b0 0D050000 	 .word .L204+1
 3199 02b4 0D050000 	 .word .L204+1
 3200 02b8 0D050000 	 .word .L204+1
 3201 02bc 0D050000 	 .word .L204+1
 3202 02c0 0D050000 	 .word .L204+1
 3203 02c4 0D050000 	 .word .L204+1
 3204 02c8 0D050000 	 .word .L204+1
 3205 02cc 0D050000 	 .word .L204+1
 3206 02d0 75040000 	 .word .L217+1
 3207 02d4 47040000 	 .word .L218+1
 3208 02d8 07050000 	 .word .L209+1
 3209 02dc 37040000 	 .word .L219+1
 3210 02e0 0D050000 	 .word .L204+1
 3211 02e4 0D050000 	 .word .L204+1
 3212 02e8 0D050000 	 .word .L204+1
 3213 02ec C7040000 	 .word .L211+1
 3214              	 .p2align 1
 3215              	.L208:
1519:../SSC/Src/ecatslv.c ****         {
1520:../SSC/Src/ecatslv.c ****         case INIT_2_BOOT    :
1521:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_BOOTNOTSUPP;
 3216              	 .loc 3 1521 0
 3217 02f0 1323     	 movs r3,#19
 3218 02f2 FB81     	 strh r3,[r7,#14]
1522:../SSC/Src/ecatslv.c **** 
1523:../SSC/Src/ecatslv.c **** 
1524:../SSC/Src/ecatslv.c **** 
1525:../SSC/Src/ecatslv.c ****             break;
 3219              	 .loc 3 1525 0
 3220 02f4 0DE1     	 b .L220
 3221              	.L213:
1526:../SSC/Src/ecatslv.c **** 
1527:../SSC/Src/ecatslv.c ****         case BOOT_2_INIT    :
1528:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_BOOTNOTSUPP;
 3222              	 .loc 3 1528 0
 3223 02f6 1323     	 movs r3,#19
 3224 02f8 FB81     	 strh r3,[r7,#14]
1529:../SSC/Src/ecatslv.c **** 
1530:../SSC/Src/ecatslv.c ****             BackToInitTransition();
 3225              	 .loc 3 1530 0
 3226 02fa FFF7FEFF 	 bl BackToInitTransition
1531:../SSC/Src/ecatslv.c **** 
1532:../SSC/Src/ecatslv.c **** 
1533:../SSC/Src/ecatslv.c **** 
1534:../SSC/Src/ecatslv.c ****             break;
 3227              	 .loc 3 1534 0
 3228 02fe 08E1     	 b .L220
 3229              	.L207:
1535:../SSC/Src/ecatslv.c ****         case INIT_2_PREOP :
1536:../SSC/Src/ecatslv.c **** 
1537:../SSC/Src/ecatslv.c ****            UpdateEEPROMLoadedState();
 3230              	 .loc 3 1537 0
 3231 0300 FFF7FEFF 	 bl UpdateEEPROMLoadedState
1538:../SSC/Src/ecatslv.c **** 
1539:../SSC/Src/ecatslv.c ****             if (EepromLoaded == FALSE)
 3232              	 .loc 3 1539 0
 3233 0304 1F4B     	 ldr r3,.L258+28
 3234 0306 1B78     	 ldrb r3,[r3]
 3235 0308 83F00103 	 eor r3,r3,#1
 3236 030c DBB2     	 uxtb r3,r3
 3237 030e 002B     	 cmp r3,#0
 3238 0310 01D0     	 beq .L221
1540:../SSC/Src/ecatslv.c ****             {
1541:../SSC/Src/ecatslv.c ****                 //return an error if the EEPROM was not loaded correct  (device restart is required
1542:../SSC/Src/ecatslv.c ****                 result = ALSTATUSCODE_EE_ERROR;
 3239              	 .loc 3 1542 0
 3240 0312 5123     	 movs r3,#81
 3241 0314 FB81     	 strh r3,[r7,#14]
 3242              	.L221:
1543:../SSC/Src/ecatslv.c ****             }
1544:../SSC/Src/ecatslv.c ****             if (result == 0)
 3243              	 .loc 3 1544 0
 3244 0316 FB89     	 ldrh r3,[r7,#14]
 3245 0318 002B     	 cmp r3,#0
 3246 031a 37D1     	 bne .L222
1545:../SSC/Src/ecatslv.c ****             {
1546:../SSC/Src/ecatslv.c ****             /* MBX_StartMailboxHandler (in mailbox.c) checks if the areas of the mailbox
1547:../SSC/Src/ecatslv.c ****                sync managers SYNCM0 and SYNCM1 overlap each other
1548:../SSC/Src/ecatslv.c ****               if result is unequal 0, the slave will stay in INIT
1549:../SSC/Src/ecatslv.c ****               and sets the ErrorInd Bit (bit 4) of the AL-Status */
1550:../SSC/Src/ecatslv.c ****             result = MBX_StartMailboxHandler();
 3247              	 .loc 3 1550 0
 3248 031c FFF7FEFF 	 bl MBX_StartMailboxHandler
 3249 0320 0346     	 mov r3,r0
 3250 0322 FB81     	 strh r3,[r7,#14]
1551:../SSC/Src/ecatslv.c ****             if (result == 0)
 3251              	 .loc 3 1551 0
 3252 0324 FB89     	 ldrh r3,[r7,#14]
 3253 0326 002B     	 cmp r3,#0
 3254 0328 0CD1     	 bne .L223
1552:../SSC/Src/ecatslv.c ****             {
1553:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3255              	 .loc 3 1553 0
 3256 032a 104B     	 ldr r3,.L258+4
 3257 032c 0022     	 movs r2,#0
 3258 032e 1A70     	 strb r2,[r3]
1554:../SSC/Src/ecatslv.c ****                 /* additionally there could be an application specific check (in ecatappl.c)
1555:../SSC/Src/ecatslv.c ****                    if the state transition from INIT to PREOP should be done
1556:../SSC/Src/ecatslv.c ****                  if result is unequal 0, the slave will stay in INIT
1557:../SSC/Src/ecatslv.c ****                  and sets the ErrorInd Bit (bit 4) of the AL-Status */
1558:../SSC/Src/ecatslv.c ****                 result = APPL_StartMailboxHandler();
 3259              	 .loc 3 1558 0
 3260 0330 FFF7FEFF 	 bl APPL_StartMailboxHandler
 3261 0334 0346     	 mov r3,r0
 3262 0336 FB81     	 strh r3,[r7,#14]
1559:../SSC/Src/ecatslv.c ****                 if ( result == 0 )
 3263              	 .loc 3 1559 0
 3264 0338 FB89     	 ldrh r3,[r7,#14]
 3265 033a 002B     	 cmp r3,#0
 3266 033c 02D1     	 bne .L223
1560:../SSC/Src/ecatslv.c ****                 {
1561:../SSC/Src/ecatslv.c ****                     bMbxRunning = TRUE;
 3267              	 .loc 3 1561 0
 3268 033e 124B     	 ldr r3,.L258+32
 3269 0340 0122     	 movs r2,#1
 3270 0342 1A70     	 strb r2,[r3]
 3271              	.L223:
1562:../SSC/Src/ecatslv.c ****                 }
1563:../SSC/Src/ecatslv.c ****             }
1564:../SSC/Src/ecatslv.c **** 
1565:../SSC/Src/ecatslv.c ****             if(result != 0 && result != NOERROR_INWORK)
 3272              	 .loc 3 1565 0
 3273 0344 FB89     	 ldrh r3,[r7,#14]
 3274 0346 002B     	 cmp r3,#0
 3275 0348 20D0     	 beq .L222
 3276              	 .loc 3 1565 0 is_stmt 0 discriminator 1
 3277 034a FB89     	 ldrh r3,[r7,#14]
 3278 034c FF2B     	 cmp r3,#255
 3279 034e 1DD0     	 beq .L222
1566:../SSC/Src/ecatslv.c ****             {
1567:../SSC/Src/ecatslv.c ****                 /*Stop APPL Mbx handler if APPL Start Mbx handler was called before*/
1568:../SSC/Src/ecatslv.c ****                     if (!bApplEsmPending)
 3280              	 .loc 3 1568 0 is_stmt 1
 3281 0350 064B     	 ldr r3,.L258+4
 3282 0352 1B78     	 ldrb r3,[r3]
 3283 0354 83F00103 	 eor r3,r3,#1
 3284 0358 DBB2     	 uxtb r3,r3
 3285 035a 002B     	 cmp r3,#0
 3286 035c 01D0     	 beq .L224
1569:../SSC/Src/ecatslv.c ****                     {
1570:../SSC/Src/ecatslv.c ****                         APPL_StopMailboxHandler();
 3287              	 .loc 3 1570 0
 3288 035e FFF7FEFF 	 bl APPL_StopMailboxHandler
 3289              	.L224:
1571:../SSC/Src/ecatslv.c ****                     }
1572:../SSC/Src/ecatslv.c **** 
1573:../SSC/Src/ecatslv.c ****                  MBX_StopMailboxHandler();
 3290              	 .loc 3 1573 0
 3291 0362 FFF7FEFF 	 bl MBX_StopMailboxHandler
1574:../SSC/Src/ecatslv.c ****             }
1575:../SSC/Src/ecatslv.c **** 
1576:../SSC/Src/ecatslv.c ****             }
1577:../SSC/Src/ecatslv.c ****             break;
 3292              	 .loc 3 1577 0
 3293 0366 D4E0     	 b .L220
 3294              	.L259:
 3295              	 .align 2
 3296              	.L258:
 3297 0368 00000000 	 .word EsmTimeoutCounter
 3298 036c 00000000 	 .word bApplEsmPending
 3299 0370 00000000 	 .word nAlStatus
 3300 0374 00000000 	 .word nPdInputSize
 3301 0378 00000000 	 .word nPdOutputSize
 3302 037c 00000000 	 .word nMaxSyncMan
 3303 0380 00000000 	 .word nEcatStateTrans
 3304 0384 00000000 	 .word EepromLoaded
 3305 0388 00000000 	 .word bMbxRunning
 3306              	.L222:
 3307 038c C1E0     	 b .L220
 3308              	.L212:
1578:../SSC/Src/ecatslv.c **** 
1579:../SSC/Src/ecatslv.c ****         case PREOP_2_SAFEOP:
1580:../SSC/Src/ecatslv.c ****             /* start the input handler (function is defined above) */
1581:../SSC/Src/ecatslv.c ****             result = StartInputHandler();
 3309              	 .loc 3 1581 0
 3310 038e FFF7FEFF 	 bl StartInputHandler
 3311 0392 0346     	 mov r3,r0
 3312 0394 FB81     	 strh r3,[r7,#14]
1582:../SSC/Src/ecatslv.c ****             if ( result == 0 )
 3313              	 .loc 3 1582 0
 3314 0396 FB89     	 ldrh r3,[r7,#14]
 3315 0398 002B     	 cmp r3,#0
 3316 039a 12D1     	 bne .L225
1583:../SSC/Src/ecatslv.c ****             {
1584:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3317              	 .loc 3 1584 0
 3318 039c AC4B     	 ldr r3,.L260
 3319 039e 0022     	 movs r2,#0
 3320 03a0 1A70     	 strb r2,[r3]
1585:../SSC/Src/ecatslv.c ****                 result = APPL_StartInputHandler(&u16ALEventMask);
 3321              	 .loc 3 1585 0
 3322 03a2 AC48     	 ldr r0,.L260+4
 3323 03a4 FFF7FEFF 	 bl APPL_StartInputHandler
 3324 03a8 0346     	 mov r3,r0
 3325 03aa FB81     	 strh r3,[r7,#14]
1586:../SSC/Src/ecatslv.c **** 
1587:../SSC/Src/ecatslv.c ****                 if(result == 0)
 3326              	 .loc 3 1587 0
 3327 03ac FB89     	 ldrh r3,[r7,#14]
 3328 03ae 002B     	 cmp r3,#0
 3329 03b0 07D1     	 bne .L225
1588:../SSC/Src/ecatslv.c ****                 {
1589:../SSC/Src/ecatslv.c ****                     /* initialize the AL Event Mask register (0x204) */
1590:../SSC/Src/ecatslv.c ****                     SetALEventMask( u16ALEventMask );
 3330              	 .loc 3 1590 0
 3331 03b2 A84B     	 ldr r3,.L260+4
 3332 03b4 1B88     	 ldrh r3,[r3]
 3333 03b6 1846     	 mov r0,r3
 3334 03b8 FFF7FEFF 	 bl SetALEventMask
1591:../SSC/Src/ecatslv.c **** 
1592:../SSC/Src/ecatslv.c ****                     bEcatInputUpdateRunning = TRUE;
 3335              	 .loc 3 1592 0
 3336 03bc A64B     	 ldr r3,.L260+8
 3337 03be 0122     	 movs r2,#1
 3338 03c0 1A70     	 strb r2,[r3]
 3339              	.L225:
1593:../SSC/Src/ecatslv.c ****                 }
1594:../SSC/Src/ecatslv.c ****             }
1595:../SSC/Src/ecatslv.c **** 
1596:../SSC/Src/ecatslv.c ****             /*if one start input handler returned an error stop the input handler*/
1597:../SSC/Src/ecatslv.c ****             if(result != 0 && result != NOERROR_INWORK)
 3340              	 .loc 3 1597 0
 3341 03c2 FB89     	 ldrh r3,[r7,#14]
 3342 03c4 002B     	 cmp r3,#0
 3343 03c6 0ED0     	 beq .L226
 3344              	 .loc 3 1597 0 is_stmt 0 discriminator 1
 3345 03c8 FB89     	 ldrh r3,[r7,#14]
 3346 03ca FF2B     	 cmp r3,#255
 3347 03cc 0BD0     	 beq .L226
1598:../SSC/Src/ecatslv.c ****             {
1599:../SSC/Src/ecatslv.c ****                 if(!bApplEsmPending)
 3348              	 .loc 3 1599 0 is_stmt 1
 3349 03ce A04B     	 ldr r3,.L260
 3350 03d0 1B78     	 ldrb r3,[r3]
 3351 03d2 83F00103 	 eor r3,r3,#1
 3352 03d6 DBB2     	 uxtb r3,r3
 3353 03d8 002B     	 cmp r3,#0
 3354 03da 01D0     	 beq .L227
1600:../SSC/Src/ecatslv.c ****                 {
1601:../SSC/Src/ecatslv.c ****                     /*Call only the APPL stop handler if the APPL start handler was called before*/
1602:../SSC/Src/ecatslv.c ****                     /*The application can react to the state transition in the function APPL_StopIn
1603:../SSC/Src/ecatslv.c ****                     APPL_StopInputHandler();
 3355              	 .loc 3 1603 0
 3356 03dc FFF7FEFF 	 bl APPL_StopInputHandler
 3357              	.L227:
1604:../SSC/Src/ecatslv.c ****                 }
1605:../SSC/Src/ecatslv.c **** 
1606:../SSC/Src/ecatslv.c ****                 StopInputHandler();
 3358              	 .loc 3 1606 0
 3359 03e0 FFF7FEFF 	 bl StopInputHandler
1607:../SSC/Src/ecatslv.c ****             }
1608:../SSC/Src/ecatslv.c ****             break;
 3360              	 .loc 3 1608 0
 3361 03e4 95E0     	 b .L220
 3362              	.L226:
 3363              	 .loc 3 1608 0 is_stmt 0 discriminator 2
 3364 03e6 94E0     	 b .L220
 3365              	.L216:
1609:../SSC/Src/ecatslv.c **** 
1610:../SSC/Src/ecatslv.c ****         case SAFEOP_2_OP:
1611:../SSC/Src/ecatslv.c ****             /* start the output handler (function is defined above) */
1612:../SSC/Src/ecatslv.c ****             result = StartOutputHandler();
 3366              	 .loc 3 1612 0 is_stmt 1
 3367 03e8 FFF7FEFF 	 bl StartOutputHandler
 3368 03ec 0346     	 mov r3,r0
 3369 03ee FB81     	 strh r3,[r7,#14]
1613:../SSC/Src/ecatslv.c ****             if(result == 0)
 3370              	 .loc 3 1613 0
 3371 03f0 FB89     	 ldrh r3,[r7,#14]
 3372 03f2 002B     	 cmp r3,#0
 3373 03f4 0CD1     	 bne .L228
1614:../SSC/Src/ecatslv.c ****             {
1615:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3374              	 .loc 3 1615 0
 3375 03f6 964B     	 ldr r3,.L260
 3376 03f8 0022     	 movs r2,#0
 3377 03fa 1A70     	 strb r2,[r3]
1616:../SSC/Src/ecatslv.c ****                 result = APPL_StartOutputHandler();
 3378              	 .loc 3 1616 0
 3379 03fc FFF7FEFF 	 bl APPL_StartOutputHandler
 3380 0400 0346     	 mov r3,r0
 3381 0402 FB81     	 strh r3,[r7,#14]
1617:../SSC/Src/ecatslv.c **** 
1618:../SSC/Src/ecatslv.c ****                 if(result == 0)
 3382              	 .loc 3 1618 0
 3383 0404 FB89     	 ldrh r3,[r7,#14]
 3384 0406 002B     	 cmp r3,#0
 3385 0408 02D1     	 bne .L228
1619:../SSC/Src/ecatslv.c ****                 {
1620:../SSC/Src/ecatslv.c ****                     /*Device is in OPERATINAL*/
1621:../SSC/Src/ecatslv.c ****                     bEcatOutputUpdateRunning = TRUE;
 3386              	 .loc 3 1621 0
 3387 040a 944B     	 ldr r3,.L260+12
 3388 040c 0122     	 movs r2,#1
 3389 040e 1A70     	 strb r2,[r3]
 3390              	.L228:
1622:../SSC/Src/ecatslv.c ****                 }
1623:../SSC/Src/ecatslv.c **** 
1624:../SSC/Src/ecatslv.c ****             }
1625:../SSC/Src/ecatslv.c **** 
1626:../SSC/Src/ecatslv.c ****             if ( result != 0 && result != NOERROR_INWORK)
 3391              	 .loc 3 1626 0
 3392 0410 FB89     	 ldrh r3,[r7,#14]
 3393 0412 002B     	 cmp r3,#0
 3394 0414 0ED0     	 beq .L229
 3395              	 .loc 3 1626 0 is_stmt 0 discriminator 1
 3396 0416 FB89     	 ldrh r3,[r7,#14]
 3397 0418 FF2B     	 cmp r3,#255
 3398 041a 0BD0     	 beq .L229
1627:../SSC/Src/ecatslv.c ****             {
1628:../SSC/Src/ecatslv.c ****                     if (!bApplEsmPending)
 3399              	 .loc 3 1628 0 is_stmt 1
 3400 041c 8C4B     	 ldr r3,.L260
 3401 041e 1B78     	 ldrb r3,[r3]
 3402 0420 83F00103 	 eor r3,r3,#1
 3403 0424 DBB2     	 uxtb r3,r3
 3404 0426 002B     	 cmp r3,#0
 3405 0428 01D0     	 beq .L230
1629:../SSC/Src/ecatslv.c ****                     {
1630:../SSC/Src/ecatslv.c ****                         APPL_StopOutputHandler();
 3406              	 .loc 3 1630 0
 3407 042a FFF7FEFF 	 bl APPL_StopOutputHandler
 3408              	.L230:
1631:../SSC/Src/ecatslv.c ****                     }
1632:../SSC/Src/ecatslv.c **** 
1633:../SSC/Src/ecatslv.c ****                 StopOutputHandler();
 3409              	 .loc 3 1633 0
 3410 042e FFF7FEFF 	 bl StopOutputHandler
1634:../SSC/Src/ecatslv.c ****             }
1635:../SSC/Src/ecatslv.c **** 
1636:../SSC/Src/ecatslv.c ****             break;
 3411              	 .loc 3 1636 0
 3412 0432 6EE0     	 b .L220
 3413              	.L229:
 3414              	 .loc 3 1636 0 is_stmt 0 discriminator 3
 3415 0434 6DE0     	 b .L220
 3416              	.L219:
1637:../SSC/Src/ecatslv.c **** 
1638:../SSC/Src/ecatslv.c ****         case OP_2_SAFEOP:
1639:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1640:../SSC/Src/ecatslv.c ****             APPL_StopOutputHandler();
 3417              	 .loc 3 1640 0 is_stmt 1
 3418 0436 FFF7FEFF 	 bl APPL_StopOutputHandler
1641:../SSC/Src/ecatslv.c **** 
1642:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3419              	 .loc 3 1642 0
 3420 043a FFF7FEFF 	 bl StopOutputHandler
1643:../SSC/Src/ecatslv.c **** 
1644:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3421              	 .loc 3 1644 0
 3422 043e 844B     	 ldr r3,.L260
 3423 0440 0022     	 movs r2,#0
 3424 0442 1A70     	 strb r2,[r3]
1645:../SSC/Src/ecatslv.c **** 
1646:../SSC/Src/ecatslv.c ****             break;
 3425              	 .loc 3 1646 0
 3426 0444 65E0     	 b .L220
 3427              	.L218:
1647:../SSC/Src/ecatslv.c **** 
1648:../SSC/Src/ecatslv.c ****         case OP_2_PREOP:
1649:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1650:../SSC/Src/ecatslv.c ****             result = APPL_StopOutputHandler();
 3428              	 .loc 3 1650 0
 3429 0446 FFF7FEFF 	 bl APPL_StopOutputHandler
 3430 044a 0346     	 mov r3,r0
 3431 044c FB81     	 strh r3,[r7,#14]
1651:../SSC/Src/ecatslv.c **** 
1652:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3432              	 .loc 3 1652 0
 3433 044e FFF7FEFF 	 bl StopOutputHandler
1653:../SSC/Src/ecatslv.c **** 
1654:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3434              	 .loc 3 1654 0
 3435 0452 7F4B     	 ldr r3,.L260
 3436 0454 0022     	 movs r2,#0
 3437 0456 1A70     	 strb r2,[r3]
1655:../SSC/Src/ecatslv.c **** 
1656:../SSC/Src/ecatslv.c ****             if (result != 0)
 3438              	 .loc 3 1656 0
 3439 0458 FB89     	 ldrh r3,[r7,#14]
 3440 045a 002B     	 cmp r3,#0
 3441 045c 00D0     	 beq .L231
1657:../SSC/Src/ecatslv.c ****             {
1658:../SSC/Src/ecatslv.c ****                 break;
 3442              	 .loc 3 1658 0 discriminator 4
 3443 045e 58E0     	 b .L220
 3444              	.L231:
1659:../SSC/Src/ecatslv.c ****             }
1660:../SSC/Src/ecatslv.c **** 
1661:../SSC/Src/ecatslv.c ****             stateTrans = SAFEOP_2_PREOP;
 3445              	 .loc 3 1661 0
 3446 0460 4223     	 movs r3,#66
 3447 0462 3B73     	 strb r3,[r7,#12]
 3448              	.L215:
1662:../SSC/Src/ecatslv.c **** 
1663:../SSC/Src/ecatslv.c ****         case SAFEOP_2_PREOP:
1664:../SSC/Src/ecatslv.c ****             /* stop the input handler (function is defined above) */
1665:../SSC/Src/ecatslv.c ****             APPL_StopInputHandler();
 3449              	 .loc 3 1665 0
 3450 0464 FFF7FEFF 	 bl APPL_StopInputHandler
1666:../SSC/Src/ecatslv.c ****            
1667:../SSC/Src/ecatslv.c ****             StopInputHandler();
 3451              	 .loc 3 1667 0
 3452 0468 FFF7FEFF 	 bl StopInputHandler
1668:../SSC/Src/ecatslv.c **** 
1669:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3453              	 .loc 3 1669 0
 3454 046c 784B     	 ldr r3,.L260
 3455 046e 0022     	 movs r2,#0
 3456 0470 1A70     	 strb r2,[r3]
1670:../SSC/Src/ecatslv.c **** 
1671:../SSC/Src/ecatslv.c ****             break;
 3457              	 .loc 3 1671 0
 3458 0472 4EE0     	 b .L220
 3459              	.L217:
1672:../SSC/Src/ecatslv.c **** 
1673:../SSC/Src/ecatslv.c ****         case OP_2_INIT:
1674:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1675:../SSC/Src/ecatslv.c ****             result = APPL_StopOutputHandler();
 3460              	 .loc 3 1675 0
 3461 0474 FFF7FEFF 	 bl APPL_StopOutputHandler
 3462 0478 0346     	 mov r3,r0
 3463 047a FB81     	 strh r3,[r7,#14]
1676:../SSC/Src/ecatslv.c **** 
1677:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3464              	 .loc 3 1677 0
 3465 047c FFF7FEFF 	 bl StopOutputHandler
1678:../SSC/Src/ecatslv.c **** 
1679:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3466              	 .loc 3 1679 0
 3467 0480 734B     	 ldr r3,.L260
 3468 0482 0022     	 movs r2,#0
 3469 0484 1A70     	 strb r2,[r3]
1680:../SSC/Src/ecatslv.c **** 
1681:../SSC/Src/ecatslv.c ****             if (result != 0)
 3470              	 .loc 3 1681 0
 3471 0486 FB89     	 ldrh r3,[r7,#14]
 3472 0488 002B     	 cmp r3,#0
 3473 048a 00D0     	 beq .L232
1682:../SSC/Src/ecatslv.c ****             {
1683:../SSC/Src/ecatslv.c ****                 break;
 3474              	 .loc 3 1683 0 discriminator 5
 3475 048c 41E0     	 b .L220
 3476              	.L232:
1684:../SSC/Src/ecatslv.c ****             }
1685:../SSC/Src/ecatslv.c ****             
1686:../SSC/Src/ecatslv.c ****             stateTrans = SAFEOP_2_INIT;
 3477              	 .loc 3 1686 0
 3478 048e 4123     	 movs r3,#65
 3479 0490 3B73     	 strb r3,[r7,#12]
 3480              	.L214:
1687:../SSC/Src/ecatslv.c **** 
1688:../SSC/Src/ecatslv.c ****         case SAFEOP_2_INIT:
1689:../SSC/Src/ecatslv.c ****             /* stop the input handler (function is defined above) */
1690:../SSC/Src/ecatslv.c ****             result = APPL_StopInputHandler();
 3481              	 .loc 3 1690 0
 3482 0492 FFF7FEFF 	 bl APPL_StopInputHandler
 3483 0496 0346     	 mov r3,r0
 3484 0498 FB81     	 strh r3,[r7,#14]
1691:../SSC/Src/ecatslv.c ****             
1692:../SSC/Src/ecatslv.c ****             StopInputHandler();
 3485              	 .loc 3 1692 0
 3486 049a FFF7FEFF 	 bl StopInputHandler
1693:../SSC/Src/ecatslv.c **** 
1694:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3487              	 .loc 3 1694 0
 3488 049e 6C4B     	 ldr r3,.L260
 3489 04a0 0022     	 movs r2,#0
 3490 04a2 1A70     	 strb r2,[r3]
1695:../SSC/Src/ecatslv.c **** 
1696:../SSC/Src/ecatslv.c ****             if (result != 0)
 3491              	 .loc 3 1696 0
 3492 04a4 FB89     	 ldrh r3,[r7,#14]
 3493 04a6 002B     	 cmp r3,#0
 3494 04a8 00D0     	 beq .L233
1697:../SSC/Src/ecatslv.c ****             {
1698:../SSC/Src/ecatslv.c ****                 break;
 3495              	 .loc 3 1698 0 discriminator 6
 3496 04aa 32E0     	 b .L220
 3497              	.L233:
1699:../SSC/Src/ecatslv.c ****             }
1700:../SSC/Src/ecatslv.c ****             stateTrans = PREOP_2_INIT;
 3498              	 .loc 3 1700 0
 3499 04ac 2123     	 movs r3,#33
 3500 04ae 3B73     	 strb r3,[r7,#12]
 3501              	.L210:
1701:../SSC/Src/ecatslv.c **** 
1702:../SSC/Src/ecatslv.c ****         case PREOP_2_INIT:
1703:../SSC/Src/ecatslv.c ****             MBX_StopMailboxHandler();
 3502              	 .loc 3 1703 0
 3503 04b0 FFF7FEFF 	 bl MBX_StopMailboxHandler
1704:../SSC/Src/ecatslv.c ****             result = APPL_StopMailboxHandler();
 3504              	 .loc 3 1704 0
 3505 04b4 FFF7FEFF 	 bl APPL_StopMailboxHandler
 3506 04b8 0346     	 mov r3,r0
 3507 04ba FB81     	 strh r3,[r7,#14]
1705:../SSC/Src/ecatslv.c **** 
1706:../SSC/Src/ecatslv.c ****             BackToInitTransition();
 3508              	 .loc 3 1706 0
 3509 04bc FFF7FEFF 	 bl BackToInitTransition
1707:../SSC/Src/ecatslv.c ****             break;
 3510              	 .loc 3 1707 0
 3511 04c0 27E0     	 b .L220
 3512              	.L205:
1708:../SSC/Src/ecatslv.c **** 
1709:../SSC/Src/ecatslv.c ****         case INIT_2_INIT:
1710:../SSC/Src/ecatslv.c ****             BackToInitTransition();
 3513              	 .loc 3 1710 0
 3514 04c2 FFF7FEFF 	 bl BackToInitTransition
 3515              	.L211:
1711:../SSC/Src/ecatslv.c ****         case PREOP_2_PREOP:
1712:../SSC/Src/ecatslv.c ****         case SAFEOP_2_SAFEOP:
1713:../SSC/Src/ecatslv.c ****         case OP_2_OP:
1714:../SSC/Src/ecatslv.c ****             if(bErrAck)
 3516              	 .loc 3 1714 0
 3517 04c6 7B7B     	 ldrb r3,[r7,#13]
 3518 04c8 002B     	 cmp r3,#0
 3519 04ca 04D0     	 beq .L234
1715:../SSC/Src/ecatslv.c ****             {
1716:../SSC/Src/ecatslv.c ****                 APPL_AckErrorInd(stateTrans);
 3520              	 .loc 3 1716 0
 3521 04cc 3B7B     	 ldrb r3,[r7,#12]
 3522 04ce 9BB2     	 uxth r3,r3
 3523 04d0 1846     	 mov r0,r3
 3524 04d2 FFF7FEFF 	 bl APPL_AckErrorInd
 3525              	.L234:
1717:../SSC/Src/ecatslv.c ****             }
1718:../SSC/Src/ecatslv.c **** 
1719:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM2*/
1720:../SSC/Src/ecatslv.c **** 
1721:../SSC/Src/ecatslv.c ****                 /*no local error flag is currently active, enable SM*/
1722:../SSC/Src/ecatslv.c ****                 if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
 3526              	 .loc 3 1722 0
 3527 04d6 624B     	 ldr r3,.L260+16
 3528 04d8 1B78     	 ldrb r3,[r3]
 3529 04da 03F00C03 	 and r3,r3,#12
 3530 04de 002B     	 cmp r3,#0
 3531 04e0 0ED0     	 beq .L235
1723:../SSC/Src/ecatslv.c ****                 {
1724:../SSC/Src/ecatslv.c ****                     if(nPdOutputSize > 0)
 3532              	 .loc 3 1724 0
 3533 04e2 604B     	 ldr r3,.L260+20
 3534 04e4 1B88     	 ldrh r3,[r3]
 3535 04e6 002B     	 cmp r3,#0
 3536 04e8 03D0     	 beq .L236
1725:../SSC/Src/ecatslv.c ****                     {
1726:../SSC/Src/ecatslv.c ****                         EnableSyncManChannel(PROCESS_DATA_OUT);
 3537              	 .loc 3 1726 0
 3538 04ea 0220     	 movs r0,#2
 3539 04ec FFF7FEFF 	 bl EnableSyncManChannel
 3540 04f0 06E0     	 b .L235
 3541              	.L236:
1727:../SSC/Src/ecatslv.c ****                     }
1728:../SSC/Src/ecatslv.c ****                     else 
1729:../SSC/Src/ecatslv.c ****                     if(nPdInputSize > 0)
 3542              	 .loc 3 1729 0
 3543 04f2 5D4B     	 ldr r3,.L260+24
 3544 04f4 1B88     	 ldrh r3,[r3]
 3545 04f6 002B     	 cmp r3,#0
 3546 04f8 02D0     	 beq .L235
1730:../SSC/Src/ecatslv.c ****                     {
1731:../SSC/Src/ecatslv.c ****                         EnableSyncManChannel(PROCESS_DATA_IN);
 3547              	 .loc 3 1731 0
 3548 04fa 0320     	 movs r0,#3
 3549 04fc FFF7FEFF 	 bl EnableSyncManChannel
 3550              	.L235:
1732:../SSC/Src/ecatslv.c ****                     }
1733:../SSC/Src/ecatslv.c ****                 }
1734:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM2*/
1735:../SSC/Src/ecatslv.c ****             
1736:../SSC/Src/ecatslv.c ****             result = NOERROR_NOSTATECHANGE;
 3551              	 .loc 3 1736 0
 3552 0500 FE23     	 movs r3,#254
 3553 0502 FB81     	 strh r3,[r7,#14]
1737:../SSC/Src/ecatslv.c ****             break;
 3554              	 .loc 3 1737 0
 3555 0504 05E0     	 b .L220
 3556              	.L209:
1738:../SSC/Src/ecatslv.c **** 
1739:../SSC/Src/ecatslv.c ****         case INIT_2_SAFEOP:
1740:../SSC/Src/ecatslv.c ****         case INIT_2_OP:
1741:../SSC/Src/ecatslv.c ****         case PREOP_2_OP:
1742:../SSC/Src/ecatslv.c ****         case PREOP_2_BOOT:
1743:../SSC/Src/ecatslv.c ****         case SAFEOP_2_BOOT:
1744:../SSC/Src/ecatslv.c ****         case OP_2_BOOT:
1745:../SSC/Src/ecatslv.c ****         case BOOT_2_PREOP:
1746:../SSC/Src/ecatslv.c ****         case BOOT_2_SAFEOP:
1747:../SSC/Src/ecatslv.c ****         case BOOT_2_OP:
1748:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_INVALIDALCONTROL;
 3557              	 .loc 3 1748 0
 3558 0506 1123     	 movs r3,#17
 3559 0508 FB81     	 strh r3,[r7,#14]
1749:../SSC/Src/ecatslv.c ****             break;
 3560              	 .loc 3 1749 0
 3561 050a 02E0     	 b .L220
 3562              	.L204:
1750:../SSC/Src/ecatslv.c **** 
1751:../SSC/Src/ecatslv.c ****         default:
1752:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_UNKNOWNALCONTROL;
 3563              	 .loc 3 1752 0
 3564 050c 1223     	 movs r3,#18
 3565 050e FB81     	 strh r3,[r7,#14]
1753:../SSC/Src/ecatslv.c ****             break;
 3566              	 .loc 3 1753 0
 3567 0510 00BF     	 nop
 3568              	.L220:
 3569 0512 24E0     	 b .L237
 3570              	.L203:
1754:../SSC/Src/ecatslv.c ****         }
1755:../SSC/Src/ecatslv.c ****     }
1756:../SSC/Src/ecatslv.c ****     else
1757:../SSC/Src/ecatslv.c ****     {
1758:../SSC/Src/ecatslv.c ****         /* the checking of the sync manager settings was not successful
1759:../SSC/Src/ecatslv.c ****             switch back the state to PREOP or INIT */
1760:../SSC/Src/ecatslv.c ****         switch (nAlStatus)
 3571              	 .loc 3 1760 0
 3572 0514 524B     	 ldr r3,.L260+16
 3573 0516 1B78     	 ldrb r3,[r3]
 3574 0518 042B     	 cmp r3,#4
 3575 051a 08D0     	 beq .L238
 3576 051c 082B     	 cmp r3,#8
 3577 051e 02D0     	 beq .L239
 3578 0520 022B     	 cmp r3,#2
 3579 0522 08D0     	 beq .L240
 3580 0524 1BE0     	 b .L237
 3581              	.L239:
1761:../SSC/Src/ecatslv.c ****         {
1762:../SSC/Src/ecatslv.c ****         case STATE_OP:
1763:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1764:../SSC/Src/ecatslv.c ****             APPL_StopOutputHandler();
 3582              	 .loc 3 1764 0
 3583 0526 FFF7FEFF 	 bl APPL_StopOutputHandler
1765:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3584              	 .loc 3 1765 0
 3585 052a FFF7FEFF 	 bl StopOutputHandler
 3586              	.L238:
1766:../SSC/Src/ecatslv.c ****         case STATE_SAFEOP:
1767:../SSC/Src/ecatslv.c ****             /* stop the input handler (function is defined above) */
1768:../SSC/Src/ecatslv.c ****             APPL_StopInputHandler();
 3587              	 .loc 3 1768 0
 3588 052e FFF7FEFF 	 bl APPL_StopInputHandler
1769:../SSC/Src/ecatslv.c **** 
1770:../SSC/Src/ecatslv.c ****             StopInputHandler();
 3589              	 .loc 3 1770 0
 3590 0532 FFF7FEFF 	 bl StopInputHandler
 3591              	.L240:
1771:../SSC/Src/ecatslv.c ****         case STATE_PREOP:
1772:../SSC/Src/ecatslv.c ****             if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
 3592              	 .loc 3 1772 0
 3593 0536 FB89     	 ldrh r3,[r7,#14]
 3594 0538 162B     	 cmp r3,#22
 3595 053a 0DD1     	 bne .L241
1773:../SSC/Src/ecatslv.c ****             {
1774:../SSC/Src/ecatslv.c ****                 /* the mailbox sync manager settings were wrong, switch back to INIT */
1775:../SSC/Src/ecatslv.c ****                 MBX_StopMailboxHandler();
 3596              	 .loc 3 1775 0
 3597 053c FFF7FEFF 	 bl MBX_StopMailboxHandler
1776:../SSC/Src/ecatslv.c ****                 APPL_StopMailboxHandler();
 3598              	 .loc 3 1776 0
 3599 0540 FFF7FEFF 	 bl APPL_StopMailboxHandler
1777:../SSC/Src/ecatslv.c **** 
1778:../SSC/Src/ecatslv.c ****                 /*Disable SM0 (MBX Out)*/
1779:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(MAILBOX_WRITE);
 3600              	 .loc 3 1779 0
 3601 0544 0020     	 movs r0,#0
 3602 0546 FFF7FEFF 	 bl DisableSyncManChannel
1780:../SSC/Src/ecatslv.c **** 
1781:../SSC/Src/ecatslv.c ****                 /*Disable SM1 (MBX In)*/
1782:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(MAILBOX_READ);
 3603              	 .loc 3 1782 0
 3604 054a 0120     	 movs r0,#1
 3605 054c FFF7FEFF 	 bl DisableSyncManChannel
1783:../SSC/Src/ecatslv.c **** 
1784:../SSC/Src/ecatslv.c ****                 nAlStatus = STATE_INIT;
 3606              	 .loc 3 1784 0
 3607 0550 434B     	 ldr r3,.L260+16
 3608 0552 0122     	 movs r2,#1
 3609 0554 1A70     	 strb r2,[r3]
 3610 0556 02E0     	 b .L237
 3611              	.L241:
1785:../SSC/Src/ecatslv.c ****             }
1786:../SSC/Src/ecatslv.c ****             else
1787:../SSC/Src/ecatslv.c ****             {
1788:../SSC/Src/ecatslv.c ****                 nAlStatus = STATE_PREOP;
 3612              	 .loc 3 1788 0
 3613 0558 414B     	 ldr r3,.L260+16
 3614 055a 0222     	 movs r2,#2
 3615 055c 1A70     	 strb r2,[r3]
 3616              	.L237:
1789:../SSC/Src/ecatslv.c ****             }
1790:../SSC/Src/ecatslv.c ****         }
1791:../SSC/Src/ecatslv.c ****     }
1792:../SSC/Src/ecatslv.c **** 
1793:../SSC/Src/ecatslv.c ****     if ( result == NOERROR_INWORK )
 3617              	 .loc 3 1793 0
 3618 055e FB89     	 ldrh r3,[r7,#14]
 3619 0560 FF2B     	 cmp r3,#255
 3620 0562 35D1     	 bne .L242
1794:../SSC/Src/ecatslv.c ****     {
1795:../SSC/Src/ecatslv.c ****         /* state transition is still in work
1796:../SSC/Src/ecatslv.c ****             ECAT_StateChange must be called from the application */
1797:../SSC/Src/ecatslv.c ****         bEcatWaitForAlControlRes = TRUE;
 3621              	 .loc 3 1797 0
 3622 0564 414B     	 ldr r3,.L260+28
 3623 0566 0122     	 movs r2,#1
 3624 0568 1A70     	 strb r2,[r3]
1798:../SSC/Src/ecatslv.c ****         /* state transition has to be stored */
1799:../SSC/Src/ecatslv.c ****         nEcatStateTrans = stateTrans;
 3625              	 .loc 3 1799 0
 3626 056a 3B7B     	 ldrb r3,[r7,#12]
 3627 056c 9AB2     	 uxth r2,r3
 3628 056e 404B     	 ldr r3,.L260+32
 3629 0570 1A80     	 strh r2,[r3]
1800:../SSC/Src/ecatslv.c **** 
1801:../SSC/Src/ecatslv.c ****         /*Init ESM timeout counter (will be decremented with the local 1ms timer)*/
1802:../SSC/Src/ecatslv.c ****         switch(nEcatStateTrans)
 3630              	 .loc 3 1802 0
 3631 0572 3F4B     	 ldr r3,.L260+32
 3632 0574 1B88     	 ldrh r3,[r3]
 3633 0576 242B     	 cmp r3,#36
 3634 0578 0DD0     	 beq .L244
 3635 057a 242B     	 cmp r3,#36
 3636 057c 03DC     	 bgt .L245
 3637 057e 123B     	 subs r3,r3,#18
 3638 0580 012B     	 cmp r3,#1
 3639 0582 0DD8     	 bhi .L243
 3640 0584 02E0     	 b .L257
 3641              	.L245:
 3642 0586 482B     	 cmp r3,#72
 3643 0588 05D0     	 beq .L244
 3644 058a 09E0     	 b .L243
 3645              	.L257:
1803:../SSC/Src/ecatslv.c ****         {
1804:../SSC/Src/ecatslv.c ****             case INIT_2_PREOP:
1805:../SSC/Src/ecatslv.c ****             case INIT_2_BOOT:
1806:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = PREOPTIMEOUT;
 3646              	 .loc 3 1806 0
 3647 058c 394B     	 ldr r3,.L260+36
 3648 058e 4FF4FA62 	 mov r2,#2000
 3649 0592 1A80     	 strh r2,[r3]
1807:../SSC/Src/ecatslv.c ****             break;
 3650              	 .loc 3 1807 0
 3651 0594 08E0     	 b .L247
 3652              	.L244:
1808:../SSC/Src/ecatslv.c ****             case PREOP_2_SAFEOP:
1809:../SSC/Src/ecatslv.c ****             case SAFEOP_2_OP:
1810:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = SAFEOP2OPTIMEOUT;
 3653              	 .loc 3 1810 0
 3654 0596 374B     	 ldr r3,.L260+36
 3655 0598 42F22832 	 movw r2,#9000
 3656 059c 1A80     	 strh r2,[r3]
1811:../SSC/Src/ecatslv.c ****                 break;
 3657              	 .loc 3 1811 0
 3658 059e 03E0     	 b .L247
 3659              	.L243:
1812:../SSC/Src/ecatslv.c ****            default:
1813:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = 200; //Set default timeout value to 200ms
 3660              	 .loc 3 1813 0
 3661 05a0 344B     	 ldr r3,.L260+36
 3662 05a2 C822     	 movs r2,#200
 3663 05a4 1A80     	 strh r2,[r3]
1814:../SSC/Src/ecatslv.c ****                 break;
 3664              	 .loc 3 1814 0
 3665 05a6 00BF     	 nop
 3666              	.L247:
1815:../SSC/Src/ecatslv.c ****         }
1816:../SSC/Src/ecatslv.c ****         /*ECATCHANGE_START(V5.12) ESM3*/
1817:../SSC/Src/ecatslv.c ****         EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to r
 3667              	 .loc 3 1817 0
 3668 05a8 324B     	 ldr r3,.L260+36
 3669 05aa 1B88     	 ldrh r3,[r3]
 3670 05ac 9AB2     	 uxth r2,r3
 3671 05ae 314B     	 ldr r3,.L260+36
 3672 05b0 1B88     	 ldrh r3,[r3]
 3673 05b2 1BB2     	 sxth r3,r3
 3674 05b4 3049     	 ldr r1,.L260+40
 3675 05b6 81FB0301 	 smull r0,r1,r1,r3
 3676 05ba 8910     	 asrs r1,r1,#2
 3677 05bc DB17     	 asrs r3,r3,#31
 3678 05be CB1A     	 subs r3,r1,r3
 3679 05c0 9BB2     	 uxth r3,r3
 3680 05c2 9BB2     	 uxth r3,r3
 3681 05c4 D31A     	 subs r3,r2,r3
 3682 05c6 9BB2     	 uxth r3,r3
 3683 05c8 9AB2     	 uxth r2,r3
 3684 05ca 2A4B     	 ldr r3,.L260+36
 3685 05cc 1A80     	 strh r2,[r3]
 3686 05ce 75E0     	 b .L191
 3687              	.L242:
1818:../SSC/Src/ecatslv.c ****         /*ECATCHANGE_END(V5.12) ESM3*/
1819:../SSC/Src/ecatslv.c **** 
1820:../SSC/Src/ecatslv.c ****     }
1821:../SSC/Src/ecatslv.c ****     else if ( alControl != (nAlStatus & STATE_MASK) )
 3688              	 .loc 3 1821 0
 3689 05d0 FA79     	 ldrb r2,[r7,#7]
 3690 05d2 234B     	 ldr r3,.L260+16
 3691 05d4 1B78     	 ldrb r3,[r3]
 3692 05d6 03F00F03 	 and r3,r3,#15
 3693 05da 9A42     	 cmp r2,r3
 3694 05dc 65D0     	 beq .L248
1822:../SSC/Src/ecatslv.c ****     {
1823:../SSC/Src/ecatslv.c ****         /* The slave state has changed */
1824:../SSC/Src/ecatslv.c **** 
1825:../SSC/Src/ecatslv.c ****         if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
 3695              	 .loc 3 1825 0
 3696 05de FB89     	 ldrh r3,[r7,#14]
 3697 05e0 002B     	 cmp r3,#0
 3698 05e2 02D1     	 bne .L249
 3699              	 .loc 3 1825 0 is_stmt 0 discriminator 2
 3700 05e4 BB88     	 ldrh r3,[r7,#4]
 3701 05e6 002B     	 cmp r3,#0
 3702 05e8 1FD0     	 beq .L250
 3703              	.L249:
 3704              	 .loc 3 1825 0 discriminator 3
 3705 05ea 1D4B     	 ldr r3,.L260+16
 3706 05ec 1A78     	 ldrb r2,[r3]
 3707 05ee FB79     	 ldrb r3,[r7,#7]
 3708 05f0 1343     	 orrs r3,r3,r2
 3709 05f2 DBB2     	 uxtb r3,r3
 3710 05f4 03F00803 	 and r3,r3,#8
 3711 05f8 002B     	 cmp r3,#0
 3712 05fa 16D0     	 beq .L250
1826:../SSC/Src/ecatslv.c ****         {
1827:../SSC/Src/ecatslv.c ****             /* the local application requested to leave the state OP so we have to disable the SM2
1828:../SSC/Src/ecatslv.c ****                and make the state change from OP to SAFEOP by calling StopOutputHandler */
1829:../SSC/Src/ecatslv.c **** 
1830:../SSC/Src/ecatslv.c ****             //only execute StopOutputHandler() if Output update is still running
1831:../SSC/Src/ecatslv.c ****             if(bEcatOutputUpdateRunning)
 3713              	 .loc 3 1831 0 is_stmt 1
 3714 05fc 174B     	 ldr r3,.L260+12
 3715 05fe 1B78     	 ldrb r3,[r3]
 3716 0600 002B     	 cmp r3,#0
 3717 0602 03D0     	 beq .L251
1832:../SSC/Src/ecatslv.c ****             {
1833:../SSC/Src/ecatslv.c ****                 APPL_StopOutputHandler();
 3718              	 .loc 3 1833 0
 3719 0604 FFF7FEFF 	 bl APPL_StopOutputHandler
1834:../SSC/Src/ecatslv.c **** 
1835:../SSC/Src/ecatslv.c ****                 StopOutputHandler();
 3720              	 .loc 3 1835 0
 3721 0608 FFF7FEFF 	 bl StopOutputHandler
 3722              	.L251:
1836:../SSC/Src/ecatslv.c ****             }
1837:../SSC/Src/ecatslv.c **** 
1838:../SSC/Src/ecatslv.c ****             if(nPdOutputSize > 0)
 3723              	 .loc 3 1838 0
 3724 060c 154B     	 ldr r3,.L260+20
 3725 060e 1B88     	 ldrh r3,[r3]
 3726 0610 002B     	 cmp r3,#0
 3727 0612 03D0     	 beq .L252
1839:../SSC/Src/ecatslv.c ****             {
1840:../SSC/Src/ecatslv.c ****                 /* disable the Sync Manager Channel 2 (outputs) */
1841:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(PROCESS_DATA_OUT);
 3728              	 .loc 3 1841 0
 3729 0614 0220     	 movs r0,#2
 3730 0616 FFF7FEFF 	 bl DisableSyncManChannel
 3731 061a 06E0     	 b .L250
 3732              	.L252:
1842:../SSC/Src/ecatslv.c ****             }
1843:../SSC/Src/ecatslv.c ****             else
1844:../SSC/Src/ecatslv.c ****                 if(nPdInputSize > 0)
 3733              	 .loc 3 1844 0
 3734 061c 124B     	 ldr r3,.L260+24
 3735 061e 1B88     	 ldrh r3,[r3]
 3736 0620 002B     	 cmp r3,#0
 3737 0622 02D0     	 beq .L250
1845:../SSC/Src/ecatslv.c ****             {
1846:../SSC/Src/ecatslv.c ****                 /*disable Sync Manager 3 (inputs) if no outputs available*/
1847:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(PROCESS_DATA_IN);
 3738              	 .loc 3 1847 0
 3739 0624 0320     	 movs r0,#3
 3740 0626 FFF7FEFF 	 bl DisableSyncManChannel
 3741              	.L250:
1848:../SSC/Src/ecatslv.c ****             }
1849:../SSC/Src/ecatslv.c **** 
1850:../SSC/Src/ecatslv.c ****         }
1851:../SSC/Src/ecatslv.c ****         if ( result != 0 )
 3742              	 .loc 3 1851 0
 3743 062a FB89     	 ldrh r3,[r7,#14]
 3744 062c 002B     	 cmp r3,#0
 3745 062e 25D0     	 beq .L253
1852:../SSC/Src/ecatslv.c ****         {
1853:../SSC/Src/ecatslv.c ****                 if (nAlStatus == STATE_OP)
 3746              	 .loc 3 1853 0
 3747 0630 0B4B     	 ldr r3,.L260+16
 3748 0632 1B78     	 ldrb r3,[r3]
 3749 0634 082B     	 cmp r3,#8
 3750 0636 02D1     	 bne .L254
1854:../SSC/Src/ecatslv.c ****                 {
1855:../SSC/Src/ecatslv.c ****                     nAlStatus = STATE_SAFEOP;
 3751              	 .loc 3 1855 0
 3752 0638 094B     	 ldr r3,.L260+16
 3753 063a 0422     	 movs r2,#4
 3754 063c 1A70     	 strb r2,[r3]
 3755              	.L254:
1856:../SSC/Src/ecatslv.c ****                 }
1857:../SSC/Src/ecatslv.c ****             /* save the failed status to be able to decide, if the AL Status Code shall be
1858:../SSC/Src/ecatslv.c ****                reset in case of a coming successful state transition */
1859:../SSC/Src/ecatslv.c ****             nAlStatus |= STATE_CHANGE;
 3756              	 .loc 3 1859 0
 3757 063e 084B     	 ldr r3,.L260+16
 3758 0640 1B78     	 ldrb r3,[r3]
 3759 0642 43F01003 	 orr r3,r3,#16
 3760 0646 DAB2     	 uxtb r2,r3
 3761 0648 054B     	 ldr r3,.L260+16
 3762 064a 1A70     	 strb r2,[r3]
 3763 064c 22E0     	 b .L255
 3764              	.L261:
 3765 064e 00BF     	 .align 2
 3766              	.L260:
 3767 0650 00000000 	 .word bApplEsmPending
 3768 0654 00000000 	 .word u16ALEventMask
 3769 0658 00000000 	 .word bEcatInputUpdateRunning
 3770 065c 00000000 	 .word bEcatOutputUpdateRunning
 3771 0660 00000000 	 .word nAlStatus
 3772 0664 00000000 	 .word nPdOutputSize
 3773 0668 00000000 	 .word nPdInputSize
 3774 066c 00000000 	 .word bEcatWaitForAlControlRes
 3775 0670 00000000 	 .word nEcatStateTrans
 3776 0674 00000000 	 .word EsmTimeoutCounter
 3777 0678 67666666 	 .word 1717986919
 3778              	.L253:
1860:../SSC/Src/ecatslv.c ****         }
1861:../SSC/Src/ecatslv.c ****         else
1862:../SSC/Src/ecatslv.c ****         {
1863:../SSC/Src/ecatslv.c ****             /* state transition was successful */
1864:../SSC/Src/ecatslv.c ****             if ( alStatusCode != 0 )
 3779              	 .loc 3 1864 0
 3780 067c BB88     	 ldrh r3,[r7,#4]
 3781 067e 002B     	 cmp r3,#0
 3782 0680 05D0     	 beq .L256
1865:../SSC/Src/ecatslv.c ****             {
1866:../SSC/Src/ecatslv.c ****                 /* state change request from the user */
1867:../SSC/Src/ecatslv.c ****                 result = alStatusCode;
 3783              	 .loc 3 1867 0
 3784 0682 BB88     	 ldrh r3,[r7,#4]
 3785 0684 FB81     	 strh r3,[r7,#14]
1868:../SSC/Src/ecatslv.c ****                 alControl |= STATE_CHANGE;
 3786              	 .loc 3 1868 0
 3787 0686 FB79     	 ldrb r3,[r7,#7]
 3788 0688 43F01003 	 orr r3,r3,#16
 3789 068c FB71     	 strb r3,[r7,#7]
 3790              	.L256:
1869:../SSC/Src/ecatslv.c ****             }
1870:../SSC/Src/ecatslv.c ****             /* acknowledge the new state */
1871:../SSC/Src/ecatslv.c ****             nAlStatus = alControl;
 3791              	 .loc 3 1871 0
 3792 068e 0D4A     	 ldr r2,.L262
 3793 0690 FB79     	 ldrb r3,[r7,#7]
 3794 0692 1370     	 strb r3,[r2]
 3795              	.L255:
1872:../SSC/Src/ecatslv.c ****         }
1873:../SSC/Src/ecatslv.c **** 
1874:../SSC/Src/ecatslv.c ****         bEcatWaitForAlControlRes = FALSE;
 3796              	 .loc 3 1874 0
 3797 0694 0C4B     	 ldr r3,.L262+4
 3798 0696 0022     	 movs r2,#0
 3799 0698 1A70     	 strb r2,[r3]
1875:../SSC/Src/ecatslv.c **** 
1876:../SSC/Src/ecatslv.c ****         /* write the AL Status register */
1877:../SSC/Src/ecatslv.c ****         SetALStatus(nAlStatus, result);
 3800              	 .loc 3 1877 0
 3801 069a 0A4B     	 ldr r3,.L262
 3802 069c 1A78     	 ldrb r2,[r3]
 3803 069e FB89     	 ldrh r3,[r7,#14]
 3804 06a0 1046     	 mov r0,r2
 3805 06a2 1946     	 mov r1,r3
 3806 06a4 FFF7FEFF 	 bl SetALStatus
 3807 06a8 08E0     	 b .L191
 3808              	.L248:
1878:../SSC/Src/ecatslv.c ****     }
1879:../SSC/Src/ecatslv.c ****     else
1880:../SSC/Src/ecatslv.c ****     {
1881:../SSC/Src/ecatslv.c ****         /* Error acknowledgement without a state transition */
1882:../SSC/Src/ecatslv.c **** 
1883:../SSC/Src/ecatslv.c ****          bEcatWaitForAlControlRes = FALSE;
 3809              	 .loc 3 1883 0
 3810 06aa 074B     	 ldr r3,.L262+4
 3811 06ac 0022     	 movs r2,#0
 3812 06ae 1A70     	 strb r2,[r3]
1884:../SSC/Src/ecatslv.c **** 
1885:../SSC/Src/ecatslv.c ****         /* AL-Status has to be updated and AL-Status-Code has to be reset
1886:../SSC/Src/ecatslv.c ****            if the the error bit was acknowledged */
1887:../SSC/Src/ecatslv.c ****         SetALStatus(nAlStatus, 0);
 3813              	 .loc 3 1887 0
 3814 06b0 044B     	 ldr r3,.L262
 3815 06b2 1B78     	 ldrb r3,[r3]
 3816 06b4 1846     	 mov r0,r3
 3817 06b6 0021     	 movs r1,#0
 3818 06b8 FFF7FEFF 	 bl SetALStatus
 3819              	.L191:
1888:../SSC/Src/ecatslv.c ****     }
1889:../SSC/Src/ecatslv.c **** 
1890:../SSC/Src/ecatslv.c **** }
 3820              	 .loc 3 1890 0
 3821 06bc 1037     	 adds r7,r7,#16
 3822              	.LCFI82:
 3823              	 .cfi_def_cfa_offset 8
 3824 06be BD46     	 mov sp,r7
 3825              	.LCFI83:
 3826              	 .cfi_def_cfa_register 13
 3827              	 
 3828 06c0 80BD     	 pop {r7,pc}
 3829              	.L263:
 3830 06c2 00BF     	 .align 2
 3831              	.L262:
 3832 06c4 00000000 	 .word nAlStatus
 3833 06c8 00000000 	 .word bEcatWaitForAlControlRes
 3834              	 .cfi_endproc
 3835              	.LFE192:
 3837              	 .section .text.AL_ControlRes,"ax",%progbits
 3838              	 .align 2
 3839              	 .global AL_ControlRes
 3840              	 .thumb
 3841              	 .thumb_func
 3843              	AL_ControlRes:
 3844              	.LFB193:
1891:../SSC/Src/ecatslv.c **** 
1892:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1893:../SSC/Src/ecatslv.c **** /**
1894:../SSC/Src/ecatslv.c **** 
1895:../SSC/Src/ecatslv.c ****  \brief    This function is called cyclic if a state transition is pending (bEcatWaitForAlControlRe
1896:../SSC/Src/ecatslv.c ****  \brief    If the ESM timeout is expired the state transition will be rejected. Otherwise the appli
1897:../SSC/Src/ecatslv.c ****  \brief    If the pending state transition is triggered by the application the transition need to b
1898:../SSC/Src/ecatslv.c ****   *////////////////////////////////////////////////////////////////////////////////////////
1899:../SSC/Src/ecatslv.c **** void AL_ControlRes(void)
1900:../SSC/Src/ecatslv.c **** {
 3845              	 .loc 3 1900 0
 3846              	 .cfi_startproc
 3847              	 
 3848              	 
 3849 0000 80B5     	 push {r7,lr}
 3850              	.LCFI84:
 3851              	 .cfi_def_cfa_offset 8
 3852              	 .cfi_offset 7,-8
 3853              	 .cfi_offset 14,-4
 3854 0002 82B0     	 sub sp,sp,#8
 3855              	.LCFI85:
 3856              	 .cfi_def_cfa_offset 16
 3857 0004 00AF     	 add r7,sp,#0
 3858              	.LCFI86:
 3859              	 .cfi_def_cfa_register 7
1901:../SSC/Src/ecatslv.c ****     if(bEcatWaitForAlControlRes)
 3860              	 .loc 3 1901 0
 3861 0006 A14B     	 ldr r3,.L306
 3862 0008 1B78     	 ldrb r3,[r3]
 3863 000a 002B     	 cmp r3,#0
 3864 000c 00F03B81 	 beq .L264
 3865              	.LBB8:
1902:../SSC/Src/ecatslv.c ****     {
1903:../SSC/Src/ecatslv.c ****         UINT16 result = 0;
 3866              	 .loc 3 1903 0
 3867 0010 0023     	 movs r3,#0
 3868 0012 7B80     	 strh r3,[r7,#2]
1904:../SSC/Src/ecatslv.c ****         UINT8 Status = 0;
 3869              	 .loc 3 1904 0
 3870 0014 0023     	 movs r3,#0
 3871 0016 FB71     	 strb r3,[r7,#7]
1905:../SSC/Src/ecatslv.c ****         UINT16 StatusCode = 0;
 3872              	 .loc 3 1905 0
 3873 0018 0023     	 movs r3,#0
 3874 001a BB80     	 strh r3,[r7,#4]
1906:../SSC/Src/ecatslv.c **** 
1907:../SSC/Src/ecatslv.c ****         if(EsmTimeoutCounter == 0)
 3875              	 .loc 3 1907 0
 3876 001c 9C4B     	 ldr r3,.L306+4
 3877 001e 1B88     	 ldrh r3,[r3]
 3878 0020 002B     	 cmp r3,#0
 3879 0022 7CD1     	 bne .L266
1908:../SSC/Src/ecatslv.c ****         {
1909:../SSC/Src/ecatslv.c ****             Status =  (UINT8)(nEcatStateTrans >> 4);
 3880              	 .loc 3 1909 0
 3881 0024 9B4B     	 ldr r3,.L306+8
 3882 0026 1B88     	 ldrh r3,[r3]
 3883 0028 1B09     	 lsrs r3,r3,#4
 3884 002a 9BB2     	 uxth r3,r3
 3885 002c FB71     	 strb r3,[r7,#7]
1910:../SSC/Src/ecatslv.c **** 
1911:../SSC/Src/ecatslv.c ****             /* ESM timeout expired*/
1912:../SSC/Src/ecatslv.c ****             switch(nEcatStateTrans)
 3886              	 .loc 3 1912 0
 3887 002e 994B     	 ldr r3,.L306+8
 3888 0030 1B88     	 ldrh r3,[r3]
 3889 0032 242B     	 cmp r3,#36
 3890 0034 1FD0     	 beq .L268
 3891 0036 242B     	 cmp r3,#36
 3892 0038 04DC     	 bgt .L269
 3893 003a 123B     	 subs r3,r3,#18
 3894 003c 012B     	 cmp r3,#1
 3895 003e 00F20F81 	 bhi .L286
 3896 0042 02E0     	 b .L302
 3897              	.L269:
 3898 0044 482B     	 cmp r3,#72
 3899 0046 2CD0     	 beq .L271
 3900 0048 0AE1     	 b .L286
 3901              	.L302:
1913:../SSC/Src/ecatslv.c ****             {
1914:../SSC/Src/ecatslv.c ****                 case INIT_2_PREOP:
1915:../SSC/Src/ecatslv.c ****                 case INIT_2_BOOT:
1916:../SSC/Src/ecatslv.c **** 
1917:../SSC/Src/ecatslv.c ****                         if (!bApplEsmPending)
 3902              	 .loc 3 1917 0
 3903 004a 934B     	 ldr r3,.L306+12
 3904 004c 1B78     	 ldrb r3,[r3]
 3905 004e 83F00103 	 eor r3,r3,#1
 3906 0052 DBB2     	 uxtb r3,r3
 3907 0054 002B     	 cmp r3,#0
 3908 0056 01D0     	 beq .L272
1918:../SSC/Src/ecatslv.c ****                         {
1919:../SSC/Src/ecatslv.c ****                             APPL_StopMailboxHandler();
 3909              	 .loc 3 1919 0
 3910 0058 FFF7FEFF 	 bl APPL_StopMailboxHandler
 3911              	.L272:
1920:../SSC/Src/ecatslv.c ****                         }
1921:../SSC/Src/ecatslv.c **** 
1922:../SSC/Src/ecatslv.c ****                     MBX_StopMailboxHandler();
 3912              	 .loc 3 1922 0
 3913 005c FFF7FEFF 	 bl MBX_StopMailboxHandler
1923:../SSC/Src/ecatslv.c ****                     if(bLocalErrorFlag)
 3914              	 .loc 3 1923 0
 3915 0060 8E4B     	 ldr r3,.L306+16
 3916 0062 1B78     	 ldrb r3,[r3]
 3917 0064 002B     	 cmp r3,#0
 3918 0066 03D0     	 beq .L273
1924:../SSC/Src/ecatslv.c ****                     {
1925:../SSC/Src/ecatslv.c ****                         /*Set application specified error*/
1926:../SSC/Src/ecatslv.c ****                         StatusCode = u16LocalErrorCode;
 3919              	 .loc 3 1926 0
 3920 0068 8D4B     	 ldr r3,.L306+20
 3921 006a 1B88     	 ldrh r3,[r3]
 3922 006c BB80     	 strh r3,[r7,#4]
1927:../SSC/Src/ecatslv.c ****                     }
1928:../SSC/Src/ecatslv.c ****                     else
1929:../SSC/Src/ecatslv.c ****                     {
1930:../SSC/Src/ecatslv.c ****                         /*Set unspecified error*/
1931:../SSC/Src/ecatslv.c ****                         StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
1932:../SSC/Src/ecatslv.c ****                     }
1933:../SSC/Src/ecatslv.c ****                 break;
 3923              	 .loc 3 1933 0
 3924 006e 55E0     	 b .L267
 3925              	.L273:
1931:../SSC/Src/ecatslv.c ****                     }
 3926              	 .loc 3 1931 0
 3927 0070 0123     	 movs r3,#1
 3928 0072 BB80     	 strh r3,[r7,#4]
 3929              	 .loc 3 1933 0
 3930 0074 52E0     	 b .L267
 3931              	.L268:
1934:../SSC/Src/ecatslv.c ****                 case PREOP_2_SAFEOP:
1935:../SSC/Src/ecatslv.c **** 
1936:../SSC/Src/ecatslv.c ****                         if (!bApplEsmPending)
 3932              	 .loc 3 1936 0
 3933 0076 884B     	 ldr r3,.L306+12
 3934 0078 1B78     	 ldrb r3,[r3]
 3935 007a 83F00103 	 eor r3,r3,#1
 3936 007e DBB2     	 uxtb r3,r3
 3937 0080 002B     	 cmp r3,#0
 3938 0082 01D0     	 beq .L275
1937:../SSC/Src/ecatslv.c ****                         {
1938:../SSC/Src/ecatslv.c ****                             APPL_StopInputHandler();
 3939              	 .loc 3 1938 0
 3940 0084 FFF7FEFF 	 bl APPL_StopInputHandler
 3941              	.L275:
1939:../SSC/Src/ecatslv.c ****                         }
1940:../SSC/Src/ecatslv.c **** 
1941:../SSC/Src/ecatslv.c ****                     StopInputHandler();
 3942              	 .loc 3 1941 0
 3943 0088 FFF7FEFF 	 bl StopInputHandler
1942:../SSC/Src/ecatslv.c ****                     
1943:../SSC/Src/ecatslv.c ****                     if(bLocalErrorFlag)
 3944              	 .loc 3 1943 0
 3945 008c 834B     	 ldr r3,.L306+16
 3946 008e 1B78     	 ldrb r3,[r3]
 3947 0090 002B     	 cmp r3,#0
 3948 0092 03D0     	 beq .L276
1944:../SSC/Src/ecatslv.c ****                     {
1945:../SSC/Src/ecatslv.c ****                         /*Set application specified error*/
1946:../SSC/Src/ecatslv.c ****                         StatusCode = u16LocalErrorCode;
 3949              	 .loc 3 1946 0
 3950 0094 824B     	 ldr r3,.L306+20
 3951 0096 1B88     	 ldrh r3,[r3]
 3952 0098 BB80     	 strh r3,[r7,#4]
1947:../SSC/Src/ecatslv.c ****                     }
1948:../SSC/Src/ecatslv.c ****                     else
1949:../SSC/Src/ecatslv.c ****                     {
1950:../SSC/Src/ecatslv.c ****                         /*Set unspecified error*/
1951:../SSC/Src/ecatslv.c ****                         StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
1952:../SSC/Src/ecatslv.c ****                     }
1953:../SSC/Src/ecatslv.c ****                 break;
 3953              	 .loc 3 1953 0
 3954 009a 3FE0     	 b .L267
 3955              	.L276:
1951:../SSC/Src/ecatslv.c ****                     }
 3956              	 .loc 3 1951 0
 3957 009c 0123     	 movs r3,#1
 3958 009e BB80     	 strh r3,[r7,#4]
 3959              	 .loc 3 1953 0
 3960 00a0 3CE0     	 b .L267
 3961              	.L271:
1954:../SSC/Src/ecatslv.c ****                 case SAFEOP_2_OP:
1955:../SSC/Src/ecatslv.c ****                     if(bDcSyncActive)
 3962              	 .loc 3 1955 0
 3963 00a2 804B     	 ldr r3,.L306+24
 3964 00a4 1B78     	 ldrb r3,[r3]
 3965 00a6 002B     	 cmp r3,#0
 3966 00a8 1AD0     	 beq .L278
1956:../SSC/Src/ecatslv.c ****                     {
1957:../SSC/Src/ecatslv.c ****                         /*SafeOP to OP timeout expired check which AL status code need to be writte
1958:../SSC/Src/ecatslv.c ****                         if(!bDcRunning)
 3967              	 .loc 3 1958 0
 3968 00aa 7F4B     	 ldr r3,.L306+28
 3969 00ac 1B78     	 ldrb r3,[r3]
 3970 00ae 83F00103 	 eor r3,r3,#1
 3971 00b2 DBB2     	 uxtb r3,r3
 3972 00b4 002B     	 cmp r3,#0
 3973 00b6 02D0     	 beq .L279
1959:../SSC/Src/ecatslv.c ****                         {
1960:../SSC/Src/ecatslv.c ****                             /*no Sync0 signal received*/
1961:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_NOSYNCERROR;
 3974              	 .loc 3 1961 0
 3975 00b8 2D23     	 movs r3,#45
 3976 00ba BB80     	 strh r3,[r7,#4]
 3977 00bc 1EE0     	 b .L282
 3978              	.L279:
1962:../SSC/Src/ecatslv.c ****                         }
1963:../SSC/Src/ecatslv.c ****                         else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
 3979              	 .loc 3 1963 0
 3980 00be 7B4B     	 ldr r3,.L306+32
 3981 00c0 1B78     	 ldrb r3,[r3]
 3982 00c2 83F00103 	 eor r3,r3,#1
 3983 00c6 DBB2     	 uxtb r3,r3
 3984 00c8 002B     	 cmp r3,#0
 3985 00ca 06D0     	 beq .L281
 3986              	 .loc 3 1963 0 is_stmt 0 discriminator 1
 3987 00cc 784B     	 ldr r3,.L306+36
 3988 00ce 1B88     	 ldrh r3,[r3]
 3989 00d0 002B     	 cmp r3,#0
 3990 00d2 02D0     	 beq .L281
1964:../SSC/Src/ecatslv.c ****                         {
1965:../SSC/Src/ecatslv.c ****                             /*no process data received*/
1966:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_SMWATCHDOG;
 3991              	 .loc 3 1966 0 is_stmt 1
 3992 00d4 1B23     	 movs r3,#27
 3993 00d6 BB80     	 strh r3,[r7,#4]
 3994 00d8 10E0     	 b .L282
 3995              	.L281:
1967:../SSC/Src/ecatslv.c ****                         }
1968:../SSC/Src/ecatslv.c ****                         else
1969:../SSC/Src/ecatslv.c ****                         {
1970:../SSC/Src/ecatslv.c ****                             /*SM/Sync Sequence is not valid*/
1971:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_SYNCERROR;
 3996              	 .loc 3 1971 0
 3997 00da 1A23     	 movs r3,#26
 3998 00dc BB80     	 strh r3,[r7,#4]
 3999 00de 0DE0     	 b .L282
 4000              	.L278:
1972:../SSC/Src/ecatslv.c ****                         }
1973:../SSC/Src/ecatslv.c ****                     }
1974:../SSC/Src/ecatslv.c ****                     else
1975:../SSC/Src/ecatslv.c ****                     {
1976:../SSC/Src/ecatslv.c ****                         if (nPdOutputSize > 0)
 4001              	 .loc 3 1976 0
 4002 00e0 734B     	 ldr r3,.L306+36
 4003 00e2 1B88     	 ldrh r3,[r3]
 4004 00e4 002B     	 cmp r3,#0
 4005 00e6 02D0     	 beq .L283
1977:../SSC/Src/ecatslv.c ****                         {
1978:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_SMWATCHDOG;
 4006              	 .loc 3 1978 0
 4007 00e8 1B23     	 movs r3,#27
 4008 00ea BB80     	 strh r3,[r7,#4]
 4009 00ec 06E0     	 b .L282
 4010              	.L283:
1979:../SSC/Src/ecatslv.c ****                         }
1980:../SSC/Src/ecatslv.c ****                         else
1981:../SSC/Src/ecatslv.c ****                         {
1982:../SSC/Src/ecatslv.c ****                             /*Set valid state transition even if timeout expired*/
1983:../SSC/Src/ecatslv.c ****                             Status = STATE_OP;
 4011              	 .loc 3 1983 0
 4012 00ee 0823     	 movs r3,#8
 4013 00f0 FB71     	 strb r3,[r7,#7]
1984:../SSC/Src/ecatslv.c ****                             StatusCode = 0;
 4014              	 .loc 3 1984 0
 4015 00f2 0023     	 movs r3,#0
 4016 00f4 BB80     	 strh r3,[r7,#4]
1985:../SSC/Src/ecatslv.c ****                             /* Slave is OPERATIONAL */
1986:../SSC/Src/ecatslv.c ****                             bEcatOutputUpdateRunning = TRUE;
 4017              	 .loc 3 1986 0
 4018 00f6 6F4B     	 ldr r3,.L306+40
 4019 00f8 0122     	 movs r2,#1
 4020 00fa 1A70     	 strb r2,[r3]
 4021              	.L282:
1987:../SSC/Src/ecatslv.c ****                         }
1988:../SSC/Src/ecatslv.c ****                     }
1989:../SSC/Src/ecatslv.c **** 
1990:../SSC/Src/ecatslv.c ****                     /*Stop handler on failed transition*/
1991:../SSC/Src/ecatslv.c ****                     if(StatusCode != 0)
 4022              	 .loc 3 1991 0
 4023 00fc BB88     	 ldrh r3,[r7,#4]
 4024 00fe 002B     	 cmp r3,#0
 4025 0100 0BD0     	 beq .L284
1992:../SSC/Src/ecatslv.c ****                     {
1993:../SSC/Src/ecatslv.c ****                             if (!bApplEsmPending)
 4026              	 .loc 3 1993 0
 4027 0102 654B     	 ldr r3,.L306+12
 4028 0104 1B78     	 ldrb r3,[r3]
 4029 0106 83F00103 	 eor r3,r3,#1
 4030 010a DBB2     	 uxtb r3,r3
 4031 010c 002B     	 cmp r3,#0
 4032 010e 01D0     	 beq .L285
1994:../SSC/Src/ecatslv.c ****                             {
1995:../SSC/Src/ecatslv.c ****                                 APPL_StopOutputHandler();
 4033              	 .loc 3 1995 0
 4034 0110 FFF7FEFF 	 bl APPL_StopOutputHandler
 4035              	.L285:
1996:../SSC/Src/ecatslv.c ****                             }
1997:../SSC/Src/ecatslv.c **** 
1998:../SSC/Src/ecatslv.c ****                         StopOutputHandler();
 4036              	 .loc 3 1998 0
 4037 0114 FFF7FEFF 	 bl StopOutputHandler
1999:../SSC/Src/ecatslv.c ****                     }
2000:../SSC/Src/ecatslv.c ****                 break;
 4038              	 .loc 3 2000 0
 4039 0118 FFE7     	 b .L304
 4040              	.L284:
 4041              	.L304:
 4042 011a 00BF     	 nop
 4043              	.L267:
 4044 011c A0E0     	 b .L286
 4045              	.L266:
2001:../SSC/Src/ecatslv.c ****             }
2002:../SSC/Src/ecatslv.c ****         } //ESM timeout
2003:../SSC/Src/ecatslv.c ****         else
2004:../SSC/Src/ecatslv.c ****         {
2005:../SSC/Src/ecatslv.c ****             /*Call application specific transition function and complete transition it the function
2006:../SSC/Src/ecatslv.c ****             switch(nEcatStateTrans)
 4046              	 .loc 3 2006 0
 4047 011e 5D4B     	 ldr r3,.L306+8
 4048 0120 1B88     	 ldrh r3,[r3]
 4049 0122 242B     	 cmp r3,#36
 4050 0124 2AD0     	 beq .L287
 4051 0126 242B     	 cmp r3,#36
 4052 0128 04DC     	 bgt .L288
 4053 012a 123B     	 subs r3,r3,#18
 4054 012c 012B     	 cmp r3,#1
 4055 012e 00F29780 	 bhi .L286
 4056 0132 02E0     	 b .L303
 4057              	.L288:
 4058 0134 482B     	 cmp r3,#72
 4059 0136 3FD0     	 beq .L290
 4060 0138 92E0     	 b .L286
 4061              	.L303:
2007:../SSC/Src/ecatslv.c ****             {
2008:../SSC/Src/ecatslv.c ****                 case INIT_2_PREOP:
2009:../SSC/Src/ecatslv.c ****                 case INIT_2_BOOT:
2010:../SSC/Src/ecatslv.c ****                     if(bApplEsmPending)
 4062              	 .loc 3 2010 0
 4063 013a 574B     	 ldr r3,.L306+12
 4064 013c 1B78     	 ldrb r3,[r3]
 4065 013e 002B     	 cmp r3,#0
 4066 0140 1BD0     	 beq .L291
2011:../SSC/Src/ecatslv.c ****                     {
2012:../SSC/Src/ecatslv.c ****                         bApplEsmPending = FALSE;
 4067              	 .loc 3 2012 0
 4068 0142 554B     	 ldr r3,.L306+12
 4069 0144 0022     	 movs r2,#0
 4070 0146 1A70     	 strb r2,[r3]
2013:../SSC/Src/ecatslv.c ****                         /*APPL_StartMailboxHandler() need to be called*/
2014:../SSC/Src/ecatslv.c ****                         result = APPL_StartMailboxHandler();
 4071              	 .loc 3 2014 0
 4072 0148 FFF7FEFF 	 bl APPL_StartMailboxHandler
 4073 014c 0346     	 mov r3,r0
 4074 014e 7B80     	 strh r3,[r7,#2]
2015:../SSC/Src/ecatslv.c **** 
2016:../SSC/Src/ecatslv.c ****                         if(result == 0)
 4075              	 .loc 3 2016 0
 4076 0150 7B88     	 ldrh r3,[r7,#2]
 4077 0152 002B     	 cmp r3,#0
 4078 0154 09D1     	 bne .L292
2017:../SSC/Src/ecatslv.c ****                         {
2018:../SSC/Src/ecatslv.c ****                             /*The application specific transition was successful => set active mail
2019:../SSC/Src/ecatslv.c ****                             bMbxRunning = TRUE;
 4079              	 .loc 3 2019 0
 4080 0156 584B     	 ldr r3,.L306+44
 4081 0158 0122     	 movs r2,#1
 4082 015a 1A70     	 strb r2,[r3]
2020:../SSC/Src/ecatslv.c ****                             Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
 4083              	 .loc 3 2020 0
 4084 015c 4D4B     	 ldr r3,.L306+8
 4085 015e 1B88     	 ldrh r3,[r3]
 4086 0160 DBB2     	 uxtb r3,r3
 4087 0162 03F00F03 	 and r3,r3,#15
 4088 0166 FB71     	 strb r3,[r7,#7]
 4089 0168 07E0     	 b .L291
 4090              	.L292:
2021:../SSC/Src/ecatslv.c ****                         }
2022:../SSC/Src/ecatslv.c ****                         else
2023:../SSC/Src/ecatslv.c ****                         {
2024:../SSC/Src/ecatslv.c ****                             /*The application specific transition failed.
2025:../SSC/Src/ecatslv.c ****                             (In pending case the application need to complete the transition)*/
2026:../SSC/Src/ecatslv.c **** 
2027:../SSC/Src/ecatslv.c ****                             if(result != NOERROR_INWORK)
 4091              	 .loc 3 2027 0
 4092 016a 7B88     	 ldrh r3,[r7,#2]
 4093 016c FF2B     	 cmp r3,#255
 4094 016e 04D0     	 beq .L291
2028:../SSC/Src/ecatslv.c ****                             {
2029:../SSC/Src/ecatslv.c ****                                 APPL_StopMailboxHandler();
 4095              	 .loc 3 2029 0
 4096 0170 FFF7FEFF 	 bl APPL_StopMailboxHandler
2030:../SSC/Src/ecatslv.c ****                                 MBX_StopMailboxHandler();
 4097              	 .loc 3 2030 0
 4098 0174 FFF7FEFF 	 bl MBX_StopMailboxHandler
2031:../SSC/Src/ecatslv.c ****                             }
2032:../SSC/Src/ecatslv.c ****                         }
2033:../SSC/Src/ecatslv.c ****                     }
2034:../SSC/Src/ecatslv.c ****                 break;
 4099              	 .loc 3 2034 0
 4100 0178 72E0     	 b .L286
 4101              	.L291:
 4102 017a 71E0     	 b .L286
 4103              	.L287:
2035:../SSC/Src/ecatslv.c ****                 case PREOP_2_SAFEOP:
2036:../SSC/Src/ecatslv.c ****                     if(bApplEsmPending)
 4104              	 .loc 3 2036 0
 4105 017c 464B     	 ldr r3,.L306+12
 4106 017e 1B78     	 ldrb r3,[r3]
 4107 0180 002B     	 cmp r3,#0
 4108 0182 18D0     	 beq .L293
2037:../SSC/Src/ecatslv.c ****                     {
2038:../SSC/Src/ecatslv.c ****                         bApplEsmPending = FALSE;
 4109              	 .loc 3 2038 0
 4110 0184 444B     	 ldr r3,.L306+12
 4111 0186 0022     	 movs r2,#0
 4112 0188 1A70     	 strb r2,[r3]
2039:../SSC/Src/ecatslv.c ****                         result = APPL_StartInputHandler(&u16ALEventMask);
 4113              	 .loc 3 2039 0
 4114 018a 4C48     	 ldr r0,.L306+48
 4115 018c FFF7FEFF 	 bl APPL_StartInputHandler
 4116 0190 0346     	 mov r3,r0
 4117 0192 7B80     	 strh r3,[r7,#2]
2040:../SSC/Src/ecatslv.c **** 
2041:../SSC/Src/ecatslv.c ****                         if(result == 0)
 4118              	 .loc 3 2041 0
 4119 0194 7B88     	 ldrh r3,[r7,#2]
 4120 0196 002B     	 cmp r3,#0
 4121 0198 05D1     	 bne .L294
2042:../SSC/Src/ecatslv.c ****                         {
2043:../SSC/Src/ecatslv.c ****                             bEcatInputUpdateRunning = TRUE;
 4122              	 .loc 3 2043 0
 4123 019a 494B     	 ldr r3,.L306+52
 4124 019c 0122     	 movs r2,#1
 4125 019e 1A70     	 strb r2,[r3]
2044:../SSC/Src/ecatslv.c ****                             Status = STATE_SAFEOP;
 4126              	 .loc 3 2044 0
 4127 01a0 0423     	 movs r3,#4
 4128 01a2 FB71     	 strb r3,[r7,#7]
 4129 01a4 07E0     	 b .L293
 4130              	.L294:
2045:../SSC/Src/ecatslv.c ****                         }
2046:../SSC/Src/ecatslv.c ****                         else
2047:../SSC/Src/ecatslv.c ****                         {
2048:../SSC/Src/ecatslv.c ****                             /*The application specific transition failed.
2049:../SSC/Src/ecatslv.c ****                             (In pending case the application need to complete the transition)*/
2050:../SSC/Src/ecatslv.c **** 
2051:../SSC/Src/ecatslv.c ****                             if(result != NOERROR_INWORK)
 4131              	 .loc 3 2051 0
 4132 01a6 7B88     	 ldrh r3,[r7,#2]
 4133 01a8 FF2B     	 cmp r3,#255
 4134 01aa 04D0     	 beq .L293
2052:../SSC/Src/ecatslv.c ****                             {
2053:../SSC/Src/ecatslv.c ****                                 APPL_StopInputHandler();
 4135              	 .loc 3 2053 0
 4136 01ac FFF7FEFF 	 bl APPL_StopInputHandler
2054:../SSC/Src/ecatslv.c ****                                 StopInputHandler();
 4137              	 .loc 3 2054 0
 4138 01b0 FFF7FEFF 	 bl StopInputHandler
2055:../SSC/Src/ecatslv.c ****                             }
2056:../SSC/Src/ecatslv.c ****                         }
2057:../SSC/Src/ecatslv.c ****                     }
2058:../SSC/Src/ecatslv.c ****                 break;
 4139              	 .loc 3 2058 0
 4140 01b4 54E0     	 b .L286
 4141              	.L293:
 4142 01b6 53E0     	 b .L286
 4143              	.L290:
2059:../SSC/Src/ecatslv.c ****                 case SAFEOP_2_OP:
2060:../SSC/Src/ecatslv.c ****                    if(bApplEsmPending)
 4144              	 .loc 3 2060 0
 4145 01b8 374B     	 ldr r3,.L306+12
 4146 01ba 1B78     	 ldrb r3,[r3]
 4147 01bc 002B     	 cmp r3,#0
 4148 01be 4ED0     	 beq .L295
2061:../SSC/Src/ecatslv.c ****                     {
2062:../SSC/Src/ecatslv.c ****                         if(bDcSyncActive)
 4149              	 .loc 3 2062 0
 4150 01c0 384B     	 ldr r3,.L306+24
 4151 01c2 1B78     	 ldrb r3,[r3]
 4152 01c4 002B     	 cmp r3,#0
 4153 01c6 2AD0     	 beq .L296
2063:../SSC/Src/ecatslv.c ****                         {
2064:../SSC/Src/ecatslv.c ****                             if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i1
 4154              	 .loc 3 2064 0
 4155 01c8 3E4B     	 ldr r3,.L306+56
 4156 01ca 1B88     	 ldrh r3,[r3]
 4157 01cc 1BB2     	 sxth r3,r3
 4158 01ce 002B     	 cmp r3,#0
 4159 01d0 45DD     	 ble .L295
 4160              	 .loc 3 2064 0 is_stmt 0 discriminator 1
 4161 01d2 3C4B     	 ldr r3,.L306+56
 4162 01d4 1A88     	 ldrh r2,[r3]
 4163 01d6 3C4B     	 ldr r3,.L306+60
 4164 01d8 1B88     	 ldrh r3,[r3]
 4165 01da 12B2     	 sxth r2,r2
 4166 01dc 1BB2     	 sxth r3,r3
 4167 01de 9A42     	 cmp r2,r3
 4168 01e0 3DDC     	 bgt .L295
2065:../SSC/Src/ecatslv.c ****                             {
2066:../SSC/Src/ecatslv.c ****                                 /*Pll sequence valid for 200ms (set in APPL_StartOutputHandler() )
2067:../SSC/Src/ecatslv.c ****                                 acknowledge state transition to OP */
2068:../SSC/Src/ecatslv.c **** 
2069:../SSC/Src/ecatslv.c ****                                 i16WaitForPllRunningTimeout = 0;
 4169              	 .loc 3 2069 0 is_stmt 1
 4170 01e2 384B     	 ldr r3,.L306+56
 4171 01e4 0022     	 movs r2,#0
 4172 01e6 1A80     	 strh r2,[r3]
2070:../SSC/Src/ecatslv.c ****                                 i16WaitForPllRunningCnt = 0;
 4173              	 .loc 3 2070 0
 4174 01e8 374B     	 ldr r3,.L306+60
 4175 01ea 0022     	 movs r2,#0
 4176 01ec 1A80     	 strh r2,[r3]
2071:../SSC/Src/ecatslv.c **** 
2072:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM4*/
2073:../SSC/Src/ecatslv.c ****                                 bApplEsmPending = FALSE;
 4177              	 .loc 3 2073 0
 4178 01ee 2A4B     	 ldr r3,.L306+12
 4179 01f0 0022     	 movs r2,#0
 4180 01f2 1A70     	 strb r2,[r3]
2074:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM4*/
2075:../SSC/Src/ecatslv.c ****                                 result = APPL_StartOutputHandler();
 4181              	 .loc 3 2075 0
 4182 01f4 FFF7FEFF 	 bl APPL_StartOutputHandler
 4183 01f8 0346     	 mov r3,r0
 4184 01fa 7B80     	 strh r3,[r7,#2]
2076:../SSC/Src/ecatslv.c **** 
2077:../SSC/Src/ecatslv.c ****                                 if(result == 0)
 4185              	 .loc 3 2077 0
 4186 01fc 7B88     	 ldrh r3,[r7,#2]
 4187 01fe 002B     	 cmp r3,#0
 4188 0200 05D1     	 bne .L298
2078:../SSC/Src/ecatslv.c ****                                 {
2079:../SSC/Src/ecatslv.c ****                                     /* Slave is OPERATIONAL */
2080:../SSC/Src/ecatslv.c ****                                     bEcatOutputUpdateRunning = TRUE;
 4189              	 .loc 3 2080 0
 4190 0202 2C4B     	 ldr r3,.L306+40
 4191 0204 0122     	 movs r2,#1
 4192 0206 1A70     	 strb r2,[r3]
2081:../SSC/Src/ecatslv.c ****                                     Status = STATE_OP;
 4193              	 .loc 3 2081 0
 4194 0208 0823     	 movs r3,#8
 4195 020a FB71     	 strb r3,[r7,#7]
 4196 020c 27E0     	 b .L295
 4197              	.L298:
2082:../SSC/Src/ecatslv.c ****                                 }
2083:../SSC/Src/ecatslv.c ****                                 else
2084:../SSC/Src/ecatslv.c ****                                 {
2085:../SSC/Src/ecatslv.c ****                                     if(result != NOERROR_INWORK)
 4198              	 .loc 3 2085 0
 4199 020e 7B88     	 ldrh r3,[r7,#2]
 4200 0210 FF2B     	 cmp r3,#255
 4201 0212 24D0     	 beq .L295
2086:../SSC/Src/ecatslv.c ****                                     {
2087:../SSC/Src/ecatslv.c ****                                         APPL_StopOutputHandler();
 4202              	 .loc 3 2087 0
 4203 0214 FFF7FEFF 	 bl APPL_StopOutputHandler
2088:../SSC/Src/ecatslv.c ****                                         StopOutputHandler();
 4204              	 .loc 3 2088 0
 4205 0218 FFF7FEFF 	 bl StopOutputHandler
2089:../SSC/Src/ecatslv.c ****                                     }
2090:../SSC/Src/ecatslv.c ****                                 }
2091:../SSC/Src/ecatslv.c ****                             }
2092:../SSC/Src/ecatslv.c ****                         }
2093:../SSC/Src/ecatslv.c ****                         else
2094:../SSC/Src/ecatslv.c ****                         {
2095:../SSC/Src/ecatslv.c ****                             if(nPdOutputSize == 0 || bEcatFirstOutputsReceived)
2096:../SSC/Src/ecatslv.c ****                             {
2097:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM4*/
2098:../SSC/Src/ecatslv.c ****                                 bApplEsmPending = FALSE;  
2099:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM4*/
2100:../SSC/Src/ecatslv.c ****                                 result = APPL_StartOutputHandler();
2101:../SSC/Src/ecatslv.c **** 
2102:../SSC/Src/ecatslv.c ****                                 if(result == 0)
2103:../SSC/Src/ecatslv.c ****                                 {
2104:../SSC/Src/ecatslv.c ****                                     /* Slave is OPERATIONAL */
2105:../SSC/Src/ecatslv.c ****                                     bEcatOutputUpdateRunning = TRUE;
2106:../SSC/Src/ecatslv.c ****                                     Status = STATE_OP;
2107:../SSC/Src/ecatslv.c ****                                 }
2108:../SSC/Src/ecatslv.c ****                                 else
2109:../SSC/Src/ecatslv.c ****                                 {
2110:../SSC/Src/ecatslv.c ****                                     if(result != NOERROR_INWORK)
2111:../SSC/Src/ecatslv.c ****                                     {
2112:../SSC/Src/ecatslv.c ****                                         APPL_StopOutputHandler();
2113:../SSC/Src/ecatslv.c ****                                         StopOutputHandler();
2114:../SSC/Src/ecatslv.c ****                                     }
2115:../SSC/Src/ecatslv.c ****                                 }
2116:../SSC/Src/ecatslv.c ****                             }
2117:../SSC/Src/ecatslv.c ****                         }       
2118:../SSC/Src/ecatslv.c ****                     }             
2119:../SSC/Src/ecatslv.c ****                 break;
 4206              	 .loc 3 2119 0
 4207 021c 1FE0     	 b .L305
 4208              	.L296:
2095:../SSC/Src/ecatslv.c ****                             {
 4209              	 .loc 3 2095 0
 4210 021e 244B     	 ldr r3,.L306+36
 4211 0220 1B88     	 ldrh r3,[r3]
 4212 0222 002B     	 cmp r3,#0
 4213 0224 03D0     	 beq .L299
2095:../SSC/Src/ecatslv.c ****                             {
 4214              	 .loc 3 2095 0 is_stmt 0 discriminator 1
 4215 0226 214B     	 ldr r3,.L306+32
 4216 0228 1B78     	 ldrb r3,[r3]
 4217 022a 002B     	 cmp r3,#0
 4218 022c 17D0     	 beq .L295
 4219              	.L299:
2098:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM4*/
 4220              	 .loc 3 2098 0 is_stmt 1
 4221 022e 1A4B     	 ldr r3,.L306+12
 4222 0230 0022     	 movs r2,#0
 4223 0232 1A70     	 strb r2,[r3]
2100:../SSC/Src/ecatslv.c **** 
 4224              	 .loc 3 2100 0
 4225 0234 FFF7FEFF 	 bl APPL_StartOutputHandler
 4226 0238 0346     	 mov r3,r0
 4227 023a 7B80     	 strh r3,[r7,#2]
2102:../SSC/Src/ecatslv.c ****                                 {
 4228              	 .loc 3 2102 0
 4229 023c 7B88     	 ldrh r3,[r7,#2]
 4230 023e 002B     	 cmp r3,#0
 4231 0240 05D1     	 bne .L300
2105:../SSC/Src/ecatslv.c ****                                     Status = STATE_OP;
 4232              	 .loc 3 2105 0
 4233 0242 1C4B     	 ldr r3,.L306+40
 4234 0244 0122     	 movs r2,#1
 4235 0246 1A70     	 strb r2,[r3]
2106:../SSC/Src/ecatslv.c ****                                 }
 4236              	 .loc 3 2106 0
 4237 0248 0823     	 movs r3,#8
 4238 024a FB71     	 strb r3,[r7,#7]
 4239 024c 07E0     	 b .L295
 4240              	.L300:
2110:../SSC/Src/ecatslv.c ****                                     {
 4241              	 .loc 3 2110 0
 4242 024e 7B88     	 ldrh r3,[r7,#2]
 4243 0250 FF2B     	 cmp r3,#255
 4244 0252 04D0     	 beq .L295
2112:../SSC/Src/ecatslv.c ****                                         StopOutputHandler();
 4245              	 .loc 3 2112 0
 4246 0254 FFF7FEFF 	 bl APPL_StopOutputHandler
2113:../SSC/Src/ecatslv.c ****                                     }
 4247              	 .loc 3 2113 0
 4248 0258 FFF7FEFF 	 bl StopOutputHandler
 4249              	 .loc 3 2119 0
 4250 025c FFE7     	 b .L305
 4251              	.L295:
 4252              	.L305:
 4253 025e 00BF     	 nop
 4254              	.L286:
2120:../SSC/Src/ecatslv.c ****             }//Switch - transition
2121:../SSC/Src/ecatslv.c ****         }
2122:../SSC/Src/ecatslv.c **** 
2123:../SSC/Src/ecatslv.c ****         if(Status != 0)
 4255              	 .loc 3 2123 0
 4256 0260 FB79     	 ldrb r3,[r7,#7]
 4257 0262 002B     	 cmp r3,#0
 4258 0264 0FD0     	 beq .L264
2124:../SSC/Src/ecatslv.c ****         {
2125:../SSC/Src/ecatslv.c ****             /*Pending state transition finished => write AL Status and AL Status Code*/
2126:../SSC/Src/ecatslv.c ****             bEcatWaitForAlControlRes = FALSE;
 4259              	 .loc 3 2126 0
 4260 0266 094B     	 ldr r3,.L306
 4261 0268 0022     	 movs r2,#0
 4262 026a 1A70     	 strb r2,[r3]
2127:../SSC/Src/ecatslv.c **** 
2128:../SSC/Src/ecatslv.c ****             if (StatusCode != 0)
 4263              	 .loc 3 2128 0
 4264 026c BB88     	 ldrh r3,[r7,#4]
 4265 026e 002B     	 cmp r3,#0
 4266 0270 03D0     	 beq .L301
2129:../SSC/Src/ecatslv.c ****             {
2130:../SSC/Src/ecatslv.c ****                 Status |= STATE_CHANGE;
 4267              	 .loc 3 2130 0
 4268 0272 FB79     	 ldrb r3,[r7,#7]
 4269 0274 43F01003 	 orr r3,r3,#16
 4270 0278 FB71     	 strb r3,[r7,#7]
 4271              	.L301:
2131:../SSC/Src/ecatslv.c ****             }
2132:../SSC/Src/ecatslv.c **** 
2133:../SSC/Src/ecatslv.c ****             SetALStatus(Status,StatusCode);
 4272              	 .loc 3 2133 0
 4273 027a FA79     	 ldrb r2,[r7,#7]
 4274 027c BB88     	 ldrh r3,[r7,#4]
 4275 027e 1046     	 mov r0,r2
 4276 0280 1946     	 mov r1,r3
 4277 0282 FFF7FEFF 	 bl SetALStatus
 4278              	.L264:
 4279              	.LBE8:
2134:../SSC/Src/ecatslv.c ****         }
2135:../SSC/Src/ecatslv.c ****     }// Pending state transition (bEcatWaitForAlControlRes == true)
2136:../SSC/Src/ecatslv.c **** }
 4280              	 .loc 3 2136 0
 4281 0286 0837     	 adds r7,r7,#8
 4282              	.LCFI87:
 4283              	 .cfi_def_cfa_offset 8
 4284 0288 BD46     	 mov sp,r7
 4285              	.LCFI88:
 4286              	 .cfi_def_cfa_register 13
 4287              	 
 4288 028a 80BD     	 pop {r7,pc}
 4289              	.L307:
 4290              	 .align 2
 4291              	.L306:
 4292 028c 00000000 	 .word bEcatWaitForAlControlRes
 4293 0290 00000000 	 .word EsmTimeoutCounter
 4294 0294 00000000 	 .word nEcatStateTrans
 4295 0298 00000000 	 .word bApplEsmPending
 4296 029c 00000000 	 .word bLocalErrorFlag
 4297 02a0 00000000 	 .word u16LocalErrorCode
 4298 02a4 00000000 	 .word bDcSyncActive
 4299 02a8 00000000 	 .word bDcRunning
 4300 02ac 00000000 	 .word bEcatFirstOutputsReceived
 4301 02b0 00000000 	 .word nPdOutputSize
 4302 02b4 00000000 	 .word bEcatOutputUpdateRunning
 4303 02b8 00000000 	 .word bMbxRunning
 4304 02bc 00000000 	 .word u16ALEventMask
 4305 02c0 00000000 	 .word bEcatInputUpdateRunning
 4306 02c4 00000000 	 .word i16WaitForPllRunningTimeout
 4307 02c8 00000000 	 .word i16WaitForPllRunningCnt
 4308              	 .cfi_endproc
 4309              	.LFE193:
 4311              	 .section .text.DC_CheckWatchdog,"ax",%progbits
 4312              	 .align 2
 4313              	 .global DC_CheckWatchdog
 4314              	 .thumb
 4315              	 .thumb_func
 4317              	DC_CheckWatchdog:
 4318              	.LFB194:
2137:../SSC/Src/ecatslv.c **** 
2138:../SSC/Src/ecatslv.c **** 
2139:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2140:../SSC/Src/ecatslv.c **** /**
2141:../SSC/Src/ecatslv.c **** 
2142:../SSC/Src/ecatslv.c ****  \brief    This function checks the current Sync state and set the local flags
2143:../SSC/Src/ecatslv.c ****  The analyse of the local flags is handled in "CheckIfEcatError"
2144:../SSC/Src/ecatslv.c **** 
2145:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2146:../SSC/Src/ecatslv.c **** void DC_CheckWatchdog(void)
2147:../SSC/Src/ecatslv.c **** {
 4319              	 .loc 3 2147 0
 4320              	 .cfi_startproc
 4321              	 
 4322              	 
 4323              	 
 4324 0000 80B4     	 push {r7}
 4325              	.LCFI89:
 4326              	 .cfi_def_cfa_offset 4
 4327              	 .cfi_offset 7,-4
 4328 0002 00AF     	 add r7,sp,#0
 4329              	.LCFI90:
 4330              	 .cfi_def_cfa_register 7
2148:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT5*/
2149:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT5*/
2150:../SSC/Src/ecatslv.c **** 
2151:../SSC/Src/ecatslv.c ****     if(bDcSyncActive && bEcatInputUpdateRunning)
 4331              	 .loc 3 2151 0
 4332 0004 394B     	 ldr r3,.L319
 4333 0006 1B78     	 ldrb r3,[r3]
 4334 0008 002B     	 cmp r3,#0
 4335 000a 6BD0     	 beq .L308
 4336              	 .loc 3 2151 0 is_stmt 0 discriminator 1
 4337 000c 384B     	 ldr r3,.L319+4
 4338 000e 1B78     	 ldrb r3,[r3]
 4339 0010 002B     	 cmp r3,#0
 4340 0012 67D0     	 beq .L308
2152:../SSC/Src/ecatslv.c ****     {
2153:../SSC/Src/ecatslv.c ****         /*If Sync0 watchdog is enabled and expired*/
2154:../SSC/Src/ecatslv.c ****         if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
 4341              	 .loc 3 2154 0 is_stmt 1
 4342 0014 374B     	 ldr r3,.L319+8
 4343 0016 1B88     	 ldrh r3,[r3]
 4344 0018 002B     	 cmp r3,#0
 4345 001a 09D0     	 beq .L310
 4346              	 .loc 3 2154 0 is_stmt 0 discriminator 1
 4347 001c 364B     	 ldr r3,.L319+12
 4348 001e 1A88     	 ldrh r2,[r3]
 4349 0020 344B     	 ldr r3,.L319+8
 4350 0022 1B88     	 ldrh r3,[r3]
 4351 0024 9A42     	 cmp r2,r3
 4352 0026 03D3     	 bcc .L310
2155:../SSC/Src/ecatslv.c ****         {
2156:../SSC/Src/ecatslv.c ****                 /*Sync0 watchdog expired*/
2157:../SSC/Src/ecatslv.c ****                 bDcRunning = FALSE;        
 4353              	 .loc 3 2157 0 is_stmt 1
 4354 0028 344B     	 ldr r3,.L319+16
 4355 002a 0022     	 movs r2,#0
 4356 002c 1A70     	 strb r2,[r3]
 4357 002e 0EE0     	 b .L311
 4358              	.L310:
2158:../SSC/Src/ecatslv.c ****         }
2159:../SSC/Src/ecatslv.c ****         else
2160:../SSC/Src/ecatslv.c ****         {
2161:../SSC/Src/ecatslv.c ****             if(Sync0WdCounter < Sync0WdValue)
 4359              	 .loc 3 2161 0
 4360 0030 314B     	 ldr r3,.L319+12
 4361 0032 1A88     	 ldrh r2,[r3]
 4362 0034 2F4B     	 ldr r3,.L319+8
 4363 0036 1B88     	 ldrh r3,[r3]
 4364 0038 9A42     	 cmp r2,r3
 4365 003a 05D2     	 bcs .L312
2162:../SSC/Src/ecatslv.c ****             {
2163:../SSC/Src/ecatslv.c ****                 Sync0WdCounter ++;
 4366              	 .loc 3 2163 0
 4367 003c 2E4B     	 ldr r3,.L319+12
 4368 003e 1B88     	 ldrh r3,[r3]
 4369 0040 0133     	 adds r3,r3,#1
 4370 0042 9AB2     	 uxth r2,r3
 4371 0044 2C4B     	 ldr r3,.L319+12
 4372 0046 1A80     	 strh r2,[r3]
 4373              	.L312:
2164:../SSC/Src/ecatslv.c ****             }
2165:../SSC/Src/ecatslv.c **** 
2166:../SSC/Src/ecatslv.c ****             bDcRunning = TRUE;
 4374              	 .loc 3 2166 0
 4375 0048 2C4B     	 ldr r3,.L319+16
 4376 004a 0122     	 movs r2,#1
 4377 004c 1A70     	 strb r2,[r3]
 4378              	.L311:
2167:../SSC/Src/ecatslv.c ****         }
2168:../SSC/Src/ecatslv.c **** 
2169:../SSC/Src/ecatslv.c ****         if(bDcRunning)
 4379              	 .loc 3 2169 0
 4380 004e 2B4B     	 ldr r3,.L319+16
 4381 0050 1B78     	 ldrb r3,[r3]
 4382 0052 002B     	 cmp r3,#0
 4383 0054 13D0     	 beq .L313
2170:../SSC/Src/ecatslv.c ****         {
2171:../SSC/Src/ecatslv.c ****             /*Check the Sync1 cycle if Sync1 Wd is enabled*/
2172:../SSC/Src/ecatslv.c ****             if(Sync1WdValue > 0)
 4384              	 .loc 3 2172 0
 4385 0056 2A4B     	 ldr r3,.L319+20
 4386 0058 1B88     	 ldrh r3,[r3]
 4387 005a 002B     	 cmp r3,#0
 4388 005c 0FD0     	 beq .L313
2173:../SSC/Src/ecatslv.c ****             {
2174:../SSC/Src/ecatslv.c ****                 if(Sync1WdCounter < Sync1WdValue)
 4389              	 .loc 3 2174 0
 4390 005e 294B     	 ldr r3,.L319+24
 4391 0060 1A88     	 ldrh r2,[r3]
 4392 0062 274B     	 ldr r3,.L319+20
 4393 0064 1B88     	 ldrh r3,[r3]
 4394 0066 9A42     	 cmp r2,r3
 4395 0068 06D2     	 bcs .L314
2175:../SSC/Src/ecatslv.c ****                 {
2176:../SSC/Src/ecatslv.c ****                     Sync1WdCounter ++;
 4396              	 .loc 3 2176 0
 4397 006a 264B     	 ldr r3,.L319+24
 4398 006c 1B88     	 ldrh r3,[r3]
 4399 006e 0133     	 adds r3,r3,#1
 4400 0070 9AB2     	 uxth r2,r3
 4401 0072 244B     	 ldr r3,.L319+24
 4402 0074 1A80     	 strh r2,[r3]
 4403 0076 02E0     	 b .L313
 4404              	.L314:
2177:../SSC/Src/ecatslv.c ****                 }
2178:../SSC/Src/ecatslv.c ****                 else
2179:../SSC/Src/ecatslv.c ****                 {
2180:../SSC/Src/ecatslv.c ****                     /*Sync1 watchdog expired*/
2181:../SSC/Src/ecatslv.c ****                     bDcRunning = FALSE;
 4405              	 .loc 3 2181 0
 4406 0078 204B     	 ldr r3,.L319+16
 4407 007a 0022     	 movs r2,#0
 4408 007c 1A70     	 strb r2,[r3]
 4409              	.L313:
2182:../SSC/Src/ecatslv.c ****                 }
2183:../SSC/Src/ecatslv.c ****             }
2184:../SSC/Src/ecatslv.c ****         }
2185:../SSC/Src/ecatslv.c ****         if(bDcRunning)
 4410              	 .loc 3 2185 0
 4411 007e 1F4B     	 ldr r3,.L319+16
 4412 0080 1B78     	 ldrb r3,[r3]
 4413 0082 002B     	 cmp r3,#0
 4414 0084 27D0     	 beq .L315
2186:../SSC/Src/ecatslv.c ****         {
2187:../SSC/Src/ecatslv.c ****            if(sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit)
 4415              	 .loc 3 2187 0
 4416 0086 204B     	 ldr r3,.L319+28
 4417 0088 1A8D     	 ldrh r2,[r3,#40]
 4418 008a 204B     	 ldr r3,.L319+32
 4419 008c 1B89     	 ldrh r3,[r3,#8]
 4420 008e 9A42     	 cmp r2,r3
 4421 0090 11D2     	 bcs .L316
2188:../SSC/Src/ecatslv.c ****             {
2189:../SSC/Src/ecatslv.c ****                 bSmSyncSequenceValid = TRUE;
 4422              	 .loc 3 2189 0
 4423 0092 1F4B     	 ldr r3,.L319+36
 4424 0094 0122     	 movs r2,#1
 4425 0096 1A70     	 strb r2,[r3]
2190:../SSC/Src/ecatslv.c **** 
2191:../SSC/Src/ecatslv.c ****                 /*Wait for PLL is active increment the Pll valid counter*/
2192:../SSC/Src/ecatslv.c ****                 if (i16WaitForPllRunningTimeout > 0)
 4426              	 .loc 3 2192 0
 4427 0098 1E4B     	 ldr r3,.L319+40
 4428 009a 1B88     	 ldrh r3,[r3]
 4429 009c 1BB2     	 sxth r3,r3
 4430 009e 002B     	 cmp r3,#0
 4431 00a0 20DD     	 ble .L308
2193:../SSC/Src/ecatslv.c ****                 {
2194:../SSC/Src/ecatslv.c ****                     i16WaitForPllRunningCnt++;
 4432              	 .loc 3 2194 0
 4433 00a2 1D4B     	 ldr r3,.L319+44
 4434 00a4 1B88     	 ldrh r3,[r3]
 4435 00a6 9BB2     	 uxth r3,r3
 4436 00a8 9BB2     	 uxth r3,r3
 4437 00aa 0133     	 adds r3,r3,#1
 4438 00ac 9BB2     	 uxth r3,r3
 4439 00ae 9AB2     	 uxth r2,r3
 4440 00b0 194B     	 ldr r3,.L319+44
 4441 00b2 1A80     	 strh r2,[r3]
 4442 00b4 16E0     	 b .L308
 4443              	.L316:
2195:../SSC/Src/ecatslv.c ****                 }
2196:../SSC/Src/ecatslv.c ****             }
2197:../SSC/Src/ecatslv.c ****             else if (bSmSyncSequenceValid)
 4444              	 .loc 3 2197 0
 4445 00b6 164B     	 ldr r3,.L319+36
 4446 00b8 1B78     	 ldrb r3,[r3]
 4447 00ba 002B     	 cmp r3,#0
 4448 00bc 12D0     	 beq .L308
2198:../SSC/Src/ecatslv.c ****             {
2199:../SSC/Src/ecatslv.c ****                     bSmSyncSequenceValid = FALSE;
 4449              	 .loc 3 2199 0
 4450 00be 144B     	 ldr r3,.L319+36
 4451 00c0 0022     	 movs r2,#0
 4452 00c2 1A70     	 strb r2,[r3]
2200:../SSC/Src/ecatslv.c **** 
2201:../SSC/Src/ecatslv.c ****                 /*Wait for PLL is active reset the Pll valid counter*/
2202:../SSC/Src/ecatslv.c ****                 if (i16WaitForPllRunningTimeout > 0)
 4453              	 .loc 3 2202 0
 4454 00c4 134B     	 ldr r3,.L319+40
 4455 00c6 1B88     	 ldrh r3,[r3]
 4456 00c8 1BB2     	 sxth r3,r3
 4457 00ca 002B     	 cmp r3,#0
 4458 00cc 0ADD     	 ble .L308
2203:../SSC/Src/ecatslv.c ****                 {
2204:../SSC/Src/ecatslv.c ****                     i16WaitForPllRunningCnt = 0;
 4459              	 .loc 3 2204 0
 4460 00ce 124B     	 ldr r3,.L319+44
 4461 00d0 0022     	 movs r2,#0
 4462 00d2 1A80     	 strh r2,[r3]
 4463 00d4 06E0     	 b .L308
 4464              	.L315:
2205:../SSC/Src/ecatslv.c ****                 }
2206:../SSC/Src/ecatslv.c ****             }
2207:../SSC/Src/ecatslv.c ****         }
2208:../SSC/Src/ecatslv.c ****         else if(bSmSyncSequenceValid)
 4465              	 .loc 3 2208 0
 4466 00d6 0E4B     	 ldr r3,.L319+36
 4467 00d8 1B78     	 ldrb r3,[r3]
 4468 00da 002B     	 cmp r3,#0
 4469 00dc 02D0     	 beq .L308
2209:../SSC/Src/ecatslv.c ****         {
2210:../SSC/Src/ecatslv.c ****            bSmSyncSequenceValid = FALSE;
 4470              	 .loc 3 2210 0
 4471 00de 0C4B     	 ldr r3,.L319+36
 4472 00e0 0022     	 movs r2,#0
 4473 00e2 1A70     	 strb r2,[r3]
 4474              	.L308:
2211:../SSC/Src/ecatslv.c ****         }
2212:../SSC/Src/ecatslv.c ****     }
2213:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_START(V5.12) ECAT5*/
2214:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_END(V5.12) ECAT5*/
2215:../SSC/Src/ecatslv.c **** }
 4475              	 .loc 3 2215 0
 4476 00e4 BD46     	 mov sp,r7
 4477              	.LCFI91:
 4478              	 .cfi_def_cfa_register 13
 4479              	 
 4480 00e6 5DF8047B 	 ldr r7,[sp],#4
 4481              	.LCFI92:
 4482              	 .cfi_restore 7
 4483              	 .cfi_def_cfa_offset 0
 4484 00ea 7047     	 bx lr
 4485              	.L320:
 4486              	 .align 2
 4487              	.L319:
 4488 00ec 00000000 	 .word bDcSyncActive
 4489 00f0 00000000 	 .word bEcatInputUpdateRunning
 4490 00f4 00000000 	 .word Sync0WdValue
 4491 00f8 00000000 	 .word Sync0WdCounter
 4492 00fc 00000000 	 .word bDcRunning
 4493 0100 00000000 	 .word Sync1WdValue
 4494 0104 00000000 	 .word Sync1WdCounter
 4495 0108 00000000 	 .word sSyncManOutPar
 4496 010c 00000000 	 .word sErrorSettings
 4497 0110 00000000 	 .word bSmSyncSequenceValid
 4498 0114 00000000 	 .word i16WaitForPllRunningTimeout
 4499 0118 00000000 	 .word i16WaitForPllRunningCnt
 4500              	 .cfi_endproc
 4501              	.LFE194:
 4503              	 .section .text.CheckIfEcatError,"ax",%progbits
 4504              	 .align 2
 4505              	 .global CheckIfEcatError
 4506              	 .thumb
 4507              	 .thumb_func
 4509              	CheckIfEcatError:
 4510              	.LFB195:
2216:../SSC/Src/ecatslv.c **** 
2217:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2218:../SSC/Src/ecatslv.c **** /**
2219:../SSC/Src/ecatslv.c **** 
2220:../SSC/Src/ecatslv.c ****  \brief    Checks communication and synchronisation variables and update AL status / AL status code
2221:../SSC/Src/ecatslv.c **** 
2222:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2223:../SSC/Src/ecatslv.c **** void CheckIfEcatError(void)
2224:../SSC/Src/ecatslv.c **** {
 4511              	 .loc 3 2224 0
 4512              	 .cfi_startproc
 4513              	 
 4514              	 
 4515 0000 80B5     	 push {r7,lr}
 4516              	.LCFI93:
 4517              	 .cfi_def_cfa_offset 8
 4518              	 .cfi_offset 7,-8
 4519              	 .cfi_offset 14,-4
 4520 0002 82B0     	 sub sp,sp,#8
 4521              	.LCFI94:
 4522              	 .cfi_def_cfa_offset 16
 4523 0004 00AF     	 add r7,sp,#0
 4524              	.LCFI95:
 4525              	 .cfi_def_cfa_register 7
2225:../SSC/Src/ecatslv.c ****    /*if the watchdog is enabled check the the process data watchdog in the ESC
2226:../SSC/Src/ecatslv.c ****    and set the AL status code 0x1B if the watchdog expired*/
2227:../SSC/Src/ecatslv.c ****    if (EcatWdValue != 0)
 4526              	 .loc 3 2227 0
 4527 0006 204B     	 ldr r3,.L326
 4528 0008 1B88     	 ldrh r3,[r3]
 4529 000a 002B     	 cmp r3,#0
 4530 000c 19D0     	 beq .L322
 4531              	.LBB9:
2228:../SSC/Src/ecatslv.c ****    {
2229:../SSC/Src/ecatslv.c ****       /*watchdog time is set => watchdog is active*/
2230:../SSC/Src/ecatslv.c ****       UINT16 WdStatusOK = 0;
 4532              	 .loc 3 2230 0
 4533 000e 0023     	 movs r3,#0
 4534 0010 FB80     	 strh r3,[r7,#6]
2231:../SSC/Src/ecatslv.c **** 
2232:../SSC/Src/ecatslv.c ****       HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
 4535              	 .loc 3 2232 0
 4536 0012 1E4B     	 ldr r3,.L326+4
 4537 0014 1B88     	 ldrh r3,[r3]
 4538 0016 FB80     	 strh r3,[r7,#6]
2233:../SSC/Src/ecatslv.c ****       WdStatusOK = SWAPWORD(WdStatusOK);
2234:../SSC/Src/ecatslv.c **** 
2235:../SSC/Src/ecatslv.c ****       if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
 4539              	 .loc 3 2235 0
 4540 0018 FB88     	 ldrh r3,[r7,#6]
 4541 001a 03F00103 	 and r3,r3,#1
 4542 001e 002B     	 cmp r3,#0
 4543 0020 0FD1     	 bne .L322
 4544              	 .loc 3 2235 0 is_stmt 0 discriminator 1
 4545 0022 1B4B     	 ldr r3,.L326+8
 4546 0024 1B88     	 ldrh r3,[r3]
 4547 0026 002B     	 cmp r3,#0
 4548 0028 0BD0     	 beq .L322
2236:../SSC/Src/ecatslv.c ****       {
2237:../SSC/Src/ecatslv.c ****          /*The device is in OP state*/
2238:../SSC/Src/ecatslv.c **** 
2239:../SSC/Src/ecatslv.c ****          if (bEcatOutputUpdateRunning
 4549              	 .loc 3 2239 0 is_stmt 1
 4550 002a 1A4B     	 ldr r3,.L326+12
 4551 002c 1B78     	 ldrb r3,[r3]
 4552 002e 002B     	 cmp r3,#0
 4553 0030 04D0     	 beq .L323
2240:../SSC/Src/ecatslv.c ****             )
2241:../SSC/Src/ecatslv.c ****          {
2242:../SSC/Src/ecatslv.c ****             AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
 4554              	 .loc 3 2242 0
 4555 0032 0420     	 movs r0,#4
 4556 0034 1B21     	 movs r1,#27
 4557 0036 FFF7FEFF 	 bl AL_ControlInd
2243:../SSC/Src/ecatslv.c ****             return;
 4558              	 .loc 3 2243 0
 4559 003a 22E0     	 b .L321
 4560              	.L323:
2244:../SSC/Src/ecatslv.c ****          }
2245:../SSC/Src/ecatslv.c **** 
2246:../SSC/Src/ecatslv.c ****          else
2247:../SSC/Src/ecatslv.c ****          {
2248:../SSC/Src/ecatslv.c ****             bEcatFirstOutputsReceived = FALSE;
 4561              	 .loc 3 2248 0
 4562 003c 164B     	 ldr r3,.L326+16
 4563 003e 0022     	 movs r2,#0
 4564 0040 1A70     	 strb r2,[r3]
 4565              	.L322:
 4566              	.LBE9:
2249:../SSC/Src/ecatslv.c ****          }
2250:../SSC/Src/ecatslv.c ****       }
2251:../SSC/Src/ecatslv.c ****    }
2252:../SSC/Src/ecatslv.c **** 
2253:../SSC/Src/ecatslv.c ****    if(bDcSyncActive)
 4567              	 .loc 3 2253 0
 4568 0042 164B     	 ldr r3,.L326+20
 4569 0044 1B78     	 ldrb r3,[r3]
 4570 0046 002B     	 cmp r3,#0
 4571 0048 1BD0     	 beq .L321
2254:../SSC/Src/ecatslv.c ****    {
2255:../SSC/Src/ecatslv.c ****        if(bEcatOutputUpdateRunning)
 4572              	 .loc 3 2255 0
 4573 004a 124B     	 ldr r3,.L326+12
 4574 004c 1B78     	 ldrb r3,[r3]
 4575 004e 002B     	 cmp r3,#0
 4576 0050 17D0     	 beq .L321
2256:../SSC/Src/ecatslv.c ****        {
2257:../SSC/Src/ecatslv.c ****            /*Slave is in OP state*/
2258:../SSC/Src/ecatslv.c ****            if(!bDcRunning)
 4577              	 .loc 3 2258 0
 4578 0052 134B     	 ldr r3,.L326+24
 4579 0054 1B78     	 ldrb r3,[r3]
 4580 0056 83F00103 	 eor r3,r3,#1
 4581 005a DBB2     	 uxtb r3,r3
 4582 005c 002B     	 cmp r3,#0
 4583 005e 04D0     	 beq .L325
2259:../SSC/Src/ecatslv.c ****            {
2260:../SSC/Src/ecatslv.c ****                AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
 4584              	 .loc 3 2260 0
 4585 0060 0420     	 movs r0,#4
 4586 0062 2C21     	 movs r1,#44
 4587 0064 FFF7FEFF 	 bl AL_ControlInd
2261:../SSC/Src/ecatslv.c ****                return;
 4588              	 .loc 3 2261 0
 4589 0068 0BE0     	 b .L321
 4590              	.L325:
2262:../SSC/Src/ecatslv.c ****            }
2263:../SSC/Src/ecatslv.c ****            else if(!bSmSyncSequenceValid)
 4591              	 .loc 3 2263 0
 4592 006a 0E4B     	 ldr r3,.L326+28
 4593 006c 1B78     	 ldrb r3,[r3]
 4594 006e 83F00103 	 eor r3,r3,#1
 4595 0072 DBB2     	 uxtb r3,r3
 4596 0074 002B     	 cmp r3,#0
 4597 0076 04D0     	 beq .L321
2264:../SSC/Src/ecatslv.c ****            {
2265:../SSC/Src/ecatslv.c ****                AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
 4598              	 .loc 3 2265 0
 4599 0078 0420     	 movs r0,#4
 4600 007a 1A21     	 movs r1,#26
 4601 007c FFF7FEFF 	 bl AL_ControlInd
2266:../SSC/Src/ecatslv.c ****                return;
 4602              	 .loc 3 2266 0
 4603 0080 00BF     	 nop
 4604              	.L321:
2267:../SSC/Src/ecatslv.c ****            }
2268:../SSC/Src/ecatslv.c ****         
2269:../SSC/Src/ecatslv.c ****        }
2270:../SSC/Src/ecatslv.c ****    }
2271:../SSC/Src/ecatslv.c **** }
 4605              	 .loc 3 2271 0
 4606 0082 0837     	 adds r7,r7,#8
 4607              	.LCFI96:
 4608              	 .cfi_def_cfa_offset 8
 4609 0084 BD46     	 mov sp,r7
 4610              	.LCFI97:
 4611              	 .cfi_def_cfa_register 13
 4612              	 
 4613 0086 80BD     	 pop {r7,pc}
 4614              	.L327:
 4615              	 .align 2
 4616              	.L326:
 4617 0088 00000000 	 .word EcatWdValue
 4618 008c 40040154 	 .word 1409352768
 4619 0090 00000000 	 .word nPdOutputSize
 4620 0094 00000000 	 .word bEcatOutputUpdateRunning
 4621 0098 00000000 	 .word bEcatFirstOutputsReceived
 4622 009c 00000000 	 .word bDcSyncActive
 4623 00a0 00000000 	 .word bDcRunning
 4624 00a4 00000000 	 .word bSmSyncSequenceValid
 4625              	 .cfi_endproc
 4626              	.LFE195:
 4628              	 .section .text.ECAT_StateChange,"ax",%progbits
 4629              	 .align 2
 4630              	 .global ECAT_StateChange
 4631              	 .thumb
 4632              	 .thumb_func
 4634              	ECAT_StateChange:
 4635              	.LFB196:
2272:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2273:../SSC/Src/ecatslv.c **** /**
2274:../SSC/Src/ecatslv.c ****  \param    alStatus: requested state
2275:../SSC/Src/ecatslv.c ****  \param    alStatusCode: value for the AL-Status register
2276:../SSC/Src/ecatslv.c ****  
2277:../SSC/Src/ecatslv.c ****  \brief    This function changes the state of the EtherCAT slave if the requested state
2278:../SSC/Src/ecatslv.c ****              is lower than the actual state, otherwise the error condition will be reset.
2279:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2280:../SSC/Src/ecatslv.c **** 
2281:../SSC/Src/ecatslv.c **** void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
2282:../SSC/Src/ecatslv.c **** {
 4636              	 .loc 3 2282 0
 4637              	 .cfi_startproc
 4638              	 
 4639              	 
 4640 0000 80B5     	 push {r7,lr}
 4641              	.LCFI98:
 4642              	 .cfi_def_cfa_offset 8
 4643              	 .cfi_offset 7,-8
 4644              	 .cfi_offset 14,-4
 4645 0002 84B0     	 sub sp,sp,#16
 4646              	.LCFI99:
 4647              	 .cfi_def_cfa_offset 24
 4648 0004 00AF     	 add r7,sp,#0
 4649              	.LCFI100:
 4650              	 .cfi_def_cfa_register 7
 4651 0006 0346     	 mov r3,r0
 4652 0008 0A46     	 mov r2,r1
 4653 000a FB71     	 strb r3,[r7,#7]
 4654 000c 1346     	 mov r3,r2
 4655 000e BB80     	 strh r3,[r7,#4]
2283:../SSC/Src/ecatslv.c ****     UINT8 Status = alStatus;
 4656              	 .loc 3 2283 0
 4657 0010 FB79     	 ldrb r3,[r7,#7]
 4658 0012 FB73     	 strb r3,[r7,#15]
2284:../SSC/Src/ecatslv.c **** 
2285:../SSC/Src/ecatslv.c **** 
2286:../SSC/Src/ecatslv.c ****     if(bEcatWaitForAlControlRes)
 4659              	 .loc 3 2286 0
 4660 0014 504B     	 ldr r3,.L352
 4661 0016 1B78     	 ldrb r3,[r3]
 4662 0018 002B     	 cmp r3,#0
 4663 001a 71D0     	 beq .L329
2287:../SSC/Src/ecatslv.c ****     {
2288:../SSC/Src/ecatslv.c ****         /*State transition is pending*/
2289:../SSC/Src/ecatslv.c **** 
2290:../SSC/Src/ecatslv.c ****         if(bApplEsmPending)
 4664              	 .loc 3 2290 0
 4665 001c 4F4B     	 ldr r3,.L352+4
 4666 001e 1B78     	 ldrb r3,[r3]
 4667 0020 002B     	 cmp r3,#0
 4668 0022 0DD0     	 beq .L330
2291:../SSC/Src/ecatslv.c ****         {
2292:../SSC/Src/ecatslv.c ****             /*The generic stack has currently control of the state transition.
2293:../SSC/Src/ecatslv.c ****             In case on an local error force ESM timeout*/
2294:../SSC/Src/ecatslv.c ****             if(alStatusCode != 0)
 4669              	 .loc 3 2294 0
 4670 0024 BB88     	 ldrh r3,[r7,#4]
 4671 0026 002B     	 cmp r3,#0
 4672 0028 00F09380 	 beq .L328
2295:../SSC/Src/ecatslv.c ****             {
2296:../SSC/Src/ecatslv.c ****                 bLocalErrorFlag = TRUE;
 4673              	 .loc 3 2296 0
 4674 002c 4C4B     	 ldr r3,.L352+8
 4675 002e 0122     	 movs r2,#1
 4676 0030 1A70     	 strb r2,[r3]
2297:../SSC/Src/ecatslv.c ****                 u16LocalErrorCode = alStatusCode;
 4677              	 .loc 3 2297 0
 4678 0032 4C4A     	 ldr r2,.L352+12
 4679 0034 BB88     	 ldrh r3,[r7,#4]
 4680 0036 1380     	 strh r3,[r2]
2298:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = 0;
 4681              	 .loc 3 2298 0
 4682 0038 4B4B     	 ldr r3,.L352+16
 4683 003a 0022     	 movs r2,#0
 4684 003c 1A80     	 strh r2,[r3]
 4685 003e 88E0     	 b .L328
 4686              	.L330:
2299:../SSC/Src/ecatslv.c ****             }
2300:../SSC/Src/ecatslv.c ****         }
2301:../SSC/Src/ecatslv.c ****         else
2302:../SSC/Src/ecatslv.c ****         {
2303:../SSC/Src/ecatslv.c ****             /*complete the state transition*/
2304:../SSC/Src/ecatslv.c **** 
2305:../SSC/Src/ecatslv.c ****             if(alStatusCode != 0)
 4687              	 .loc 3 2305 0
 4688 0040 BB88     	 ldrh r3,[r7,#4]
 4689 0042 002B     	 cmp r3,#0
 4690 0044 27D0     	 beq .L333
2306:../SSC/Src/ecatslv.c ****             {
2307:../SSC/Src/ecatslv.c ****                 bLocalErrorFlag = TRUE;
 4691              	 .loc 3 2307 0
 4692 0046 464B     	 ldr r3,.L352+8
 4693 0048 0122     	 movs r2,#1
 4694 004a 1A70     	 strb r2,[r3]
2308:../SSC/Src/ecatslv.c ****                 u16LocalErrorCode = alStatusCode;
 4695              	 .loc 3 2308 0
 4696 004c 454A     	 ldr r2,.L352+12
 4697 004e BB88     	 ldrh r3,[r7,#4]
 4698 0050 1380     	 strh r3,[r2]
2309:../SSC/Src/ecatslv.c **** 
2310:../SSC/Src/ecatslv.c ****                 /*State transition failed due to local application reasons*/
2311:../SSC/Src/ecatslv.c ****                 switch(nEcatStateTrans)
 4699              	 .loc 3 2311 0
 4700 0052 464B     	 ldr r3,.L352+20
 4701 0054 1B88     	 ldrh r3,[r3]
 4702 0056 242B     	 cmp r3,#36
 4703 0058 0DD0     	 beq .L335
 4704 005a 242B     	 cmp r3,#36
 4705 005c 03DC     	 bgt .L336
 4706 005e 123B     	 subs r3,r3,#18
 4707 0060 012B     	 cmp r3,#1
 4708 0062 12D8     	 bhi .L334
 4709 0064 02E0     	 b .L350
 4710              	.L336:
 4711 0066 482B     	 cmp r3,#72
 4712 0068 0AD0     	 beq .L338
 4713 006a 0EE0     	 b .L334
 4714              	.L350:
2312:../SSC/Src/ecatslv.c ****                 {
2313:../SSC/Src/ecatslv.c ****                     case INIT_2_PREOP:
2314:../SSC/Src/ecatslv.c ****                     case INIT_2_BOOT:
2315:../SSC/Src/ecatslv.c ****                      
2316:../SSC/Src/ecatslv.c ****                           APPL_StopMailboxHandler();
 4715              	 .loc 3 2316 0
 4716 006c FFF7FEFF 	 bl APPL_StopMailboxHandler
2317:../SSC/Src/ecatslv.c ****                           MBX_StopMailboxHandler();
 4717              	 .loc 3 2317 0
 4718 0070 FFF7FEFF 	 bl MBX_StopMailboxHandler
2318:../SSC/Src/ecatslv.c ****                     break;
 4719              	 .loc 3 2318 0
 4720 0074 09E0     	 b .L334
 4721              	.L335:
2319:../SSC/Src/ecatslv.c ****                     case PREOP_2_SAFEOP:
2320:../SSC/Src/ecatslv.c ****                           APPL_StopInputHandler();
 4722              	 .loc 3 2320 0
 4723 0076 FFF7FEFF 	 bl APPL_StopInputHandler
2321:../SSC/Src/ecatslv.c ****                           StopInputHandler();
 4724              	 .loc 3 2321 0
 4725 007a FFF7FEFF 	 bl StopInputHandler
2322:../SSC/Src/ecatslv.c ****                     break;
 4726              	 .loc 3 2322 0
 4727 007e 04E0     	 b .L334
 4728              	.L338:
2323:../SSC/Src/ecatslv.c ****                     case SAFEOP_2_OP:
2324:../SSC/Src/ecatslv.c ****                           APPL_StopOutputHandler();
 4729              	 .loc 3 2324 0
 4730 0080 FFF7FEFF 	 bl APPL_StopOutputHandler
2325:../SSC/Src/ecatslv.c ****                           StopOutputHandler();
 4731              	 .loc 3 2325 0
 4732 0084 FFF7FEFF 	 bl StopOutputHandler
2326:../SSC/Src/ecatslv.c ****                     break;
 4733              	 .loc 3 2326 0
 4734 0088 00BF     	 nop
 4735              	.L334:
2327:../SSC/Src/ecatslv.c ****                 }
2328:../SSC/Src/ecatslv.c **** 
2329:../SSC/Src/ecatslv.c ****                 /*In case of a failed state transition the */
2330:../SSC/Src/ecatslv.c ****                 Status =  (UINT8)(nEcatStateTrans >> 4);
 4736              	 .loc 3 2330 0
 4737 008a 384B     	 ldr r3,.L352+20
 4738 008c 1B88     	 ldrh r3,[r3]
 4739 008e 1B09     	 lsrs r3,r3,#4
 4740 0090 9BB2     	 uxth r3,r3
 4741 0092 FB73     	 strb r3,[r7,#15]
 4742 0094 23E0     	 b .L339
 4743              	.L333:
2331:../SSC/Src/ecatslv.c ****             }
2332:../SSC/Src/ecatslv.c ****             else
2333:../SSC/Src/ecatslv.c ****             {
2334:../SSC/Src/ecatslv.c ****                 /*State transition succeed*/
2335:../SSC/Src/ecatslv.c ****                  
2336:../SSC/Src/ecatslv.c ****                 switch(nEcatStateTrans)
 4744              	 .loc 3 2336 0
 4745 0096 354B     	 ldr r3,.L352+20
 4746 0098 1B88     	 ldrh r3,[r3]
 4747 009a 242B     	 cmp r3,#36
 4748 009c 0CD0     	 beq .L341
 4749 009e 242B     	 cmp r3,#36
 4750 00a0 03DC     	 bgt .L342
 4751 00a2 123B     	 subs r3,r3,#18
 4752 00a4 012B     	 cmp r3,#1
 4753 00a6 14D8     	 bhi .L340
 4754 00a8 02E0     	 b .L351
 4755              	.L342:
 4756 00aa 482B     	 cmp r3,#72
 4757 00ac 0DD0     	 beq .L344
 4758 00ae 10E0     	 b .L340
 4759              	.L351:
2337:../SSC/Src/ecatslv.c ****                 {
2338:../SSC/Src/ecatslv.c ****                     case INIT_2_PREOP:
2339:../SSC/Src/ecatslv.c ****                     case INIT_2_BOOT:
2340:../SSC/Src/ecatslv.c ****                         bMbxRunning = TRUE;
 4760              	 .loc 3 2340 0
 4761 00b0 2F4B     	 ldr r3,.L352+24
 4762 00b2 0122     	 movs r2,#1
 4763 00b4 1A70     	 strb r2,[r3]
2341:../SSC/Src/ecatslv.c ****                     break;
 4764              	 .loc 3 2341 0
 4765 00b6 0CE0     	 b .L340
 4766              	.L341:
2342:../SSC/Src/ecatslv.c ****                     case PREOP_2_SAFEOP:
2343:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM4*/
2344:../SSC/Src/ecatslv.c ****                         /* initialize the AL Event Mask register (0x204) */
2345:../SSC/Src/ecatslv.c ****                         SetALEventMask(u16ALEventMask);
 4767              	 .loc 3 2345 0
 4768 00b8 2E4B     	 ldr r3,.L352+28
 4769 00ba 1B88     	 ldrh r3,[r3]
 4770 00bc 1846     	 mov r0,r3
 4771 00be FFF7FEFF 	 bl SetALEventMask
2346:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM4*/
2347:../SSC/Src/ecatslv.c ****                         bEcatInputUpdateRunning = TRUE;
 4772              	 .loc 3 2347 0
 4773 00c2 2D4B     	 ldr r3,.L352+32
 4774 00c4 0122     	 movs r2,#1
 4775 00c6 1A70     	 strb r2,[r3]
2348:../SSC/Src/ecatslv.c ****                     break;
 4776              	 .loc 3 2348 0
 4777 00c8 03E0     	 b .L340
 4778              	.L344:
2349:../SSC/Src/ecatslv.c ****                     case SAFEOP_2_OP:
2350:../SSC/Src/ecatslv.c ****                           bEcatOutputUpdateRunning = TRUE;
 4779              	 .loc 3 2350 0
 4780 00ca 2C4B     	 ldr r3,.L352+36
 4781 00cc 0122     	 movs r2,#1
 4782 00ce 1A70     	 strb r2,[r3]
2351:../SSC/Src/ecatslv.c ****                     break;
 4783              	 .loc 3 2351 0
 4784 00d0 00BF     	 nop
 4785              	.L340:
2352:../SSC/Src/ecatslv.c ****                 }
2353:../SSC/Src/ecatslv.c **** 
2354:../SSC/Src/ecatslv.c ****                 /*In case of a failed state transition the */
2355:../SSC/Src/ecatslv.c ****                 Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
 4786              	 .loc 3 2355 0
 4787 00d2 264B     	 ldr r3,.L352+20
 4788 00d4 1B88     	 ldrh r3,[r3]
 4789 00d6 DBB2     	 uxtb r3,r3
 4790 00d8 03F00F03 	 and r3,r3,#15
 4791 00dc FB73     	 strb r3,[r7,#15]
 4792              	.L339:
2356:../SSC/Src/ecatslv.c ****             }
2357:../SSC/Src/ecatslv.c ****                 /*Pending state transition finished => write AL Status and AL Status Code*/
2358:../SSC/Src/ecatslv.c ****                 bEcatWaitForAlControlRes = FALSE;
 4793              	 .loc 3 2358 0
 4794 00de 1E4B     	 ldr r3,.L352
 4795 00e0 0022     	 movs r2,#0
 4796 00e2 1A70     	 strb r2,[r3]
2359:../SSC/Src/ecatslv.c **** 
2360:../SSC/Src/ecatslv.c ****                 if (alStatusCode != 0)
 4797              	 .loc 3 2360 0
 4798 00e4 BB88     	 ldrh r3,[r7,#4]
 4799 00e6 002B     	 cmp r3,#0
 4800 00e8 03D0     	 beq .L345
2361:../SSC/Src/ecatslv.c ****                 {
2362:../SSC/Src/ecatslv.c ****                     Status |= STATE_CHANGE;
 4801              	 .loc 3 2362 0
 4802 00ea FB7B     	 ldrb r3,[r7,#15]
 4803 00ec 43F01003 	 orr r3,r3,#16
 4804 00f0 FB73     	 strb r3,[r7,#15]
 4805              	.L345:
2363:../SSC/Src/ecatslv.c ****                 }
2364:../SSC/Src/ecatslv.c **** 
2365:../SSC/Src/ecatslv.c ****                 SetALStatus(Status,alStatusCode);
 4806              	 .loc 3 2365 0
 4807 00f2 FA7B     	 ldrb r2,[r7,#15]
 4808 00f4 BB88     	 ldrh r3,[r7,#4]
 4809 00f6 1046     	 mov r0,r2
 4810 00f8 1946     	 mov r1,r3
 4811 00fa FFF7FEFF 	 bl SetALStatus
 4812 00fe 28E0     	 b .L328
 4813              	.L329:
2366:../SSC/Src/ecatslv.c **** 
2367:../SSC/Src/ecatslv.c ****         }// state transition need to be completed by the local application
2368:../SSC/Src/ecatslv.c ****     }//State transition pending
2369:../SSC/Src/ecatslv.c ****     else
2370:../SSC/Src/ecatslv.c ****     {
2371:../SSC/Src/ecatslv.c ****         if ( alStatusCode != 0 )
 4814              	 .loc 3 2371 0
 4815 0100 BB88     	 ldrh r3,[r7,#4]
 4816 0102 002B     	 cmp r3,#0
 4817 0104 1BD0     	 beq .L347
2372:../SSC/Src/ecatslv.c ****         {
2373:../SSC/Src/ecatslv.c ****             bLocalErrorFlag = TRUE;
 4818              	 .loc 3 2373 0
 4819 0106 164B     	 ldr r3,.L352+8
 4820 0108 0122     	 movs r2,#1
 4821 010a 1A70     	 strb r2,[r3]
2374:../SSC/Src/ecatslv.c ****             u16LocalErrorCode = alStatusCode;
 4822              	 .loc 3 2374 0
 4823 010c 154A     	 ldr r2,.L352+12
 4824 010e BB88     	 ldrh r3,[r7,#4]
 4825 0110 1380     	 strh r3,[r2]
2375:../SSC/Src/ecatslv.c **** 
2376:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM1*/    
2377:../SSC/Src/ecatslv.c ****             if (((nAlStatus & STATE_CHANGE) != STATE_CHANGE) || ((alStatus & STATE_MASK) < (nAlStat
 4826              	 .loc 3 2377 0
 4827 0112 1B4B     	 ldr r3,.L352+40
 4828 0114 1B78     	 ldrb r3,[r3]
 4829 0116 03F01003 	 and r3,r3,#16
 4830 011a 002B     	 cmp r3,#0
 4831 011c 08D0     	 beq .L348
 4832              	 .loc 3 2377 0 is_stmt 0 discriminator 1
 4833 011e FB79     	 ldrb r3,[r7,#7]
 4834 0120 03F00F02 	 and r2,r3,#15
 4835 0124 164B     	 ldr r3,.L352+40
 4836 0126 1B78     	 ldrb r3,[r3]
 4837 0128 03F00F03 	 and r3,r3,#15
 4838 012c 9A42     	 cmp r2,r3
 4839 012e 10DA     	 bge .L328
 4840              	.L348:
2378:../SSC/Src/ecatslv.c ****             {
2379:../SSC/Src/ecatslv.c ****                 /* Local error has happened, we change the state if necessary */
2380:../SSC/Src/ecatslv.c **** 
2381:../SSC/Src/ecatslv.c ****                /* no error pending and the target state is lower than the current one*/
2382:../SSC/Src/ecatslv.c ****                 AL_ControlInd(alStatus, alStatusCode);
 4841              	 .loc 3 2382 0 is_stmt 1
 4842 0130 FA79     	 ldrb r2,[r7,#7]
 4843 0132 BB88     	 ldrh r3,[r7,#4]
 4844 0134 1046     	 mov r0,r2
 4845 0136 1946     	 mov r1,r3
 4846 0138 FFF7FEFF 	 bl AL_ControlInd
 4847 013c 09E0     	 b .L328
 4848              	.L347:
2383:../SSC/Src/ecatslv.c ****             }
2384:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM1*/    
2385:../SSC/Src/ecatslv.c ****         }
2386:../SSC/Src/ecatslv.c ****         else if (bLocalErrorFlag)
 4849              	 .loc 3 2386 0
 4850 013e 084B     	 ldr r3,.L352+8
 4851 0140 1B78     	 ldrb r3,[r3]
 4852 0142 002B     	 cmp r3,#0
 4853 0144 05D0     	 beq .L328
2387:../SSC/Src/ecatslv.c ****         {
2388:../SSC/Src/ecatslv.c ****             /*a local error is gone*/
2389:../SSC/Src/ecatslv.c ****             bLocalErrorFlag = FALSE;
 4854              	 .loc 3 2389 0
 4855 0146 064B     	 ldr r3,.L352+8
 4856 0148 0022     	 movs r2,#0
 4857 014a 1A70     	 strb r2,[r3]
2390:../SSC/Src/ecatslv.c ****             u16LocalErrorCode = 0x00;
 4858              	 .loc 3 2390 0
 4859 014c 054B     	 ldr r3,.L352+12
 4860 014e 0022     	 movs r2,#0
 4861 0150 1A80     	 strh r2,[r3]
 4862              	.L328:
2391:../SSC/Src/ecatslv.c ****         }
2392:../SSC/Src/ecatslv.c ****     }
2393:../SSC/Src/ecatslv.c **** }
 4863              	 .loc 3 2393 0
 4864 0152 1037     	 adds r7,r7,#16
 4865              	.LCFI101:
 4866              	 .cfi_def_cfa_offset 8
 4867 0154 BD46     	 mov sp,r7
 4868              	.LCFI102:
 4869              	 .cfi_def_cfa_register 13
 4870              	 
 4871 0156 80BD     	 pop {r7,pc}
 4872              	.L353:
 4873              	 .align 2
 4874              	.L352:
 4875 0158 00000000 	 .word bEcatWaitForAlControlRes
 4876 015c 00000000 	 .word bApplEsmPending
 4877 0160 00000000 	 .word bLocalErrorFlag
 4878 0164 00000000 	 .word u16LocalErrorCode
 4879 0168 00000000 	 .word EsmTimeoutCounter
 4880 016c 00000000 	 .word nEcatStateTrans
 4881 0170 00000000 	 .word bMbxRunning
 4882 0174 00000000 	 .word u16ALEventMask
 4883 0178 00000000 	 .word bEcatInputUpdateRunning
 4884 017c 00000000 	 .word bEcatOutputUpdateRunning
 4885 0180 00000000 	 .word nAlStatus
 4886              	 .cfi_endproc
 4887              	.LFE196:
 4889              	 .section .text.ECAT_Init,"ax",%progbits
 4890              	 .align 2
 4891              	 .global ECAT_Init
 4892              	 .thumb
 4893              	 .thumb_func
 4895              	ECAT_Init:
 4896              	.LFB197:
2394:../SSC/Src/ecatslv.c **** 
2395:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2396:../SSC/Src/ecatslv.c **** /**
2397:../SSC/Src/ecatslv.c **** 
2398:../SSC/Src/ecatslv.c ****  \brief    This function initialize the EtherCAT Slave Interface.
2399:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2400:../SSC/Src/ecatslv.c **** 
2401:../SSC/Src/ecatslv.c **** void ECAT_Init(void)
2402:../SSC/Src/ecatslv.c **** {
 4897              	 .loc 3 2402 0
 4898              	 .cfi_startproc
 4899              	 
 4900              	 
 4901 0000 80B5     	 push {r7,lr}
 4902              	.LCFI103:
 4903              	 .cfi_def_cfa_offset 8
 4904              	 .cfi_offset 7,-8
 4905              	 .cfi_offset 14,-4
 4906 0002 82B0     	 sub sp,sp,#8
 4907              	.LCFI104:
 4908              	 .cfi_def_cfa_offset 16
 4909 0004 00AF     	 add r7,sp,#0
 4910              	.LCFI105:
 4911              	 .cfi_def_cfa_register 7
2403:../SSC/Src/ecatslv.c ****     UINT8 i;
2404:../SSC/Src/ecatslv.c **** 
2405:../SSC/Src/ecatslv.c ****     /*Get Maximum Number of SyncManagers and supported DPRAM size*/
2406:../SSC/Src/ecatslv.c ****     HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
 4912              	 .loc 3 2406 0
 4913 0006 394B     	 ldr r3,.L357
 4914 0008 1B78     	 ldrb r3,[r3]
 4915 000a DAB2     	 uxtb r2,r3
 4916 000c 384B     	 ldr r3,.L357+4
 4917 000e 1A70     	 strb r2,[r3]
2407:../SSC/Src/ecatslv.c **** 
2408:../SSC/Src/ecatslv.c ****     HW_EscReadWord(nMaxEscAddress, ESC_DPRAM_SIZE_OFFSET);
 4918              	 .loc 3 2408 0
 4919 0010 384B     	 ldr r3,.L357+8
 4920 0012 1B88     	 ldrh r3,[r3]
 4921 0014 9AB2     	 uxth r2,r3
 4922 0016 384B     	 ldr r3,.L357+12
 4923 0018 1A80     	 strh r2,[r3]
2409:../SSC/Src/ecatslv.c ****     //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
2410:../SSC/Src/ecatslv.c ****     nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
 4924              	 .loc 3 2410 0
 4925 001a 374B     	 ldr r3,.L357+12
 4926 001c 1B88     	 ldrh r3,[r3]
 4927 001e 9B02     	 lsls r3,r3,#10
 4928 0020 9BB2     	 uxth r3,r3
 4929 0022 03F6FF73 	 addw r3,r3,#4095
 4930 0026 9AB2     	 uxth r2,r3
 4931 0028 334B     	 ldr r3,.L357+12
 4932 002a 1A80     	 strh r2,[r3]
2411:../SSC/Src/ecatslv.c **** 
2412:../SSC/Src/ecatslv.c ****     /* Get EEPROM loaded information */
2413:../SSC/Src/ecatslv.c ****     UpdateEEPROMLoadedState();
 4933              	 .loc 3 2413 0
 4934 002c FFF7FEFF 	 bl UpdateEEPROMLoadedState
2414:../SSC/Src/ecatslv.c **** 
2415:../SSC/Src/ecatslv.c ****     /* disable all Sync Manager channels */
2416:../SSC/Src/ecatslv.c ****     for (i = 0; i < nMaxSyncMan; i++)
 4935              	 .loc 3 2416 0
 4936 0030 0023     	 movs r3,#0
 4937 0032 FB71     	 strb r3,[r7,#7]
 4938 0034 06E0     	 b .L355
 4939              	.L356:
2417:../SSC/Src/ecatslv.c ****     {
2418:../SSC/Src/ecatslv.c ****         DisableSyncManChannel(i);
 4940              	 .loc 3 2418 0 discriminator 3
 4941 0036 FB79     	 ldrb r3,[r7,#7]
 4942 0038 1846     	 mov r0,r3
 4943 003a FFF7FEFF 	 bl DisableSyncManChannel
2416:../SSC/Src/ecatslv.c ****     {
 4944              	 .loc 3 2416 0 discriminator 3
 4945 003e FB79     	 ldrb r3,[r7,#7]
 4946 0040 0133     	 adds r3,r3,#1
 4947 0042 FB71     	 strb r3,[r7,#7]
 4948              	.L355:
2416:../SSC/Src/ecatslv.c ****     {
 4949              	 .loc 3 2416 0 is_stmt 0 discriminator 1
 4950 0044 2A4B     	 ldr r3,.L357+4
 4951 0046 1B78     	 ldrb r3,[r3]
 4952 0048 FA79     	 ldrb r2,[r7,#7]
 4953 004a 9A42     	 cmp r2,r3
 4954 004c F3D3     	 bcc .L356
2419:../SSC/Src/ecatslv.c ****     }
2420:../SSC/Src/ecatslv.c **** 
2421:../SSC/Src/ecatslv.c ****     /* initialize the mailbox handler */
2422:../SSC/Src/ecatslv.c ****     MBX_Init();
 4955              	 .loc 3 2422 0 is_stmt 1
 4956 004e FFF7FEFF 	 bl MBX_Init
2423:../SSC/Src/ecatslv.c **** 
2424:../SSC/Src/ecatslv.c ****     /* initialize variables */
2425:../SSC/Src/ecatslv.c ****     bApplEsmPending = FALSE;
 4957              	 .loc 3 2425 0
 4958 0052 2A4B     	 ldr r3,.L357+16
 4959 0054 0022     	 movs r2,#0
 4960 0056 1A70     	 strb r2,[r3]
2426:../SSC/Src/ecatslv.c ****     bEcatWaitForAlControlRes = FALSE;
 4961              	 .loc 3 2426 0
 4962 0058 294B     	 ldr r3,.L357+20
 4963 005a 0022     	 movs r2,#0
 4964 005c 1A70     	 strb r2,[r3]
2427:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 4965              	 .loc 3 2427 0
 4966 005e 294B     	 ldr r3,.L357+24
 4967 0060 0022     	 movs r2,#0
 4968 0062 1A70     	 strb r2,[r3]
2428:../SSC/Src/ecatslv.c ****      bEcatOutputUpdateRunning = FALSE;
 4969              	 .loc 3 2428 0
 4970 0064 284B     	 ldr r3,.L357+28
 4971 0066 0022     	 movs r2,#0
 4972 0068 1A70     	 strb r2,[r3]
2429:../SSC/Src/ecatslv.c ****      bEcatInputUpdateRunning = FALSE;
 4973              	 .loc 3 2429 0
 4974 006a 284B     	 ldr r3,.L357+32
 4975 006c 0022     	 movs r2,#0
 4976 006e 1A70     	 strb r2,[r3]
2430:../SSC/Src/ecatslv.c ****     bWdTrigger = FALSE;
 4977              	 .loc 3 2430 0
 4978 0070 274B     	 ldr r3,.L357+36
 4979 0072 0022     	 movs r2,#0
 4980 0074 1A70     	 strb r2,[r3]
2431:../SSC/Src/ecatslv.c ****     EcatWdValue = 0;
 4981              	 .loc 3 2431 0
 4982 0076 274B     	 ldr r3,.L357+40
 4983 0078 0022     	 movs r2,#0
 4984 007a 1A80     	 strh r2,[r3]
2432:../SSC/Src/ecatslv.c ****     Sync0WdCounter = 0;
 4985              	 .loc 3 2432 0
 4986 007c 264B     	 ldr r3,.L357+44
 4987 007e 0022     	 movs r2,#0
 4988 0080 1A80     	 strh r2,[r3]
2433:../SSC/Src/ecatslv.c ****     Sync0WdValue = 0;
 4989              	 .loc 3 2433 0
 4990 0082 264B     	 ldr r3,.L357+48
 4991 0084 0022     	 movs r2,#0
 4992 0086 1A80     	 strh r2,[r3]
2434:../SSC/Src/ecatslv.c ****     Sync1WdCounter = 0;
 4993              	 .loc 3 2434 0
 4994 0088 254B     	 ldr r3,.L357+52
 4995 008a 0022     	 movs r2,#0
 4996 008c 1A80     	 strh r2,[r3]
2435:../SSC/Src/ecatslv.c ****     Sync1WdValue = 0;
 4997              	 .loc 3 2435 0
 4998 008e 254B     	 ldr r3,.L357+56
 4999 0090 0022     	 movs r2,#0
 5000 0092 1A80     	 strh r2,[r3]
2436:../SSC/Src/ecatslv.c ****     bDcSyncActive = FALSE;
 5001              	 .loc 3 2436 0
 5002 0094 244B     	 ldr r3,.L357+60
 5003 0096 0022     	 movs r2,#0
 5004 0098 1A70     	 strb r2,[r3]
2437:../SSC/Src/ecatslv.c ****     bLocalErrorFlag = FALSE;
 5005              	 .loc 3 2437 0
 5006 009a 244B     	 ldr r3,.L357+64
 5007 009c 0022     	 movs r2,#0
 5008 009e 1A70     	 strb r2,[r3]
2438:../SSC/Src/ecatslv.c ****     u16LocalErrorCode = 0x00;
 5009              	 .loc 3 2438 0
 5010 00a0 234B     	 ldr r3,.L357+68
 5011 00a2 0022     	 movs r2,#0
 5012 00a4 1A80     	 strh r2,[r3]
2439:../SSC/Src/ecatslv.c **** 
2440:../SSC/Src/ecatslv.c ****     u16ALEventMask = 0;
 5013              	 .loc 3 2440 0
 5014 00a6 234B     	 ldr r3,.L357+72
 5015 00a8 0022     	 movs r2,#0
 5016 00aa 1A80     	 strh r2,[r3]
2441:../SSC/Src/ecatslv.c ****     nPdOutputSize = 0;
 5017              	 .loc 3 2441 0
 5018 00ac 224B     	 ldr r3,.L357+76
 5019 00ae 0022     	 movs r2,#0
 5020 00b0 1A80     	 strh r2,[r3]
2442:../SSC/Src/ecatslv.c ****     nPdInputSize = 0;
 5021              	 .loc 3 2442 0
 5022 00b2 224B     	 ldr r3,.L357+80
 5023 00b4 0022     	 movs r2,#0
 5024 00b6 1A80     	 strh r2,[r3]
2443:../SSC/Src/ecatslv.c **** 
2444:../SSC/Src/ecatslv.c ****     /* initialize the AL Status register */
2445:../SSC/Src/ecatslv.c ****     nAlStatus    = STATE_INIT;
 5025              	 .loc 3 2445 0
 5026 00b8 214B     	 ldr r3,.L357+84
 5027 00ba 0122     	 movs r2,#1
 5028 00bc 1A70     	 strb r2,[r3]
2446:../SSC/Src/ecatslv.c ****     SetALStatus(nAlStatus, 0);
 5029              	 .loc 3 2446 0
 5030 00be 204B     	 ldr r3,.L357+84
 5031 00c0 1B78     	 ldrb r3,[r3]
 5032 00c2 1846     	 mov r0,r3
 5033 00c4 0021     	 movs r1,#0
 5034 00c6 FFF7FEFF 	 bl SetALStatus
2447:../SSC/Src/ecatslv.c ****     nEcatStateTrans = 0;
 5035              	 .loc 3 2447 0
 5036 00ca 1E4B     	 ldr r3,.L357+88
 5037 00cc 0022     	 movs r2,#0
 5038 00ce 1A80     	 strh r2,[r3]
2448:../SSC/Src/ecatslv.c ****     u8EcatErrorLed = LED_OFF;
 5039              	 .loc 3 2448 0
 5040 00d0 1D4B     	 ldr r3,.L357+92
 5041 00d2 0022     	 movs r2,#0
 5042 00d4 1A70     	 strb r2,[r3]
2449:../SSC/Src/ecatslv.c **** 
2450:../SSC/Src/ecatslv.c ****     bEscIntEnabled = FALSE;
 5043              	 .loc 3 2450 0
 5044 00d6 1D4B     	 ldr r3,.L357+96
 5045 00d8 0022     	 movs r2,#0
 5046 00da 1A70     	 strb r2,[r3]
2451:../SSC/Src/ecatslv.c **** 
2452:../SSC/Src/ecatslv.c ****     /* initialize the COE part */
2453:../SSC/Src/ecatslv.c ****     COE_Init();
 5047              	 .loc 3 2453 0
 5048 00dc FFF7FEFF 	 bl COE_Init
2454:../SSC/Src/ecatslv.c **** 
2455:../SSC/Src/ecatslv.c ****     /*reset AL event mask*/
2456:../SSC/Src/ecatslv.c ****     ResetALEventMask(0);
 5049              	 .loc 3 2456 0
 5050 00e0 0020     	 movs r0,#0
 5051 00e2 FFF7FEFF 	 bl ResetALEventMask
2457:../SSC/Src/ecatslv.c **** }
 5052              	 .loc 3 2457 0
 5053 00e6 0837     	 adds r7,r7,#8
 5054              	.LCFI106:
 5055              	 .cfi_def_cfa_offset 8
 5056 00e8 BD46     	 mov sp,r7
 5057              	.LCFI107:
 5058              	 .cfi_def_cfa_register 13
 5059              	 
 5060 00ea 80BD     	 pop {r7,pc}
 5061              	.L358:
 5062              	 .align 2
 5063              	.L357:
 5064 00ec 05000154 	 .word 1409351685
 5065 00f0 00000000 	 .word nMaxSyncMan
 5066 00f4 06000154 	 .word 1409351686
 5067 00f8 00000000 	 .word nMaxEscAddress
 5068 00fc 00000000 	 .word bApplEsmPending
 5069 0100 00000000 	 .word bEcatWaitForAlControlRes
 5070 0104 00000000 	 .word bEcatFirstOutputsReceived
 5071 0108 00000000 	 .word bEcatOutputUpdateRunning
 5072 010c 00000000 	 .word bEcatInputUpdateRunning
 5073 0110 00000000 	 .word bWdTrigger
 5074 0114 00000000 	 .word EcatWdValue
 5075 0118 00000000 	 .word Sync0WdCounter
 5076 011c 00000000 	 .word Sync0WdValue
 5077 0120 00000000 	 .word Sync1WdCounter
 5078 0124 00000000 	 .word Sync1WdValue
 5079 0128 00000000 	 .word bDcSyncActive
 5080 012c 00000000 	 .word bLocalErrorFlag
 5081 0130 00000000 	 .word u16LocalErrorCode
 5082 0134 00000000 	 .word u16ALEventMask
 5083 0138 00000000 	 .word nPdOutputSize
 5084 013c 00000000 	 .word nPdInputSize
 5085 0140 00000000 	 .word nAlStatus
 5086 0144 00000000 	 .word nEcatStateTrans
 5087 0148 00000000 	 .word u8EcatErrorLed
 5088 014c 00000000 	 .word bEscIntEnabled
 5089              	 .cfi_endproc
 5090              	.LFE197:
 5092              	 .section .text.ECAT_Main,"ax",%progbits
 5093              	 .align 2
 5094              	 .global ECAT_Main
 5095              	 .thumb
 5096              	 .thumb_func
 5098              	ECAT_Main:
 5099              	.LFB198:
2458:../SSC/Src/ecatslv.c **** 
2459:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2460:../SSC/Src/ecatslv.c **** /**
2461:../SSC/Src/ecatslv.c ****  \brief        This function has to be called cyclically.
2462:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2463:../SSC/Src/ecatslv.c **** 
2464:../SSC/Src/ecatslv.c **** void ECAT_Main(void)
2465:../SSC/Src/ecatslv.c **** {
 5100              	 .loc 3 2465 0
 5101              	 .cfi_startproc
 5102              	 
 5103              	 
 5104 0000 80B5     	 push {r7,lr}
 5105              	.LCFI108:
 5106              	 .cfi_def_cfa_offset 8
 5107              	 .cfi_offset 7,-8
 5108              	 .cfi_offset 14,-4
 5109 0002 82B0     	 sub sp,sp,#8
 5110              	.LCFI109:
 5111              	 .cfi_def_cfa_offset 16
 5112 0004 00AF     	 add r7,sp,#0
 5113              	.LCFI110:
 5114              	 .cfi_def_cfa_register 7
2466:../SSC/Src/ecatslv.c ****     UINT16 ALEventReg;
2467:../SSC/Src/ecatslv.c ****     UINT16 EscAlControl = 0x0000;
 5115              	 .loc 3 2467 0
 5116 0006 0023     	 movs r3,#0
 5117 0008 7B80     	 strh r3,[r7,#2]
2468:../SSC/Src/ecatslv.c ****     UINT8 sm1Activate = SM_SETTING_ENABLE_VALUE;
 5118              	 .loc 3 2468 0
 5119 000a 0123     	 movs r3,#1
 5120 000c 7B71     	 strb r3,[r7,#5]
2469:../SSC/Src/ecatslv.c **** 
2470:../SSC/Src/ecatslv.c **** 
2471:../SSC/Src/ecatslv.c ****     /* check if services are stored in the mailbox */
2472:../SSC/Src/ecatslv.c ****     MBX_Main();
 5121              	 .loc 3 2472 0
 5122 000e FFF7FEFF 	 bl MBX_Main
2473:../SSC/Src/ecatslv.c **** 
2474:../SSC/Src/ecatslv.c **** 
2475:../SSC/Src/ecatslv.c ****     if ( bMbxRunning )
 5123              	 .loc 3 2475 0
 5124 0012 584B     	 ldr r3,.L371
 5125 0014 1B78     	 ldrb r3,[r3]
 5126 0016 002B     	 cmp r3,#0
 5127 0018 02D0     	 beq .L360
2476:../SSC/Src/ecatslv.c ****     {
2477:../SSC/Src/ecatslv.c ****         /* Slave is at least in PREOP, Mailbox is running */
2478:../SSC/Src/ecatslv.c ****         /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was 
2479:../SSC/Src/ecatslv.c ****         HW_EscReadByte(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
 5128              	 .loc 3 2479 0
 5129 001a 574B     	 ldr r3,.L371+4
 5130 001c 1B78     	 ldrb r3,[r3]
 5131 001e 7B71     	 strb r3,[r7,#5]
 5132              	.L360:
2480:../SSC/Src/ecatslv.c ****     }
2481:../SSC/Src/ecatslv.c **** 
2482:../SSC/Src/ecatslv.c ****     /* Read AL Event-Register from ESC */
2483:../SSC/Src/ecatslv.c ****     ALEventReg = HW_GetALEventRegister();
 5133              	 .loc 3 2483 0
 5134 0020 FFF7FEFF 	 bl HW_GetALEventRegister
 5135 0024 0346     	 mov r3,r0
 5136 0026 FB80     	 strh r3,[r7,#6]
2484:../SSC/Src/ecatslv.c ****     ALEventReg = SWAPWORD(ALEventReg);
2485:../SSC/Src/ecatslv.c **** 
2486:../SSC/Src/ecatslv.c ****     if ((ALEventReg & EEPROM_CMD_PENDING)) 
 5137              	 .loc 3 2486 0
 5138 0028 FB88     	 ldrh r3,[r7,#6]
 5139 002a 03F02003 	 and r3,r3,#32
 5140 002e 002B     	 cmp r3,#0
 5141 0030 01D0     	 beq .L361
2487:../SSC/Src/ecatslv.c ****     {
2488:../SSC/Src/ecatslv.c ****         EEPROM_CommandHandler();
 5142              	 .loc 3 2488 0
 5143 0032 FFF7FEFF 	 bl EEPROM_CommandHandler
 5144              	.L361:
2489:../SSC/Src/ecatslv.c ****     }
2490:../SSC/Src/ecatslv.c **** 
2491:../SSC/Src/ecatslv.c ****     if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
 5145              	 .loc 3 2491 0
 5146 0036 FB88     	 ldrh r3,[r7,#6]
 5147 0038 03F00103 	 and r3,r3,#1
 5148 003c 002B     	 cmp r3,#0
 5149 003e 14D0     	 beq .L362
 5150              	 .loc 3 2491 0 is_stmt 0 discriminator 1
 5151 0040 4E4B     	 ldr r3,.L371+8
 5152 0042 1B78     	 ldrb r3,[r3]
 5153 0044 83F00103 	 eor r3,r3,#1
 5154 0048 DBB2     	 uxtb r3,r3
 5155 004a 002B     	 cmp r3,#0
 5156 004c 0DD0     	 beq .L362
2492:../SSC/Src/ecatslv.c ****     {
2493:../SSC/Src/ecatslv.c ****         /* AL Control event is set, get the AL Control register sent by the Master to acknowledge t
2494:../SSC/Src/ecatslv.c ****           (that the corresponding bit in the AL Event register will be reset) */
2495:../SSC/Src/ecatslv.c ****         HW_EscReadByte( EscAlControl, ESC_AL_CONTROL_OFFSET);
 5157              	 .loc 3 2495 0 is_stmt 1
 5158 004e 4C4B     	 ldr r3,.L371+12
 5159 0050 1B78     	 ldrb r3,[r3]
 5160 0052 DBB2     	 uxtb r3,r3
 5161 0054 7B80     	 strh r3,[r7,#2]
2496:../SSC/Src/ecatslv.c ****         EscAlControl = SWAPWORD(EscAlControl);
2497:../SSC/Src/ecatslv.c **** 
2498:../SSC/Src/ecatslv.c **** 
2499:../SSC/Src/ecatslv.c ****         /* reset AL Control event and the SM Change event (because the Sync Manager settings will b
2500:../SSC/Src/ecatslv.c ****            in AL_ControlInd, too)*/
2501:../SSC/Src/ecatslv.c ****         ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
 5162              	 .loc 3 2501 0
 5163 0056 FB88     	 ldrh r3,[r7,#6]
 5164 0058 23F01103 	 bic r3,r3,#17
 5165 005c FB80     	 strh r3,[r7,#6]
2502:../SSC/Src/ecatslv.c **** 
2503:../SSC/Src/ecatslv.c ****         AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be che
 5166              	 .loc 3 2503 0
 5167 005e 7B88     	 ldrh r3,[r7,#2]
 5168 0060 DBB2     	 uxtb r3,r3
 5169 0062 1846     	 mov r0,r3
 5170 0064 0021     	 movs r1,#0
 5171 0066 FFF7FEFF 	 bl AL_ControlInd
 5172              	.L362:
2504:../SSC/Src/ecatslv.c ****         
2505:../SSC/Src/ecatslv.c ****         /* SM-Change-Event was handled too */
2506:../SSC/Src/ecatslv.c ****     }
2507:../SSC/Src/ecatslv.c **** 
2508:../SSC/Src/ecatslv.c ****     if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) 
 5173              	 .loc 3 2508 0
 5174 006a FB88     	 ldrh r3,[r7,#6]
 5175 006c 03F01003 	 and r3,r3,#16
 5176 0070 002B     	 cmp r3,#0
 5177 0072 1FD0     	 beq .L363
 5178              	 .loc 3 2508 0 is_stmt 0 discriminator 1
 5179 0074 414B     	 ldr r3,.L371+8
 5180 0076 1B78     	 ldrb r3,[r3]
 5181 0078 83F00103 	 eor r3,r3,#1
 5182 007c DBB2     	 uxtb r3,r3
 5183 007e 002B     	 cmp r3,#0
 5184 0080 18D0     	 beq .L363
 5185              	 .loc 3 2508 0 discriminator 2
 5186 0082 404B     	 ldr r3,.L371+16
 5187 0084 1B78     	 ldrb r3,[r3]
 5188 0086 03F01003 	 and r3,r3,#16
 5189 008a 002B     	 cmp r3,#0
 5190 008c 12D1     	 bne .L363
 5191              	 .loc 3 2508 0 discriminator 3
 5192 008e 3D4B     	 ldr r3,.L371+16
 5193 0090 1B78     	 ldrb r3,[r3]
 5194 0092 23F01003 	 bic r3,r3,#16
 5195 0096 012B     	 cmp r3,#1
 5196 0098 0CD0     	 beq .L363
2509:../SSC/Src/ecatslv.c ****     {
2510:../SSC/Src/ecatslv.c ****         /* the SM Change event is set (Bit 4 of Register 0x220), when the Byte 6 (Enable, Lo-Byte o
2511:../SSC/Src/ecatslv.c ****            of a Sync Manager channel was written */
2512:../SSC/Src/ecatslv.c ****         ALEventReg &= ~(SM_CHANGE_EVENT);
 5197              	 .loc 3 2512 0 is_stmt 1
 5198 009a FB88     	 ldrh r3,[r7,#6]
 5199 009c 23F01003 	 bic r3,r3,#16
 5200 00a0 FB80     	 strh r3,[r7,#6]
2513:../SSC/Src/ecatslv.c **** 
2514:../SSC/Src/ecatslv.c ****         /* AL_ControlInd is called with the actual state, so that the correct SM settings will be c
2515:../SSC/Src/ecatslv.c ****         AL_ControlInd(nAlStatus & STATE_MASK, 0);
 5201              	 .loc 3 2515 0
 5202 00a2 384B     	 ldr r3,.L371+16
 5203 00a4 1B78     	 ldrb r3,[r3]
 5204 00a6 03F00F03 	 and r3,r3,#15
 5205 00aa DBB2     	 uxtb r3,r3
 5206 00ac 1846     	 mov r0,r3
 5207 00ae 0021     	 movs r1,#0
 5208 00b0 FFF7FEFF 	 bl AL_ControlInd
 5209              	.L363:
2516:../SSC/Src/ecatslv.c ****     }
2517:../SSC/Src/ecatslv.c **** 
2518:../SSC/Src/ecatslv.c ****     if(bEcatWaitForAlControlRes)
 5210              	 .loc 3 2518 0
 5211 00b4 314B     	 ldr r3,.L371+8
 5212 00b6 1B78     	 ldrb r3,[r3]
 5213 00b8 002B     	 cmp r3,#0
 5214 00ba 01D0     	 beq .L364
2519:../SSC/Src/ecatslv.c ****     {
2520:../SSC/Src/ecatslv.c ****         AL_ControlRes();
 5215              	 .loc 3 2520 0
 5216 00bc FFF7FEFF 	 bl AL_ControlRes
 5217              	.L364:
2521:../SSC/Src/ecatslv.c ****     }
2522:../SSC/Src/ecatslv.c ****     /*The order of mailbox event processing was changed to prevent race condition errors.
2523:../SSC/Src/ecatslv.c ****         The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
2524:../SSC/Src/ecatslv.c ****         1. Handle Mailbox Read event
2525:../SSC/Src/ecatslv.c ****         2. Handle repeat toggle request
2526:../SSC/Src/ecatslv.c ****         3. Handle Mailbox write event
2527:../SSC/Src/ecatslv.c ****     */
2528:../SSC/Src/ecatslv.c ****     if ( bMbxRunning )
 5218              	 .loc 3 2528 0
 5219 00c0 2C4B     	 ldr r3,.L371
 5220 00c2 1B78     	 ldrb r3,[r3]
 5221 00c4 002B     	 cmp r3,#0
 5222 00c6 52D0     	 beq .L359
2529:../SSC/Src/ecatslv.c ****     {
2530:../SSC/Src/ecatslv.c ****         /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control regist
2531:../SSC/Src/ecatslv.c ****         => check if the SyncManger 1 is still enabled*/
2532:../SSC/Src/ecatslv.c ****             if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
 5223              	 .loc 3 2532 0
 5224 00c8 7B79     	 ldrb r3,[r7,#5]
 5225 00ca 03F00103 	 and r3,r3,#1
 5226 00ce 002B     	 cmp r3,#0
 5227 00d0 08D1     	 bne .L366
2533:../SSC/Src/ecatslv.c ****             {
2534:../SSC/Src/ecatslv.c ****                 AL_ControlInd(nAlStatus & STATE_MASK, 0);
 5228              	 .loc 3 2534 0
 5229 00d2 2C4B     	 ldr r3,.L371+16
 5230 00d4 1B78     	 ldrb r3,[r3]
 5231 00d6 03F00F03 	 and r3,r3,#15
 5232 00da DBB2     	 uxtb r3,r3
 5233 00dc 1846     	 mov r0,r3
 5234 00de 0021     	 movs r1,#0
 5235 00e0 FFF7FEFF 	 bl AL_ControlInd
 5236              	.L366:
2535:../SSC/Src/ecatslv.c ****             }
2536:../SSC/Src/ecatslv.c **** 
2537:../SSC/Src/ecatslv.c ****         if ( ALEventReg & (MAILBOX_READ_EVENT) )
 5237              	 .loc 3 2537 0
 5238 00e4 FB88     	 ldrh r3,[r7,#6]
 5239 00e6 03F40073 	 and r3,r3,#512
 5240 00ea 002B     	 cmp r3,#0
 5241 00ec 12D0     	 beq .L367
2538:../SSC/Src/ecatslv.c ****         {
2539:../SSC/Src/ecatslv.c ****             /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
2540:../SSC/Src/ecatslv.c ****                to acknowledge the event the first byte of the mailbox has to be written,
2541:../SSC/Src/ecatslv.c ****                by writing the first byte the mailbox is locked, too */
2542:../SSC/Src/ecatslv.c ****             u8dummy = 0;
 5242              	 .loc 3 2542 0
 5243 00ee 264B     	 ldr r3,.L371+20
 5244 00f0 0022     	 movs r2,#0
 5245 00f2 1A70     	 strb r2,[r3]
2543:../SSC/Src/ecatslv.c ****             HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
 5246              	 .loc 3 2543 0
 5247 00f4 254B     	 ldr r3,.L371+24
 5248 00f6 1B88     	 ldrh r3,[r3]
 5249 00f8 03F1A843 	 add r3,r3,#1409286144
 5250 00fc 03F58033 	 add r3,r3,#65536
 5251 0100 214A     	 ldr r2,.L371+20
 5252 0102 1278     	 ldrb r2,[r2]
 5253 0104 D2B2     	 uxtb r2,r2
 5254 0106 1A70     	 strb r2,[r3]
2544:../SSC/Src/ecatslv.c **** 
2545:../SSC/Src/ecatslv.c ****             /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
2546:../SSC/Src/ecatslv.c ****                MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in t
2547:../SSC/Src/ecatslv.c ****             ALEventReg &= ~(MAILBOX_READ_EVENT);
 5255              	 .loc 3 2547 0
 5256 0108 FB88     	 ldrh r3,[r7,#6]
 5257 010a 23F40073 	 bic r3,r3,#512
 5258 010e FB80     	 strh r3,[r7,#6]
2548:../SSC/Src/ecatslv.c ****             MBX_MailboxReadInd();
 5259              	 .loc 3 2548 0
 5260 0110 FFF7FEFF 	 bl MBX_MailboxReadInd
 5261              	.L367:
2549:../SSC/Src/ecatslv.c ****         }
2550:../SSC/Src/ecatslv.c **** 
2551:../SSC/Src/ecatslv.c ****         /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */
2552:../SSC/Src/ecatslv.c **** 
2553:../SSC/Src/ecatslv.c ****         if ( ( (sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle )
 5262              	 .loc 3 2553 0
 5263 0114 7B79     	 ldrb r3,[r7,#5]
 5264 0116 03F00203 	 and r3,r3,#2
 5265 011a 002B     	 cmp r3,#0
 5266 011c 06D0     	 beq .L368
 5267              	 .loc 3 2553 0 is_stmt 0 discriminator 1
 5268 011e 1C4B     	 ldr r3,.L371+28
 5269 0120 1B78     	 ldrb r3,[r3]
 5270 0122 83F00103 	 eor r3,r3,#1
 5271 0126 DBB2     	 uxtb r3,r3
 5272 0128 002B     	 cmp r3,#0
 5273 012a 08D1     	 bne .L369
 5274              	.L368:
2554:../SSC/Src/ecatslv.c ****             ||( !(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle ))
 5275              	 .loc 3 2554 0 is_stmt 1
 5276 012c 7B79     	 ldrb r3,[r7,#5]
 5277 012e 03F00203 	 and r3,r3,#2
 5278 0132 002B     	 cmp r3,#0
 5279 0134 0CD1     	 bne .L370
 5280              	 .loc 3 2554 0 is_stmt 0 discriminator 1
 5281 0136 164B     	 ldr r3,.L371+28
 5282 0138 1B78     	 ldrb r3,[r3]
 5283 013a 002B     	 cmp r3,#0
 5284 013c 08D0     	 beq .L370
 5285              	.L369:
2555:../SSC/Src/ecatslv.c ****         {
2556:../SSC/Src/ecatslv.c ****             /* Repeat Bit (Bit 1) has toggled, there is a repeat request, in MBX_MailboxRepeatReq t
2557:../SSC/Src/ecatslv.c ****                response will put in the send mailbox again */
2558:../SSC/Src/ecatslv.c ****             MBX_MailboxRepeatReq();
 5286              	 .loc 3 2558 0 is_stmt 1
 5287 013e FFF7FEFF 	 bl MBX_MailboxRepeatReq
2559:../SSC/Src/ecatslv.c ****             /* acknowledge the repeat request after the send mailbox was updated by writing the Rep
2560:../SSC/Src/ecatslv.c ****                in the Repeat Ack Bit (Bit 1) of the PDI Ctrl-Byte of SM 1 (Register 0x80F) */
2561:../SSC/Src/ecatslv.c ****             sm1Activate &= SM_SETTING_REPEAT_ACK;
 5288              	 .loc 3 2561 0
 5289 0142 7B79     	 ldrb r3,[r7,#5]
 5290 0144 03F00203 	 and r3,r3,#2
 5291 0148 7B71     	 strb r3,[r7,#5]
2562:../SSC/Src/ecatslv.c ****             HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
 5292              	 .loc 3 2562 0
 5293 014a 124A     	 ldr r2,.L371+32
 5294 014c 7B79     	 ldrb r3,[r7,#5]
 5295 014e 1370     	 strb r3,[r2]
 5296              	.L370:
2563:../SSC/Src/ecatslv.c ****         }
2564:../SSC/Src/ecatslv.c **** 
2565:../SSC/Src/ecatslv.c ****         /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an r
2566:../SSC/Src/ecatslv.c ****         ALEventReg = HW_GetALEventRegister();
 5297              	 .loc 3 2566 0
 5298 0150 FFF7FEFF 	 bl HW_GetALEventRegister
 5299 0154 0346     	 mov r3,r0
 5300 0156 FB80     	 strh r3,[r7,#6]
2567:../SSC/Src/ecatslv.c ****         ALEventReg = SWAPWORD(ALEventReg);
2568:../SSC/Src/ecatslv.c **** 
2569:../SSC/Src/ecatslv.c ****         if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
 5301              	 .loc 3 2569 0
 5302 0158 FB88     	 ldrh r3,[r7,#6]
 5303 015a 03F48073 	 and r3,r3,#256
 5304 015e 002B     	 cmp r3,#0
 5305 0160 05D0     	 beq .L359
2570:../SSC/Src/ecatslv.c ****         {
2571:../SSC/Src/ecatslv.c ****             /* SM 0 (Mailbox Write) event is set, when the mailbox was written from the master,
2572:../SSC/Src/ecatslv.c ****                to acknowledge the event the first byte of the mailbox has to be read,
2573:../SSC/Src/ecatslv.c ****                which will be done in MBX_CheckAndCopyMailbox */
2574:../SSC/Src/ecatslv.c ****             /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
2575:../SSC/Src/ecatslv.c ****                MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
2576:../SSC/Src/ecatslv.c ****             ALEventReg &= ~(MAILBOX_WRITE_EVENT);
 5306              	 .loc 3 2576 0
 5307 0162 FB88     	 ldrh r3,[r7,#6]
 5308 0164 23F48073 	 bic r3,r3,#256
 5309 0168 FB80     	 strh r3,[r7,#6]
2577:../SSC/Src/ecatslv.c ****             MBX_CheckAndCopyMailbox();
 5310              	 .loc 3 2577 0
 5311 016a FFF7FEFF 	 bl MBX_CheckAndCopyMailbox
 5312              	.L359:
2578:../SSC/Src/ecatslv.c **** 
2579:../SSC/Src/ecatslv.c ****         }
2580:../SSC/Src/ecatslv.c ****     }
2581:../SSC/Src/ecatslv.c **** }
 5313              	 .loc 3 2581 0
 5314 016e 0837     	 adds r7,r7,#8
 5315              	.LCFI111:
 5316              	 .cfi_def_cfa_offset 8
 5317 0170 BD46     	 mov sp,r7
 5318              	.LCFI112:
 5319              	 .cfi_def_cfa_register 13
 5320              	 
 5321 0172 80BD     	 pop {r7,pc}
 5322              	.L372:
 5323              	 .align 2
 5324              	.L371:
 5325 0174 00000000 	 .word bMbxRunning
 5326 0178 0E080154 	 .word 1409353742
 5327 017c 00000000 	 .word bEcatWaitForAlControlRes
 5328 0180 20010154 	 .word 1409351968
 5329 0184 00000000 	 .word nAlStatus
 5330 0188 00000000 	 .word u8dummy
 5331 018c 00000000 	 .word u16EscAddrSendMbx
 5332 0190 00000000 	 .word bMbxRepeatToggle
 5333 0194 0F080154 	 .word 1409353743
 5334              	 .cfi_endproc
 5335              	.LFE198:
 5337              	 .text
 5338              	.Letext0:
 5339              	 .file 4 "c:\\tools\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 5340              	 .file 5 "c:\\tools\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 5341              	 .file 6 "C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/CMSIS/Infineon/XMC4300_series/Include/XMC4300.h"
 5342              	 .file 7 "../SSC/Src/esc.h"
 5343              	 .file 8 "../SSC/Src/objdef.h"
 5344              	 .file 9 "C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/CMSIS/Include/cmsis_gcc.h"
 5345              	 .file 10 "C:/Users/Admin/DaveWorkspaces/XMC4300_Motor_Controller/Libraries/CMSIS/Include/core_cm4.h"
 5346              	 .file 11 "../SSC/Src/ecatslv.h"
 5347              	 .file 12 "../SSC/Src/mailbox.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ecatslv.c
    {standard input}:20     .text.XMC_ECAT_GetALEventRegister:00000000 $t
    {standard input}:24     .text.XMC_ECAT_GetALEventRegister:00000000 XMC_ECAT_GetALEventRegister
    {standard input}:57     .text.XMC_ECAT_GetALEventRegister:00000018 $d
    {standard input}:62     .text.HW_EscRead:00000000 $t
    {standard input}:66     .text.HW_EscRead:00000000 HW_EscRead
    {standard input}:110    .text.HW_GetALEventRegister:00000000 $t
    {standard input}:114    .text.HW_GetALEventRegister:00000000 HW_GetALEventRegister
                            *COM*:00000001 bEcatOutputUpdateRunning
                            *COM*:00000001 bEcatInputUpdateRunning
                            *COM*:00000001 bEcatFirstOutputsReceived
                            *COM*:00000001 bWdTrigger
                            *COM*:00000001 bDcSyncActive
                            *COM*:00000002 EsmTimeoutCounter
                            *COM*:00000001 bDcRunning
                            *COM*:00000002 u16SmSync0Counter
                            *COM*:00000002 u16SmSync0Value
                            *COM*:00000001 bSmSyncSequenceValid
                            *COM*:00000002 i16WaitForPllRunningTimeout
                            *COM*:00000002 i16WaitForPllRunningCnt
                            *COM*:00000002 Sync0WdCounter
                            *COM*:00000002 Sync0WdValue
                            *COM*:00000002 Sync1WdCounter
                            *COM*:00000002 Sync1WdValue
                            *COM*:00000002 LatchInputSync0Value
                            *COM*:00000002 LatchInputSync0Counter
                            *COM*:00000001 b32BitDc
                            *COM*:00000001 bEscIntEnabled
                            *COM*:00000001 b3BufferMode
                            *COM*:00000001 bLocalErrorFlag
                            *COM*:00000002 u16LocalErrorCode
                            *COM*:00000001 bApplEsmPending
                            *COM*:00000001 bEcatWaitForAlControlRes
                            *COM*:00000002 nEcatStateTrans
                            *COM*:00000001 u8EcatErrorLed
                            *COM*:00000001 u8EcatRunLed
                            *COM*:00000002 nPdInputSize
                            *COM*:00000002 nPdOutputSize
                            *COM*:00000001 nMaxSyncMan
                            *COM*:00000002 nMaxEscAddress
                            *COM*:00000001 nAlStatus
                            *COM*:00000002 EcatWdValue
                            *COM*:00000002 nEscAddrOutputData
                            *COM*:00000002 nEscAddrInputData
                            *COM*:00000002 u16ALEventMask
                            *COM*:00000001 u8dummy
    {standard input}:179    .bss.SMActivate:00000000 SMActivate
    {standard input}:180    .bss.SMActivate:00000000 $d
                            *COM*:00000008 SyncManInfo
    {standard input}:186    .bss.EepromLoaded:00000000 EepromLoaded
    {standard input}:187    .bss.EepromLoaded:00000000 $d
    {standard input}:189    .text.ResetALEventMask:00000000 $t
    {standard input}:194    .text.ResetALEventMask:00000000 ResetALEventMask
    {standard input}:243    .text.ResetALEventMask:0000002c $d
    {standard input}:248    .text.SetALEventMask:00000000 $t
    {standard input}:253    .text.SetALEventMask:00000000 SetALEventMask
    {standard input}:301    .text.SetALEventMask:0000002c $d
    {standard input}:306    .text.UpdateEEPROMLoadedState:00000000 $t
    {standard input}:311    .text.UpdateEEPROMLoadedState:00000000 UpdateEEPROMLoadedState
    {standard input}:373    .text.UpdateEEPROMLoadedState:0000003c $d
    {standard input}:379    .text.GetSyncMan:00000000 $t
    {standard input}:384    .text.GetSyncMan:00000000 GetSyncMan
    {standard input}:428    .text.GetSyncMan:0000002c $d
    {standard input}:433    .text.DisableSyncManChannel:00000000 $t
    {standard input}:438    .text.DisableSyncManChannel:00000000 DisableSyncManChannel
    {standard input}:505    .text.EnableSyncManChannel:00000000 $t
    {standard input}:510    .text.EnableSyncManChannel:00000000 EnableSyncManChannel
    {standard input}:577    .text.CheckSmSettings:00000000 $t
    {standard input}:582    .text.CheckSmSettings:00000000 CheckSmSettings
    {standard input}:1011   .text.CheckSmSettings:00000294 $d
    {standard input}:1018   .text.CheckSmSettings:000002a8 $t
    {standard input}:1194   .text.CheckSmSettings:000003a0 $d
    {standard input}:1205   .text.StartInputHandler:00000000 $t
    {standard input}:1210   .text.StartInputHandler:00000000 StartInputHandler
    {standard input}:1637   .text.StartInputHandler:000002ac $d
    {standard input}:1657   .text.StartInputHandler:000002f4 $t
    {standard input}:2095   .text.StartInputHandler:00000588 $d
    {standard input}:2114   .text.StartInputHandler:000005cc $t
    {standard input}:2371   .text.StartInputHandler:00000754 $d
    {standard input}:2392   .text.StartOutputHandler:00000000 $t
    {standard input}:2397   .text.StartOutputHandler:00000000 StartOutputHandler
    {standard input}:2477   .text.StartOutputHandler:00000058 $d
    {standard input}:2488   .text.StopOutputHandler:00000000 $t
    {standard input}:2493   .text.StopOutputHandler:00000000 StopOutputHandler
    {standard input}:2528   .text.StopOutputHandler:00000018 $d
    {standard input}:2534   .text.StopInputHandler:00000000 $t
    {standard input}:2539   .text.StopInputHandler:00000000 StopInputHandler
    {standard input}:2697   .text.StopInputHandler:000000d8 $d
    {standard input}:2722   .text.BackToInitTransition:00000000 $t
    {standard input}:2727   .text.BackToInitTransition:00000000 BackToInitTransition
    {standard input}:2758   .text.BackToInitTransition:00000014 $d
    {standard input}:2763   .text.SetALStatus:00000000 $t
    {standard input}:2768   .text.SetALStatus:00000000 SetALStatus
    {standard input}:2905   .text.SetALStatus:000000b0 $d
    {standard input}:2915   .text.AL_ControlInd:00000000 $t
    {standard input}:2920   .text.AL_ControlInd:00000000 AL_ControlInd
    {standard input}:3094   .text.AL_ControlInd:00000110 $d
    {standard input}:3214   .text.AL_ControlInd:000002f0 $t
    {standard input}:3297   .text.AL_ControlInd:00000368 $d
    {standard input}:3307   .text.AL_ControlInd:0000038c $t
    {standard input}:3767   .text.AL_ControlInd:00000650 $d
    {standard input}:3780   .text.AL_ControlInd:0000067c $t
    {standard input}:3832   .text.AL_ControlInd:000006c4 $d
    {standard input}:3838   .text.AL_ControlRes:00000000 $t
    {standard input}:3843   .text.AL_ControlRes:00000000 AL_ControlRes
    {standard input}:4292   .text.AL_ControlRes:0000028c $d
    {standard input}:4312   .text.DC_CheckWatchdog:00000000 $t
    {standard input}:4317   .text.DC_CheckWatchdog:00000000 DC_CheckWatchdog
    {standard input}:4488   .text.DC_CheckWatchdog:000000ec $d
    {standard input}:4504   .text.CheckIfEcatError:00000000 $t
    {standard input}:4509   .text.CheckIfEcatError:00000000 CheckIfEcatError
    {standard input}:4617   .text.CheckIfEcatError:00000088 $d
    {standard input}:4629   .text.ECAT_StateChange:00000000 $t
    {standard input}:4634   .text.ECAT_StateChange:00000000 ECAT_StateChange
    {standard input}:4875   .text.ECAT_StateChange:00000158 $d
    {standard input}:4890   .text.ECAT_Init:00000000 $t
    {standard input}:4895   .text.ECAT_Init:00000000 ECAT_Init
    {standard input}:5064   .text.ECAT_Init:000000ec $d
    {standard input}:5093   .text.ECAT_Main:00000000 $t
    {standard input}:5098   .text.ECAT_Main:00000000 ECAT_Main
    {standard input}:5325   .text.ECAT_Main:00000174 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memcpy
DISABLE_ESC_INT
ENABLE_ESC_INT
sSyncManOutPar
sSyncManInPar
u16EscAddrSendMbx
u16SendMbxSize
u16EscAddrReceiveMbx
u16ReceiveMbxSize
bSyncSetByUser
sCycleDiag
PDO_InputMapping
APPL_GenerateMapping
MBX_StartMailboxHandler
APPL_StartMailboxHandler
APPL_StopMailboxHandler
MBX_StopMailboxHandler
bMbxRunning
APPL_StartInputHandler
APPL_StopInputHandler
APPL_StartOutputHandler
APPL_StopOutputHandler
APPL_AckErrorInd
sErrorSettings
MBX_Init
COE_Init
MBX_Main
EEPROM_CommandHandler
MBX_MailboxReadInd
MBX_MailboxRepeatReq
MBX_CheckAndCopyMailbox
bMbxRepeatToggle
